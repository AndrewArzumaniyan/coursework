/home/dvmuser3/andrey/npb-3.3-c/LU/applu.incl:
    1|       |//---------------------------------------------------------------------
    2|       |//---------------------------------------------------------------------
    3|       |//---  applu.incl   
    4|       |//---------------------------------------------------------------------
    5|       |//---------------------------------------------------------------------
    6|       |
    7|       |//---------------------------------------------------------------------
    8|       |// npbparams.h defines parameters that depend on the class and 
    9|       |// number of nodes
   10|       |//---------------------------------------------------------------------
   11|       |
   12|       |#include "npbparams.h"
   13|       |#include "type.h"
   14|       |
   15|       |//---------------------------------------------------------------------
   16|       |// parameters which can be overridden in runtime config file
   17|       |// isiz1,isiz2,isiz3 give the maximum size
   18|       |// ipr = 1 to print out verbose information
   19|       |// omega = 2.0 is correct for all classes
   20|       |// tolrsd is tolerance levels for steady state residuals
   21|       |//---------------------------------------------------------------------
   22|      1|#define IPR_DEFAULT     1
   23|      1|#define OMEGA_DEFAULT   1.2
   24|      1|#define TOLRSD1_DEF     1.0e-08
   25|      1|#define TOLRSD2_DEF     1.0e-08
   26|      1|#define TOLRSD3_DEF     1.0e-08
   27|      1|#define TOLRSD4_DEF     1.0e-08
   28|      1|#define TOLRSD5_DEF     1.0e-08
   29|       |
   30|  2.46G|#define C1              1.40e+00
   31|  4.31G|#define C2              0.40e+00
   32|   965M|#define C3              1.00e-01
   33|   965M|#define C4              1.00e+00
   34|   846M|#define C5              1.40e+00
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// grid
   38|       |//---------------------------------------------------------------------
   39|       |/* common/cgcon/ */
   40|       |extern double dxi, deta, dzeta;
   41|       |extern double tx1, tx2, tx3;
   42|       |extern double ty1, ty2, ty3;
   43|       |extern double tz1, tz2, tz3;
   44|       |extern int nx, ny, nz;
   45|       |extern int nx0, ny0, nz0;
   46|       |extern int ist, iend;
   47|       |extern int jst, jend;
   48|       |extern int ii1, ii2;
   49|       |extern int ji1, ji2;
   50|       |extern int ki1, ki2;
   51|       |
   52|       |//---------------------------------------------------------------------
   53|       |// dissipation
   54|       |//---------------------------------------------------------------------
   55|       |/* common/disp/ */
   56|       |extern double dx1, dx2, dx3, dx4, dx5;
   57|       |extern double dy1, dy2, dy3, dy4, dy5;
   58|       |extern double dz1, dz2, dz3, dz4, dz5;
   59|       |extern double dssp;
   60|       |
   61|       |//---------------------------------------------------------------------
   62|       |// field variables and residuals
   63|       |// to improve cache performance, second two dimensions padded by 1 
   64|       |// for even number sizes only.
   65|       |// Note: corresponding array (called "v") in routines blts, buts, 
   66|       |// and l2norm are similarly padded
   67|       |//---------------------------------------------------------------------
   68|       |/* common/cvar/ */
   69|       |#pragma dvm array
   70|       |extern double u    [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   71|       |#pragma dvm array
   72|       |extern double rsd  [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   73|       |#pragma dvm array
   74|       |extern double frct [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   75|       |extern double flux [ISIZ1][5];
   76|       |#pragma dvm array
   77|       |extern double qs   [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
   78|       |#pragma dvm array
   79|       |extern double rho_i[ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
   80|       |
   81|       |//---------------------------------------------------------------------
   82|       |// output control parameters
   83|       |//---------------------------------------------------------------------
   84|       |/* common/cprcon/ */
   85|       |extern int ipr, inorm;
   86|       |
   87|       |//---------------------------------------------------------------------
   88|       |// newton-raphson iteration control parameters
   89|       |//---------------------------------------------------------------------
   90|       |/* common/ctscon/ */
   91|       |extern double dt, omega, tolrsd[5], rsdnm[5], errnm[5], frc, ttotal;
   92|       |extern int itmax, invert;
   93|       |
   94|       |/* common/cjac/ */
   95|       |extern double a[ISIZ2][ISIZ1/2*2+1][5][5];
   96|       |extern double b[ISIZ2][ISIZ1/2*2+1][5][5];
   97|       |extern double c[ISIZ2][ISIZ1/2*2+1][5][5];
   98|       |extern double d[ISIZ2][ISIZ1/2*2+1][5][5];
   99|       |
  100|       |//#pragma dvm template [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1] distribute [][][]
  101|       |#pragma dvm template [ISIZ3+2][ISIZ3+2][ISIZ3+2] distribute [block][block][block]
  102|       |extern void *dvm_tpl;
  103|       |
  104|       |//---------------------------------------------------------------------
  105|       |// coefficients of the exact solution
  106|       |//---------------------------------------------------------------------
  107|       |/* common/cexact/ */
  108|       |extern double ce[5][13];
  109|       |
  110|       |
  111|       |//---------------------------------------------------------------------
  112|       |// timers
  113|       |//---------------------------------------------------------------------
  114|       |/* common/timer/ */
  115|       |extern double maxtime;
  116|       |extern logical timeron;
  117|      0|#define t_total   1
  118|      0|#define t_rhsx    2
  119|      0|#define t_rhsy    3
  120|      0|#define t_rhsz    4
  121|      0|#define t_rhs     5
  122|      0|#define t_jacld   6
  123|      0|#define t_blts    7
  124|      0|#define t_jacu    8
  125|      0|#define t_buts    9
  126|      0|#define t_add     10
  127|      0|#define t_l2norm  11
  128|     48|#define t_last    11
  129|       |
  130|       |
  131|       |void read_input();
  132|       |void domain();
  133|       |void setcoeff();
  134|       |void setbv();
  135|       |void exact(int i, int j, int k, double u000ijk[]);
  136|       |void setiv();
  137|       |void erhs();
  138|       |void ssor(int niter);
  139|       |void rhs();
  140|       |#pragma dvm inherit(v)
  141|       |void l2norm (int ldx, int ldy, int ldz, int nx0, int ny0, int nz0,
  142|       |     int ist, int iend, int jst, int jend,
  143|       |     double v[][ldy/2*2+1][ldx/2*2+1][5], double sum[5]);
  144|       |void jacld(int k);
  145|       |void blts (int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
  146|       |    double omega,
  147|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5], 
  148|       |    double ldz[ldmy][ldmx/2*2+1][5][5],
  149|       |    double ldy[ldmy][ldmx/2*2+1][5][5],
  150|       |    double ldx[ldmy][ldmx/2*2+1][5][5],
  151|       |    double d[ldmy][ldmx/2*2+1][5][5],
  152|       |    int ist, int iend, int jst, int jend, int nx0, int ny0);
  153|       |void jacu(int k);
  154|       |void buts(int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
  155|       |    double omega,
  156|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5],
  157|       |    double tv[ldmy][ldmx/2*2+1][5],
  158|       |    double d[ldmy][ldmx/2*2+1][5][5],
  159|       |    double udx[ldmy][ldmx/2*2+1][5][5],
  160|       |    double udy[ldmy][ldmx/2*2+1][5][5],
  161|       |    double udz[ldmy][ldmx/2*2+1][5][5],
  162|       |    int ist, int iend, int jst, int jend, int nx0, int ny0);
  163|       |void error();
  164|       |void pintgr();
  165|       |void verify(double xcr[5], double xce[5], double xci, 
  166|       |            char *Class, logical *verified);
  167|       |
  168|       |
  169|       |//---------------------------------------------------------------------
  170|       |//   end of include file
  171|       |//---------------------------------------------------------------------

/home/dvmuser3/andrey/npb-3.3-c/LU/blts.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |//---------------------------------------------------------------------
   35|       |// 
   36|       |// compute the regular-sparse, block lower triangular solution:
   37|       |// 
   38|       |// v <-- ( L-inv ) * v
   39|       |// 
   40|       |//---------------------------------------------------------------------
   41|       |//---------------------------------------------------------------------
   42|       |// To improve cache performance, second two dimensions padded by 1 
   43|       |// for even number sizes only.  Only needed in v.
   44|       |//---------------------------------------------------------------------
   45|       |void blts (int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
   46|       |    double omega,
   47|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5], 
   48|       |    double ldz[ldmy][ldmx/2*2+1][5][5],
   49|       |    double ldy[ldmy][ldmx/2*2+1][5][5],
   50|       |    double ldx[ldmy][ldmx/2*2+1][5][5],
   51|       |    double d[ldmy][ldmx/2*2+1][5][5],
   52|       |    int ist, int iend, int jst, int jend, int nx0, int ny0)
   53|      0|{
   54|      0|#pragma dvm interval
   55|       |  //---------------------------------------------------------------------
   56|       |  // local variables
   57|       |  //---------------------------------------------------------------------
   58|      0|  int i, j, m;
   59|      0|  double tmp, tmp1;
   60|      0|  double tmat[5][5], tv[5];
   61|       |
   62|       |  // Since gcc 4.4.3 generates the following warning for v:
   63|       |  // warning: '({anonymous})' may be used uninitialized in this function
   64|       |  // we use casted pointers.
   65|      0|  double (*vk)[ldmx/2*2+1][5] = v[k];
   66|      0|  double (*vkm1)[ldmx/2*2+1][5] = v[k-1];
   67|       |
   68|      0|  for (j = jst; j < jend; j++) {
   69|      0|    for (i = ist; i < iend; i++) {
   70|      0|      for (m = 0; m < 5; m++) {
   71|      0|        vk[j][i][m] =  vk[j][i][m]
   72|      0|          - omega * (  ldz[j][i][0][m] * vkm1[j][i][0]
   73|      0|                     + ldz[j][i][1][m] * vkm1[j][i][1]
   74|      0|                     + ldz[j][i][2][m] * vkm1[j][i][2]
   75|      0|                     + ldz[j][i][3][m] * vkm1[j][i][3]
   76|      0|                     + ldz[j][i][4][m] * vkm1[j][i][4] );
   77|      0|      }
   78|      0|    }
   79|      0|  }
   80|       |
   81|      0|  for (j = jst; j < jend; j++) {
   82|      0|    for (i = ist; i < iend; i++) {
   83|      0|      for (m = 0; m < 5; m++) {
   84|      0|        tv[m] =  vk[j][i][m]
   85|      0|          - omega * ( ldy[j][i][0][m] * vk[j-1][i][0]
   86|      0|                    + ldx[j][i][0][m] * vk[j][i-1][0]
   87|      0|                    + ldy[j][i][1][m] * vk[j-1][i][1]
   88|      0|                    + ldx[j][i][1][m] * vk[j][i-1][1]
   89|      0|                    + ldy[j][i][2][m] * vk[j-1][i][2]
   90|      0|                    + ldx[j][i][2][m] * vk[j][i-1][2]
   91|      0|                    + ldy[j][i][3][m] * vk[j-1][i][3]
   92|      0|                    + ldx[j][i][3][m] * vk[j][i-1][3]
   93|      0|                    + ldy[j][i][4][m] * vk[j-1][i][4]
   94|      0|                    + ldx[j][i][4][m] * vk[j][i-1][4] );
   95|      0|      }
   96|       |
   97|       |      //---------------------------------------------------------------------
   98|       |      // diagonal block inversion
   99|       |      // 
  100|       |      // forward elimination
  101|       |      //---------------------------------------------------------------------
  102|      0|      for (m = 0; m < 5; m++) {
  103|      0|        tmat[m][0] = d[j][i][0][m];
  104|      0|        tmat[m][1] = d[j][i][1][m];
  105|      0|        tmat[m][2] = d[j][i][2][m];
  106|      0|        tmat[m][3] = d[j][i][3][m];
  107|      0|        tmat[m][4] = d[j][i][4][m];
  108|      0|      }
  109|       |
  110|      0|      tmp1 = 1.0 / tmat[0][0];
  111|      0|      tmp = tmp1 * tmat[1][0];
  112|      0|      tmat[1][1] =  tmat[1][1] - tmp * tmat[0][1];
  113|      0|      tmat[1][2] =  tmat[1][2] - tmp * tmat[0][2];
  114|      0|      tmat[1][3] =  tmat[1][3] - tmp * tmat[0][3];
  115|      0|      tmat[1][4] =  tmat[1][4] - tmp * tmat[0][4];
  116|      0|      tv[1] = tv[1] - tv[0] * tmp;
  117|       |
  118|      0|      tmp = tmp1 * tmat[2][0];
  119|      0|      tmat[2][1] =  tmat[2][1] - tmp * tmat[0][1];
  120|      0|      tmat[2][2] =  tmat[2][2] - tmp * tmat[0][2];
  121|      0|      tmat[2][3] =  tmat[2][3] - tmp * tmat[0][3];
  122|      0|      tmat[2][4] =  tmat[2][4] - tmp * tmat[0][4];
  123|      0|      tv[2] = tv[2] - tv[0] * tmp;
  124|       |
  125|      0|      tmp = tmp1 * tmat[3][0];
  126|      0|      tmat[3][1] =  tmat[3][1] - tmp * tmat[0][1];
  127|      0|      tmat[3][2] =  tmat[3][2] - tmp * tmat[0][2];
  128|      0|      tmat[3][3] =  tmat[3][3] - tmp * tmat[0][3];
  129|      0|      tmat[3][4] =  tmat[3][4] - tmp * tmat[0][4];
  130|      0|      tv[3] = tv[3] - tv[0] * tmp;
  131|       |
  132|      0|      tmp = tmp1 * tmat[4][0];
  133|      0|      tmat[4][1] =  tmat[4][1] - tmp * tmat[0][1];
  134|      0|      tmat[4][2] =  tmat[4][2] - tmp * tmat[0][2];
  135|      0|      tmat[4][3] =  tmat[4][3] - tmp * tmat[0][3];
  136|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[0][4];
  137|      0|      tv[4] = tv[4] - tv[0] * tmp;
  138|       |
  139|      0|      tmp1 = 1.0 / tmat[1][1];
  140|      0|      tmp = tmp1 * tmat[2][1];
  141|      0|      tmat[2][2] =  tmat[2][2] - tmp * tmat[1][2];
  142|      0|      tmat[2][3] =  tmat[2][3] - tmp * tmat[1][3];
  143|      0|      tmat[2][4] =  tmat[2][4] - tmp * tmat[1][4];
  144|      0|      tv[2] = tv[2] - tv[1] * tmp;
  145|       |
  146|      0|      tmp = tmp1 * tmat[3][1];
  147|      0|      tmat[3][2] =  tmat[3][2] - tmp * tmat[1][2];
  148|      0|      tmat[3][3] =  tmat[3][3] - tmp * tmat[1][3];
  149|      0|      tmat[3][4] =  tmat[3][4] - tmp * tmat[1][4];
  150|      0|      tv[3] = tv[3] - tv[1] * tmp;
  151|       |
  152|      0|      tmp = tmp1 * tmat[4][1];
  153|      0|      tmat[4][2] =  tmat[4][2] - tmp * tmat[1][2];
  154|      0|      tmat[4][3] =  tmat[4][3] - tmp * tmat[1][3];
  155|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[1][4];
  156|      0|      tv[4] = tv[4] - tv[1] * tmp;
  157|       |
  158|      0|      tmp1 = 1.0 / tmat[2][2];
  159|      0|      tmp = tmp1 * tmat[3][2];
  160|      0|      tmat[3][3] =  tmat[3][3] - tmp * tmat[2][3];
  161|      0|      tmat[3][4] =  tmat[3][4] - tmp * tmat[2][4];
  162|      0|      tv[3] = tv[3] - tv[2] * tmp;
  163|       |
  164|      0|      tmp = tmp1 * tmat[4][2];
  165|      0|      tmat[4][3] =  tmat[4][3] - tmp * tmat[2][3];
  166|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[2][4];
  167|      0|      tv[4] = tv[4] - tv[2] * tmp;
  168|       |
  169|      0|      tmp1 = 1.0 / tmat[3][3];
  170|      0|      tmp = tmp1 * tmat[4][3];
  171|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[3][4];
  172|      0|      tv[4] = tv[4] - tv[3] * tmp;
  173|       |
  174|       |      //---------------------------------------------------------------------
  175|       |      // back substitution
  176|       |      //---------------------------------------------------------------------
  177|      0|      vk[j][i][4] = tv[4] / tmat[4][4];
  178|       |
  179|      0|      tv[3] = tv[3] 
  180|      0|        - tmat[3][4] * vk[j][i][4];
  181|      0|      vk[j][i][3] = tv[3] / tmat[3][3];
  182|       |
  183|      0|      tv[2] = tv[2]
  184|      0|        - tmat[2][3] * vk[j][i][3]
  185|      0|        - tmat[2][4] * vk[j][i][4];
  186|      0|      vk[j][i][2] = tv[2] / tmat[2][2];
  187|       |
  188|      0|      tv[1] = tv[1]
  189|      0|        - tmat[1][2] * vk[j][i][2]
  190|      0|        - tmat[1][3] * vk[j][i][3]
  191|      0|        - tmat[1][4] * vk[j][i][4];
  192|      0|      vk[j][i][1] = tv[1] / tmat[1][1];
  193|       |
  194|      0|      tv[0] = tv[0]
  195|      0|        - tmat[0][1] * vk[j][i][1]
  196|      0|        - tmat[0][2] * vk[j][i][2]
  197|      0|        - tmat[0][3] * vk[j][i][3]
  198|      0|        - tmat[0][4] * vk[j][i][4];
  199|      0|      vk[j][i][0] = tv[0] / tmat[0][0];
  200|      0|    }
  201|      0|  }
  202|      0|#pragma dvm endinterval
  203|      0|}
  204|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/buts.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |//---------------------------------------------------------------------
   35|       |// 
   36|       |// compute the regular-sparse, block upper triangular solution:
   37|       |// 
   38|       |// v <-- ( U-inv ) * v
   39|       |// 
   40|       |//---------------------------------------------------------------------
   41|       |//---------------------------------------------------------------------
   42|       |// To improve cache performance, second two dimensions padded by 1 
   43|       |// for even number sizes only.  Only needed in v.
   44|       |//---------------------------------------------------------------------
   45|       |void buts(int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
   46|       |    double omega,
   47|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5],
   48|       |    double tv[ldmy][ldmx/2*2+1][5],
   49|       |    double d[ldmy][ldmx/2*2+1][5][5],
   50|       |    double udx[ldmy][ldmx/2*2+1][5][5],
   51|       |    double udy[ldmy][ldmx/2*2+1][5][5],
   52|       |    double udz[ldmy][ldmx/2*2+1][5][5],
   53|       |    int ist, int iend, int jst, int jend, int nx0, int ny0)
   54|      0|{
   55|      0|#pragma dvm interval
   56|       |  //---------------------------------------------------------------------
   57|       |  // local variables
   58|       |  //---------------------------------------------------------------------
   59|      0|  int i, j, m;
   60|      0|  double tmp, tmp1;
   61|      0|  double tmat[5][5];
   62|       |
   63|      0|  for (j = jend - 1; j >= jst; j--) {
   64|      0|    for (i = iend - 1; i >= ist; i--) {
   65|      0|      for (m = 0; m < 5; m++) {
   66|      0|        tv[j][i][m] = 
   67|      0|          omega * (  udz[j][i][0][m] * v[k+1][j][i][0]
   68|      0|                   + udz[j][i][1][m] * v[k+1][j][i][1]
   69|      0|                   + udz[j][i][2][m] * v[k+1][j][i][2]
   70|      0|                   + udz[j][i][3][m] * v[k+1][j][i][3]
   71|      0|                   + udz[j][i][4][m] * v[k+1][j][i][4] );
   72|      0|      }
   73|      0|    }
   74|      0|  }
   75|       |
   76|      0|  for (j = jend - 1; j >= jst; j--) {
   77|      0|    for (i = iend - 1; i >= ist; i--) {
   78|      0|      for (m = 0; m < 5; m++) {
   79|      0|        tv[j][i][m] = tv[j][i][m]
   80|      0|          + omega * ( udy[j][i][0][m] * v[k][j+1][i][0]
   81|      0|                    + udx[j][i][0][m] * v[k][j][i+1][0]
   82|      0|                    + udy[j][i][1][m] * v[k][j+1][i][1]
   83|      0|                    + udx[j][i][1][m] * v[k][j][i+1][1]
   84|      0|                    + udy[j][i][2][m] * v[k][j+1][i][2]
   85|      0|                    + udx[j][i][2][m] * v[k][j][i+1][2]
   86|      0|                    + udy[j][i][3][m] * v[k][j+1][i][3]
   87|      0|                    + udx[j][i][3][m] * v[k][j][i+1][3]
   88|      0|                    + udy[j][i][4][m] * v[k][j+1][i][4]
   89|      0|                    + udx[j][i][4][m] * v[k][j][i+1][4] );
   90|      0|      }
   91|       |
   92|       |      //---------------------------------------------------------------------
   93|       |      // diagonal block inversion
   94|       |      //---------------------------------------------------------------------
   95|      0|      for (m = 0; m < 5; m++) {
   96|      0|        tmat[m][0] = d[j][i][0][m];
   97|      0|        tmat[m][1] = d[j][i][1][m];
   98|      0|        tmat[m][2] = d[j][i][2][m];
   99|      0|        tmat[m][3] = d[j][i][3][m];
  100|      0|        tmat[m][4] = d[j][i][4][m];
  101|      0|      }
  102|       |
  103|      0|      tmp1 = 1.0 / tmat[0][0];
  104|      0|      tmp = tmp1 * tmat[1][0];
  105|      0|      tmat[1][1] =  tmat[1][1] - tmp * tmat[0][1];
  106|      0|      tmat[1][2] =  tmat[1][2] - tmp * tmat[0][2];
  107|      0|      tmat[1][3] =  tmat[1][3] - tmp * tmat[0][3];
  108|      0|      tmat[1][4] =  tmat[1][4] - tmp * tmat[0][4];
  109|      0|      tv[j][i][1] = tv[j][i][1] - tv[j][i][0] * tmp;
  110|       |
  111|      0|      tmp = tmp1 * tmat[2][0];
  112|      0|      tmat[2][1] =  tmat[2][1] - tmp * tmat[0][1];
  113|      0|      tmat[2][2] =  tmat[2][2] - tmp * tmat[0][2];
  114|      0|      tmat[2][3] =  tmat[2][3] - tmp * tmat[0][3];
  115|      0|      tmat[2][4] =  tmat[2][4] - tmp * tmat[0][4];
  116|      0|      tv[j][i][2] = tv[j][i][2] - tv[j][i][0] * tmp;
  117|       |
  118|      0|      tmp = tmp1 * tmat[3][0];
  119|      0|      tmat[3][1] =  tmat[3][1] - tmp * tmat[0][1];
  120|      0|      tmat[3][2] =  tmat[3][2] - tmp * tmat[0][2];
  121|      0|      tmat[3][3] =  tmat[3][3] - tmp * tmat[0][3];
  122|      0|      tmat[3][4] =  tmat[3][4] - tmp * tmat[0][4];
  123|      0|      tv[j][i][3] = tv[j][i][3] - tv[j][i][0] * tmp;
  124|       |
  125|      0|      tmp = tmp1 * tmat[4][0];
  126|      0|      tmat[4][1] =  tmat[4][1] - tmp * tmat[0][1];
  127|      0|      tmat[4][2] =  tmat[4][2] - tmp * tmat[0][2];
  128|      0|      tmat[4][3] =  tmat[4][3] - tmp * tmat[0][3];
  129|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[0][4];
  130|      0|      tv[j][i][4] = tv[j][i][4] - tv[j][i][0] * tmp;
  131|       |
  132|      0|      tmp1 = 1.0 / tmat[1][1];
  133|      0|      tmp = tmp1 * tmat[2][1];
  134|      0|      tmat[2][2] =  tmat[2][2] - tmp * tmat[1][2];
  135|      0|      tmat[2][3] =  tmat[2][3] - tmp * tmat[1][3];
  136|      0|      tmat[2][4] =  tmat[2][4] - tmp * tmat[1][4];
  137|      0|      tv[j][i][2] = tv[j][i][2] - tv[j][i][1] * tmp;
  138|       |
  139|      0|      tmp = tmp1 * tmat[3][1];
  140|      0|      tmat[3][2] =  tmat[3][2] - tmp * tmat[1][2];
  141|      0|      tmat[3][3] =  tmat[3][3] - tmp * tmat[1][3];
  142|      0|      tmat[3][4] =  tmat[3][4] - tmp * tmat[1][4];
  143|      0|      tv[j][i][3] = tv[j][i][3] - tv[j][i][1] * tmp;
  144|       |
  145|      0|      tmp = tmp1 * tmat[4][1];
  146|      0|      tmat[4][2] =  tmat[4][2] - tmp * tmat[1][2];
  147|      0|      tmat[4][3] =  tmat[4][3] - tmp * tmat[1][3];
  148|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[1][4];
  149|      0|      tv[j][i][4] = tv[j][i][4] - tv[j][i][1] * tmp;
  150|       |
  151|      0|      tmp1 = 1.0 / tmat[2][2];
  152|      0|      tmp = tmp1 * tmat[3][2];
  153|      0|      tmat[3][3] =  tmat[3][3] - tmp * tmat[2][3];
  154|      0|      tmat[3][4] =  tmat[3][4] - tmp * tmat[2][4];
  155|      0|      tv[j][i][3] = tv[j][i][3] - tv[j][i][2] * tmp;
  156|       |
  157|      0|      tmp = tmp1 * tmat[4][2];
  158|      0|      tmat[4][3] =  tmat[4][3] - tmp * tmat[2][3];
  159|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[2][4];
  160|      0|      tv[j][i][4] = tv[j][i][4] - tv[j][i][2] * tmp;
  161|       |
  162|      0|      tmp1 = 1.0 / tmat[3][3];
  163|      0|      tmp = tmp1 * tmat[4][3];
  164|      0|      tmat[4][4] =  tmat[4][4] - tmp * tmat[3][4];
  165|      0|      tv[j][i][4] = tv[j][i][4] - tv[j][i][3] * tmp;
  166|       |
  167|       |      //---------------------------------------------------------------------
  168|       |      // back substitution
  169|       |      //---------------------------------------------------------------------
  170|      0|      tv[j][i][4] = tv[j][i][4] / tmat[4][4];
  171|       |
  172|      0|      tv[j][i][3] = tv[j][i][3] - tmat[3][4] * tv[j][i][4];
  173|      0|      tv[j][i][3] = tv[j][i][3] / tmat[3][3];
  174|       |
  175|      0|      tv[j][i][2] = tv[j][i][2]
  176|      0|        - tmat[2][3] * tv[j][i][3]
  177|      0|        - tmat[2][4] * tv[j][i][4];
  178|      0|      tv[j][i][2] = tv[j][i][2] / tmat[2][2];
  179|       |
  180|      0|      tv[j][i][1] = tv[j][i][1]
  181|      0|        - tmat[1][2] * tv[j][i][2]
  182|      0|        - tmat[1][3] * tv[j][i][3]
  183|      0|        - tmat[1][4] * tv[j][i][4];
  184|      0|      tv[j][i][1] = tv[j][i][1] / tmat[1][1];
  185|       |
  186|      0|      tv[j][i][0] = tv[j][i][0]
  187|      0|        - tmat[0][1] * tv[j][i][1]
  188|      0|        - tmat[0][2] * tv[j][i][2]
  189|      0|        - tmat[0][3] * tv[j][i][3]
  190|      0|        - tmat[0][4] * tv[j][i][4];
  191|      0|      tv[j][i][0] = tv[j][i][0] / tmat[0][0];
  192|       |
  193|      0|      v[k][j][i][0] = v[k][j][i][0] - tv[j][i][0];
  194|      0|      v[k][j][i][1] = v[k][j][i][1] - tv[j][i][1];
  195|      0|      v[k][j][i][2] = v[k][j][i][2] - tv[j][i][2];
  196|      0|      v[k][j][i][3] = v[k][j][i][3] - tv[j][i][3];
  197|      0|      v[k][j][i][4] = v[k][j][i][4] - tv[j][i][4];
  198|      0|    }
  199|      0|  }
  200|      0|#pragma dvm endinterval
  201|      0|}
  202|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/domain.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <stdlib.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |void domain()
   39|      1|{
   40|       |  //---------------------------------------------------------------------
   41|       |  // local variables
   42|       |  //---------------------------------------------------------------------
   43|      1|  nx = nx0;
   44|      1|  ny = ny0;
   45|      1|  nz = nz0;
   46|       |
   47|       |  //---------------------------------------------------------------------
   48|       |  // check the sub-domain size
   49|       |  //---------------------------------------------------------------------
   50|      1|  if ( ( nx < 4 ) || ( ny < 4 ) || ( nz < 4 ) ) {
   51|      0|    printf("     SUBDOMAIN SIZE IS TOO SMALL - \n"
   52|      0|           "     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\n"
   53|      0|           "     SO THAT NX, NY AND NZ ARE GREATER THAN OR EQUAL\n"
   54|      0|           "     TO 4 THEY ARE CURRENTLY%3d%3d%3d\n", nx, ny, nz);
   55|      0|    exit(EXIT_FAILURE);
   56|      0|  }
   57|       |
   58|      1|  if ( ( nx > ISIZ1 ) || ( ny > ISIZ2 ) || ( nz > ISIZ3 ) ) {
   59|      0|    printf("     SUBDOMAIN SIZE IS TOO LARGE - \n"
   60|      0|           "     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\n"
   61|      0|           "     SO THAT NX, NY AND NZ ARE LESS THAN OR EQUAL TO \n"
   62|      0|           "     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY.  THEY ARE\n"
   63|      0|           "     CURRENTLYi%4d%4d%4d\n", nx, ny, nz);
   64|      0|    exit(EXIT_FAILURE);
   65|      0|  }
   66|       |
   67|       |  //---------------------------------------------------------------------
   68|       |  // set up the start and end in i and j extents for all processors
   69|       |  //---------------------------------------------------------------------
   70|      1|  ist = 1;
   71|      1|  iend = nx - 1;
   72|       |
   73|      1|  jst = 1;
   74|      1|  jend = ny - 1;
   75|       |
   76|      1|  ii1 = 1;
   77|      1|  ii2 = nx0 - 1;
   78|      1|  ji1 = 1;
   79|      1|  ji2 = ny0 - 2;
   80|      1|  ki1 = 2;
   81|      1|  ki2 = nz0 - 1;
   82|      1|}

/home/dvmuser3/andrey/npb-3.3-c/LU/erhs.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |//
   38|       |// compute the right hand side based on exact solution
   39|       |//
   40|       |//---------------------------------------------------------------------
   41|       |void erhs()
   42|      1|{
   43|       |  //---------------------------------------------------------------------
   44|       |  // local variables
   45|       |  //---------------------------------------------------------------------
   46|      1|  int i, j, k, m;
   47|      1|  double xi, eta, zeta;
   48|      1|  double q;
   49|      1|  double u21, u31, u41;
   50|      1|  double tmp;
   51|      1|  double u21i, u31i, u41i, u51i;
   52|      1|  double u21j, u31j, u41j, u51j;
   53|      1|  double u21k, u31k, u41k, u51k;
   54|      1|  double u21im1, u31im1, u41im1, u51im1;
   55|      1|  double u21jm1, u31jm1, u41jm1, u51jm1;
   56|      1|  double u21km1, u31km1, u41km1, u51km1;
   57|       |
   58|      1|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m)
   59|     65|  for (k = 0; k < nz; k++) {
   60|  4.16k|    for (j = 0; j < ny; j++) {
   61|   266k|      for (i = 0; i < nx; i++) {
   62|  1.57M|        for (m = 0; m < 5; m++) {
   63|  1.31M|          frct[k][j][i][m] = 0.0;
   64|  1.31M|        }
   65|   262k|      }
   66|  4.09k|    }
   67|     64|  }
   68|       |
   69|      1|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, zeta, eta, xi)
   70|     65|  for (k = 0; k < nz; k++) {
   71|  4.16k|    for (j = 0; j < ny; j++) {
   72|   266k|      for (i = 0; i < nx; i++) {
   73|  1.57M|        for (m = 0; m < 5; m++) {
   74|  1.31M|          zeta = ( (double)k ) / ( nz - 1 );
   75|  1.31M|          eta = ( (double)j ) / ( ny0 - 1 );
   76|  1.31M|          xi = ( (double)i ) / ( nx0 - 1 );
   77|  1.31M|          rsd[k][j][i][m] =  ce[m][0]
   78|  1.31M|            + (ce[m][1]
   79|  1.31M|            + (ce[m][4]
   80|  1.31M|            + (ce[m][7]
   81|  1.31M|            +  ce[m][10] * xi) * xi) * xi) * xi
   82|  1.31M|            + (ce[m][2]
   83|  1.31M|            + (ce[m][5]
   84|  1.31M|            + (ce[m][8]
   85|  1.31M|            +  ce[m][11] * eta) * eta) * eta) * eta
   86|  1.31M|            + (ce[m][3]
   87|  1.31M|            + (ce[m][6]
   88|  1.31M|            + (ce[m][9]
   89|  1.31M|            +  ce[m][12] * zeta) * zeta) * zeta) * zeta;
   90|  1.31M|        }
   91|   262k|      }
   92|  4.09k|    }
   93|     64|  }
   94|       |
   95|       |  //---------------------------------------------------------------------
   96|       |  // xi-direction flux differences
   97|       |  //---------------------------------------------------------------------
   98|      1|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) shadow_renew(rsd) \
   99|      1|            private(k, i, u21im1, j, u41im1, u51i, u51im1, m, u31i, u41i, u21i, u31im1, u21, tmp, q)
  100|     63|  for (k = 1; k < nz - 1; k++) {
  101|  3.90k|    for (j = jst; j < jend; j++) {
  102|   242k|      for (i = ist; i < iend; i++) {
  103|   238k|        double fluxPrivate[3][5];
  104|   238k|        int fluxI;
  105|       |
  106|   953k|        for (fluxI = 0; fluxI < 3; ++fluxI) {
  107|   714k|          fluxPrivate[fluxI][0] = rsd[k][j][i-1+fluxI][1];
  108|   714k|          u21 = rsd[k][j][i-1+fluxI][1] / rsd[k][j][i-1+fluxI][0];
  109|   714k|          q = 0.50 * (  rsd[k][j][i-1+fluxI][1] * rsd[k][j][i-1+fluxI][1]
  110|   714k|                      + rsd[k][j][i-1+fluxI][2] * rsd[k][j][i-1+fluxI][2]
  111|   714k|                      + rsd[k][j][i-1+fluxI][3] * rsd[k][j][i-1+fluxI][3] )
  112|   714k|                   / rsd[k][j][i-1+fluxI][0];
  113|   714k|          fluxPrivate[fluxI][1] = rsd[k][j][i-1+fluxI][1] * u21 + C2 * ( rsd[k][j][i-1+fluxI][4] - q );
  114|   714k|          fluxPrivate[fluxI][2] = rsd[k][j][i-1+fluxI][2] * u21;
  115|   714k|          fluxPrivate[fluxI][3] = rsd[k][j][i-1+fluxI][3] * u21;
  116|   714k|          fluxPrivate[fluxI][4] = ( C1 * rsd[k][j][i-1+fluxI][4] - C2 * q ) * u21;
  117|   714k|        }
  118|       |
  119|  1.42M|        for (m = 0; m < 5; m++) {
  120|  1.19M|          frct[k][j][i][m] =  frct[k][j][i][m]
  121|  1.19M|                    - tx2 * ( fluxPrivate[2][m] - fluxPrivate[0][m] );
  122|  1.19M|        }
  123|       |
  124|   714k|        for (fluxI = 1; fluxI < 3; ++fluxI) {
  125|   476k|          tmp = 1.0 / rsd[k][j][i-1+fluxI][0];
  126|       |
  127|   476k|          u21i = tmp * rsd[k][j][i-1+fluxI][1];
  128|   476k|          u31i = tmp * rsd[k][j][i-1+fluxI][2];
  129|   476k|          u41i = tmp * rsd[k][j][i-1+fluxI][3];
  130|   476k|          u51i = tmp * rsd[k][j][i-1+fluxI][4];
  131|       |
  132|   476k|          tmp = 1.0 / rsd[k][j][i-2+fluxI][0];
  133|       |
  134|   476k|          u21im1 = tmp * rsd[k][j][i-2+fluxI][1];
  135|   476k|          u31im1 = tmp * rsd[k][j][i-2+fluxI][2];
  136|   476k|          u41im1 = tmp * rsd[k][j][i-2+fluxI][3];
  137|   476k|          u51im1 = tmp * rsd[k][j][i-2+fluxI][4];
  138|       |
  139|   476k|          fluxPrivate[fluxI][1] = (4.0/3.0) * tx3 * ( u21i - u21im1 );
  140|   476k|          fluxPrivate[fluxI][2] = tx3 * ( u31i - u31im1 );
  141|   476k|          fluxPrivate[fluxI][3] = tx3 * ( u41i - u41im1 );
  142|   476k|          fluxPrivate[fluxI][4] = 0.50 * ( 1.0 - C1*C5 )
  143|   476k|            * tx3 * ( ( u21i*u21i     + u31i*u31i     + u41i*u41i )
  144|   476k|                    - ( u21im1*u21im1 + u31im1*u31im1 + u41im1*u41im1 ) )
  145|   476k|            + (1.0/6.0)
  146|   476k|            * tx3 * ( u21i*u21i - u21im1*u21im1 )
  147|   476k|            + C1 * C5 * tx3 * ( u51i - u51im1 );
  148|   476k|        }
  149|       |
  150|   238k|        frct[k][j][i][0] = frct[k][j][i][0]
  151|   238k|          + dx1 * tx1 * (        rsd[k][j][i-1][0]
  152|   238k|                         - 2.0 * rsd[k][j][i][0]
  153|   238k|                         +       rsd[k][j][i+1][0] );
  154|   238k|        frct[k][j][i][1] = frct[k][j][i][1]
  155|   238k|          + tx3 * C3 * C4 * ( fluxPrivate[2][1] - fluxPrivate[1][1] )
  156|   238k|          + dx2 * tx1 * (        rsd[k][j][i-1][1]
  157|   238k|                         - 2.0 * rsd[k][j][i][1]
  158|   238k|                         +       rsd[k][j][i+1][1] );
  159|   238k|        frct[k][j][i][2] = frct[k][j][i][2]
  160|   238k|          + tx3 * C3 * C4 * ( fluxPrivate[2][2] - fluxPrivate[1][2] )
  161|   238k|          + dx3 * tx1 * (        rsd[k][j][i-1][2]
  162|   238k|                         - 2.0 * rsd[k][j][i][2]
  163|   238k|                         +       rsd[k][j][i+1][2] );
  164|   238k|        frct[k][j][i][3] = frct[k][j][i][3]
  165|   238k|          + tx3 * C3 * C4 * ( fluxPrivate[2][3] - fluxPrivate[1][3] )
  166|   238k|          + dx4 * tx1 * (        rsd[k][j][i-1][3]
  167|   238k|                         - 2.0 * rsd[k][j][i][3]
  168|   238k|                         +       rsd[k][j][i+1][3] );
  169|   238k|        frct[k][j][i][4] = frct[k][j][i][4]
  170|   238k|          + tx3 * C3 * C4 * ( fluxPrivate[2][4] - fluxPrivate[1][4] )
  171|   238k|          + dx5 * tx1 * (        rsd[k][j][i-1][4]
  172|   238k|                         - 2.0 * rsd[k][j][i][4]
  173|   238k|                         +       rsd[k][j][i+1][4] );
  174|       |
  175|       |        //---------------------------------------------------------------------
  176|       |        // Fourth-order dissipation
  177|       |        //---------------------------------------------------------------------
  178|   238k|        if (i == 1)
  179|  23.0k|          for (m = 0; m < 5; m++)
  180|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  181|  19.2k|              - dssp * ( + 5.0 * rsd[k][j][i][m]
  182|  19.2k|                         - 4.0 * rsd[k][j][i+1][m]
  183|  19.2k|                         +       rsd[k][j][i+2][m] );
  184|   234k|        else if (i == 2)
  185|  23.0k|          for (m = 0; m < 5; m++)
  186|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  187|  19.2k|              - dssp * ( - 4.0 * rsd[k][j][i-1][m]
  188|  19.2k|                         + 6.0 * rsd[k][j][i][m]
  189|  19.2k|                         - 4.0 * rsd[k][j][i+1][m]
  190|  19.2k|                         +       rsd[k][j][i+2][m] );
  191|   230k|        else if (i == nx-3)
  192|  23.0k|          for (m = 0; m < 5; m++)
  193|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  194|  19.2k|              - dssp * (        rsd[k][j][i-2][m]
  195|  19.2k|                        - 4.0 * rsd[k][j][i-1][m]
  196|  19.2k|                        + 6.0 * rsd[k][j][i][m]
  197|  19.2k|                        - 4.0 * rsd[k][j][i+1][m] );
  198|   226k|        else if (i == nx-2)
  199|  23.0k|          for (m = 0; m < 5; m++)
  200|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  201|  19.2k|              - dssp * (        rsd[k][j][i-2][m]
  202|  19.2k|                        - 4.0 * rsd[k][j][i-1][m]
  203|  19.2k|                        + 5.0 * rsd[k][j][i][m] );
  204|   222k|        else
  205|  1.33M|          for (m = 0; m < 5; m++) 
  206|  1.11M|            frct[k][j][i][m] = frct[k][j][i][m]
  207|  1.11M|              - dssp * (        rsd[k][j][i-2][m]
  208|  1.11M|                        - 4.0 * rsd[k][j][i-1][m]
  209|  1.11M|                        + 6.0 * rsd[k][j][i][m]
  210|  1.11M|                        - 4.0 * rsd[k][j][i+1][m]
  211|  1.11M|                        +       rsd[k][j][i+2][m] );
  212|   238k|      }
  213|  3.84k|    }
  214|     62|  }
  215|       |
  216|       |  //---------------------------------------------------------------------
  217|       |  // eta-direction flux differences
  218|       |  //---------------------------------------------------------------------
  219|      1|#pragma dvm parallel([k][i][j] on dvm_tpl[k][j][i]) \
  220|      1|            private(k, i, tmp, u31j, u21j, m, u41j, j, u31jm1, u51jm1, u31, u21jm1, q, u41jm1, u51j)
  221|     63|  for (k = 1; k < nz - 1; k++) {
  222|  3.90k|    for (i = ist; i < iend; i++) {
  223|   242k|      for (j = jst; j < jend; j++) {
  224|   238k|        double fluxPrivate[3][5];
  225|   238k|        int fluxJ;
  226|   953k|        for (fluxJ = 0; fluxJ < 3; ++fluxJ) {
  227|   714k|          fluxPrivate[fluxJ][0] = rsd[k][j-1+fluxJ][i][2];
  228|   714k|          u31 = rsd[k][j-1+fluxJ][i][2] / rsd[k][j-1+fluxJ][i][0];
  229|   714k|          q = 0.50 * (  rsd[k][j-1+fluxJ][i][1] * rsd[k][j-1+fluxJ][i][1]
  230|   714k|                      + rsd[k][j-1+fluxJ][i][2] * rsd[k][j-1+fluxJ][i][2]
  231|   714k|                      + rsd[k][j-1+fluxJ][i][3] * rsd[k][j-1+fluxJ][i][3] )
  232|   714k|                   / rsd[k][j-1+fluxJ][i][0];
  233|   714k|          fluxPrivate[fluxJ][1] = rsd[k][j-1+fluxJ][i][1] * u31;
  234|   714k|          fluxPrivate[fluxJ][2] = rsd[k][j-1+fluxJ][i][2] * u31 + C2 * ( rsd[k][j-1+fluxJ][i][4] - q );
  235|   714k|          fluxPrivate[fluxJ][3] = rsd[k][j-1+fluxJ][i][3] * u31;
  236|   714k|          fluxPrivate[fluxJ][4] = ( C1 * rsd[k][j-1+fluxJ][i][4] - C2 * q ) * u31;
  237|   714k|        }
  238|       |
  239|  1.42M|        for (m = 0; m < 5; m++) {
  240|  1.19M|          frct[k][j][i][m] =  frct[k][j][i][m]
  241|  1.19M|            - ty2 * ( fluxPrivate[2][m] - fluxPrivate[0][m] );
  242|  1.19M|        }
  243|       |
  244|   714k|        for (fluxJ = 1; fluxJ < 3; ++fluxJ) {
  245|   476k|          tmp = 1.0 / rsd[k][j-1+fluxJ][i][0];
  246|       |
  247|   476k|          u21j = tmp * rsd[k][j-1+fluxJ][i][1];
  248|   476k|          u31j = tmp * rsd[k][j-1+fluxJ][i][2];
  249|   476k|          u41j = tmp * rsd[k][j-1+fluxJ][i][3];
  250|   476k|          u51j = tmp * rsd[k][j-1+fluxJ][i][4];
  251|       |
  252|   476k|          tmp = 1.0 / rsd[k][j-2+fluxJ][i][0];
  253|       |
  254|   476k|          u21jm1 = tmp * rsd[k][j-2+fluxJ][i][1];
  255|   476k|          u31jm1 = tmp * rsd[k][j-2+fluxJ][i][2];
  256|   476k|          u41jm1 = tmp * rsd[k][j-2+fluxJ][i][3];
  257|   476k|          u51jm1 = tmp * rsd[k][j-2+fluxJ][i][4];
  258|       |
  259|   476k|          fluxPrivate[fluxJ][1] = ty3 * ( u21j - u21jm1 );
  260|   476k|          fluxPrivate[fluxJ][2] = (4.0/3.0) * ty3 * ( u31j - u31jm1 );
  261|   476k|          fluxPrivate[fluxJ][3] = ty3 * ( u41j - u41jm1 );
  262|   476k|          fluxPrivate[fluxJ][4] = 0.50 * ( 1.0 - C1*C5 )
  263|   476k|            * ty3 * ( ( u21j*u21j     + u31j*u31j     + u41j*u41j )
  264|   476k|                    - ( u21jm1*u21jm1 + u31jm1*u31jm1 + u41jm1*u41jm1 ) )
  265|   476k|            + (1.0/6.0)
  266|   476k|            * ty3 * ( u31j*u31j - u31jm1*u31jm1 )
  267|   476k|            + C1 * C5 * ty3 * ( u51j - u51jm1 );
  268|   476k|        }
  269|       |
  270|   238k|        frct[k][j][i][0] = frct[k][j][i][0]
  271|   238k|          + dy1 * ty1 * (        rsd[k][j-1][i][0]
  272|   238k|                         - 2.0 * rsd[k][j][i][0]
  273|   238k|                         +       rsd[k][j+1][i][0] );
  274|   238k|        frct[k][j][i][1] = frct[k][j][i][1]
  275|   238k|          + ty3 * C3 * C4 * ( fluxPrivate[2][1] - fluxPrivate[1][1] )
  276|   238k|          + dy2 * ty1 * (        rsd[k][j-1][i][1]
  277|   238k|                         - 2.0 * rsd[k][j][i][1]
  278|   238k|                         +       rsd[k][j+1][i][1] );
  279|   238k|        frct[k][j][i][2] = frct[k][j][i][2]
  280|   238k|          + ty3 * C3 * C4 * ( fluxPrivate[2][2] - fluxPrivate[1][2] )
  281|   238k|          + dy3 * ty1 * (        rsd[k][j-1][i][2]
  282|   238k|                         - 2.0 * rsd[k][j][i][2]
  283|   238k|                         +       rsd[k][j+1][i][2] );
  284|   238k|        frct[k][j][i][3] = frct[k][j][i][3]
  285|   238k|          + ty3 * C3 * C4 * ( fluxPrivate[2][3] - fluxPrivate[1][3] )
  286|   238k|          + dy4 * ty1 * (        rsd[k][j-1][i][3]
  287|   238k|                         - 2.0 * rsd[k][j][i][3]
  288|   238k|                         +       rsd[k][j+1][i][3] );
  289|   238k|        frct[k][j][i][4] = frct[k][j][i][4]
  290|   238k|          + ty3 * C3 * C4 * ( fluxPrivate[2][4] - fluxPrivate[1][4] )
  291|   238k|          + dy5 * ty1 * (        rsd[k][j-1][i][4]
  292|   238k|                         - 2.0 * rsd[k][j][i][4]
  293|   238k|                         +       rsd[k][j+1][i][4] );
  294|       |
  295|       |        //---------------------------------------------------------------------
  296|       |        // fourth-order dissipation
  297|       |        //---------------------------------------------------------------------
  298|   238k|        if (j == 1)
  299|  23.0k|          for (m = 0; m < 5; m++) 
  300|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  301|  19.2k|              - dssp * ( + 5.0 * rsd[k][j][i][m]
  302|  19.2k|                         - 4.0 * rsd[k][j+1][i][m]
  303|  19.2k|                         +       rsd[k][j+2][i][m] );
  304|   234k|        else if (j == 2)
  305|  23.0k|          for (m = 0; m < 5; m++)
  306|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  307|  19.2k|              - dssp * ( - 4.0 * rsd[k][j-1][i][m]
  308|  19.2k|                         + 6.0 * rsd[k][j][i][m]
  309|  19.2k|                         - 4.0 * rsd[k][j+1][i][m]
  310|  19.2k|                         +       rsd[k][j+2][i][m] );
  311|   230k|        else if (j == ny-3)
  312|  23.0k|          for (m = 0; m < 5; m++) 
  313|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  314|  19.2k|              - dssp * (        rsd[k][j-2][i][m]
  315|  19.2k|                        - 4.0 * rsd[k][j-1][i][m]
  316|  19.2k|                        + 6.0 * rsd[k][j][i][m]
  317|  19.2k|                        - 4.0 * rsd[k][j+1][i][m] );
  318|   226k|        else if (j == ny-2)
  319|  23.0k|          for (m = 0; m < 5; m++) 
  320|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  321|  19.2k|              - dssp * (        rsd[k][j-2][i][m]
  322|  19.2k|                        - 4.0 * rsd[k][j-1][i][m]
  323|  19.2k|                        + 5.0 * rsd[k][j][i][m] );
  324|   222k|        else
  325|  1.33M|          for (m = 0; m < 5; m++)
  326|  1.11M|            frct[k][j][i][m] = frct[k][j][i][m]
  327|  1.11M|              - dssp * (        rsd[k][j-2][i][m]
  328|  1.11M|                        - 4.0 * rsd[k][j-1][i][m]
  329|  1.11M|                        + 6.0 * rsd[k][j][i][m]
  330|  1.11M|                        - 4.0 * rsd[k][j+1][i][m]
  331|  1.11M|                        +       rsd[k][j+2][i][m] );
  332|   238k|      }
  333|  3.84k|    }
  334|     62|  }
  335|       |
  336|       |  //---------------------------------------------------------------------
  337|       |  // zeta-direction flux differences
  338|       |  //---------------------------------------------------------------------
  339|      1|#pragma dvm parallel([j][i][k] on dvm_tpl[k][j][i]) \
  340|      1|            private(j, u51km1, u31k, tmp, u21k, u51k, u41k, u21km1, u31km1, u41, i, q, u41km1, k, m)
  341|     63|  for (j = jst; j < jend; j++) {
  342|  3.90k|    for (i = ist; i < iend; i++) {
  343|   242k|      for (k = 1; k < nz - 1 ; k++) {
  344|   238k|        double fluxPrivate[3][5];
  345|   238k|        int fluxK;
  346|   953k|        for (fluxK = 0; fluxK < 3; ++fluxK) {
  347|   714k|          fluxPrivate[fluxK][0] = rsd[k-1+fluxK][j][i][3];
  348|   714k|          u41 = rsd[k-1+fluxK][j][i][3] / rsd[k-1+fluxK][j][i][0];
  349|   714k|          q = 0.50 * (  rsd[k-1+fluxK][j][i][1] * rsd[k-1+fluxK][j][i][1]
  350|   714k|                      + rsd[k-1+fluxK][j][i][2] * rsd[k-1+fluxK][j][i][2]
  351|   714k|                      + rsd[k-1+fluxK][j][i][3] * rsd[k-1+fluxK][j][i][3] )
  352|   714k|                   / rsd[k-1+fluxK][j][i][0];
  353|   714k|          fluxPrivate[fluxK][1] = rsd[k-1+fluxK][j][i][1] * u41;
  354|   714k|          fluxPrivate[fluxK][2] = rsd[k-1+fluxK][j][i][2] * u41; 
  355|   714k|          fluxPrivate[fluxK][3] = rsd[k-1+fluxK][j][i][3] * u41 + C2 * ( rsd[k-1+fluxK][j][i][4] - q );
  356|   714k|          fluxPrivate[fluxK][4] = ( C1 * rsd[k-1+fluxK][j][i][4] - C2 * q ) * u41;
  357|   714k|        }
  358|       |
  359|  1.42M|        for (m = 0; m < 5; m++) {
  360|  1.19M|          frct[k][j][i][m] =  frct[k][j][i][m]
  361|  1.19M|            - tz2 * ( fluxPrivate[2][m] - fluxPrivate[0][m] );
  362|  1.19M|        }
  363|       |
  364|   714k|        for (fluxK = 1; fluxK < 3; ++fluxK) {
  365|   476k|          tmp = 1.0 / rsd[k-1+fluxK][j][i][0];
  366|       |
  367|   476k|          u21k = tmp * rsd[k-1+fluxK][j][i][1];
  368|   476k|          u31k = tmp * rsd[k-1+fluxK][j][i][2];
  369|   476k|          u41k = tmp * rsd[k-1+fluxK][j][i][3];
  370|   476k|          u51k = tmp * rsd[k-1+fluxK][j][i][4];
  371|       |
  372|   476k|          tmp = 1.0 / rsd[k-2+fluxK][j][i][0];
  373|       |
  374|   476k|          u21km1 = tmp * rsd[k-2+fluxK][j][i][1];
  375|   476k|          u31km1 = tmp * rsd[k-2+fluxK][j][i][2];
  376|   476k|          u41km1 = tmp * rsd[k-2+fluxK][j][i][3];
  377|   476k|          u51km1 = tmp * rsd[k-2+fluxK][j][i][4];
  378|       |
  379|   476k|          fluxPrivate[fluxK][1] = tz3 * ( u21k - u21km1 );
  380|   476k|          fluxPrivate[fluxK][2] = tz3 * ( u31k - u31km1 );
  381|   476k|          fluxPrivate[fluxK][3] = (4.0/3.0) * tz3 * ( u41k - u41km1 );
  382|   476k|          fluxPrivate[fluxK][4] = 0.50 * ( 1.0 - C1*C5 )
  383|   476k|            * tz3 * ( ( u21k*u21k     + u31k*u31k     + u41k*u41k )
  384|   476k|                    - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) )
  385|   476k|            + (1.0/6.0)
  386|   476k|            * tz3 * ( u41k*u41k - u41km1*u41km1 )
  387|   476k|            + C1 * C5 * tz3 * ( u51k - u51km1 );
  388|   476k|        }
  389|       |
  390|   238k|        frct[k][j][i][0] = frct[k][j][i][0]
  391|   238k|          + dz1 * tz1 * (        rsd[k+1][j][i][0]
  392|   238k|                         - 2.0 * rsd[k][j][i][0]
  393|   238k|                         +       rsd[k-1][j][i][0] );
  394|   238k|        frct[k][j][i][1] = frct[k][j][i][1]
  395|   238k|          + tz3 * C3 * C4 * ( fluxPrivate[2][1] - fluxPrivate[1][1] )
  396|   238k|          + dz2 * tz1 * (        rsd[k+1][j][i][1]
  397|   238k|                         - 2.0 * rsd[k][j][i][1]
  398|   238k|                         +       rsd[k-1][j][i][1] );
  399|   238k|        frct[k][j][i][2] = frct[k][j][i][2]
  400|   238k|          + tz3 * C3 * C4 * ( fluxPrivate[2][2] - fluxPrivate[1][2] )
  401|   238k|          + dz3 * tz1 * (        rsd[k+1][j][i][2]
  402|   238k|                         - 2.0 * rsd[k][j][i][2]
  403|   238k|                         +       rsd[k-1][j][i][2] );
  404|   238k|        frct[k][j][i][3] = frct[k][j][i][3]
  405|   238k|          + tz3 * C3 * C4 * ( fluxPrivate[2][3] - fluxPrivate[1][3] )
  406|   238k|          + dz4 * tz1 * (        rsd[k+1][j][i][3]
  407|   238k|                         - 2.0 * rsd[k][j][i][3]
  408|   238k|                         +       rsd[k-1][j][i][3] );
  409|   238k|        frct[k][j][i][4] = frct[k][j][i][4]
  410|   238k|          + tz3 * C3 * C4 * ( fluxPrivate[2][4] - fluxPrivate[1][4] )
  411|   238k|          + dz5 * tz1 * (        rsd[k+1][j][i][4]
  412|   238k|                         - 2.0 * rsd[k][j][i][4]
  413|   238k|                         +       rsd[k-1][j][i][4] );
  414|       |
  415|       |        //---------------------------------------------------------------------
  416|       |        // fourth-order dissipation
  417|       |        //---------------------------------------------------------------------
  418|   238k|        if (k == 1)
  419|  23.0k|          for (m = 0; m < 5; m++)
  420|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  421|  19.2k|              - dssp * ( + 5.0 * rsd[k][j][i][m]
  422|  19.2k|                         - 4.0 * rsd[k+1][j][i][m]
  423|  19.2k|                         +       rsd[k+2][j][i][m] );
  424|   234k|        else if (k == 2)
  425|  23.0k|          for (m = 0; m < 5; m++)
  426|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  427|  19.2k|              - dssp * ( - 4.0 * rsd[k-1][j][i][m]
  428|  19.2k|                         + 6.0 * rsd[k][j][i][m]
  429|  19.2k|                         - 4.0 * rsd[k+1][j][i][m]
  430|  19.2k|                         +       rsd[k+2][j][i][m] );
  431|   230k|        else if (k == nz-3)
  432|  23.0k|          for (m = 0; m < 5; m++)
  433|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  434|  19.2k|              - dssp * (        rsd[k-2][j][i][m]
  435|  19.2k|                        - 4.0 * rsd[k-1][j][i][m]
  436|  19.2k|                        + 6.0 * rsd[k][j][i][m]
  437|  19.2k|                        - 4.0 * rsd[k+1][j][i][m] );
  438|   226k|        else if (k == nz-2)
  439|  23.0k|          for (m = 0; m < 5; m++)
  440|  19.2k|            frct[k][j][i][m] = frct[k][j][i][m]
  441|  19.2k|              - dssp * (        rsd[k-2][j][i][m]
  442|  19.2k|                        - 4.0 * rsd[k-1][j][i][m]
  443|  19.2k|                        + 5.0 * rsd[k][j][i][m] );
  444|   222k|        else
  445|  1.33M|          for (m = 0; m < 5; m++) 
  446|  1.11M|            frct[k][j][i][m] = frct[k][j][i][m]
  447|  1.11M|              - dssp * (        rsd[k-2][j][i][m]
  448|  1.11M|                        - 4.0 * rsd[k-1][j][i][m]
  449|  1.11M|                        + 6.0 * rsd[k][j][i][m]
  450|  1.11M|                        - 4.0 * rsd[k+1][j][i][m]
  451|  1.11M|                        +       rsd[k+2][j][i][m] );
  452|   238k|      }
  453|  3.84k|    }
  454|     62|  }
  455|      1|}
  456|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/error.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <math.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |// 
   40|       |// compute the solution error
   41|       |// 
   42|       |//---------------------------------------------------------------------
   43|       |void error()
   44|      1|{
   45|       |  //---------------------------------------------------------------------
   46|       |  // local variables
   47|       |  //---------------------------------------------------------------------
   48|      1|  int i, j, k, m;
   49|      1|  double tmp;
   50|      1|  double u000ijk[5];
   51|       |
   52|      6|  for (m = 0; m < 5; m++) {
   53|      5|    errnm[m] = 0.0;
   54|      5|  }
   55|       |
   56|      1|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) reduction(sum(errnm)) private(k, j, i, u000ijk, tmp, m)
   57|     63|  for (k = 1; k < nz-1; k++) {
   58|  3.90k|    for (j = jst; j < jend; j++) {
   59|   242k|      for (i = ist; i < iend; i++) {
   60|   238k|        exact( i, j, k, u000ijk );
   61|  1.42M|        for (m = 0; m < 5; m++) {
   62|  1.19M|          tmp = ( u000ijk[m] - u[k][j][i][m] );
   63|  1.19M|          errnm[m] = errnm[m] + tmp * tmp;
   64|  1.19M|        }
   65|   238k|      }
   66|  3.84k|    }
   67|     62|  }
   68|       |
   69|      6|  for (m = 0; m < 5; m++) {
   70|      5|    errnm[m] = sqrt ( errnm[m] / ( (nx0-2)*(ny0-2)*(nz0-2) ) );
   71|      5|  }
   72|       |
   73|       |  /*
   74|       |  printf(" \n RMS-norm of error in soln. to first pde  = %12.5E\n"
   75|       |         " RMS-norm of error in soln. to second pde = %12.5E\n"
   76|       |         " RMS-norm of error in soln. to third pde  = %12.5E\n"
   77|       |         " RMS-norm of error in soln. to fourth pde = %12.5E\n"
   78|       |         " RMS-norm of error in soln. to fifth pde  = %12.5E\n",
   79|       |         errnm[0], errnm[1], errnm[2], errnm[3], errnm[4]);
   80|       |  */
   81|      1|}
   82|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/exact.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |//
   38|       |//   compute the exact solution at (i,j,k)
   39|       |//
   40|       |//---------------------------------------------------------------------
   41|       |void exact(int i, int j, int k, double u000ijk[])
   42|  3.14M|{
   43|       |  //---------------------------------------------------------------------
   44|       |  // local variables
   45|       |  //---------------------------------------------------------------------
   46|  3.14M|  int m;
   47|  3.14M|  double xi, eta, zeta;
   48|       |
   49|  3.14M|  xi   = ( (double)i ) / ( nx0 - 1 );
   50|  3.14M|  eta  = ( (double)j ) / ( ny0 - 1 );
   51|  3.14M|  zeta = ( (double)k ) / ( nz - 1 );
   52|       |
   53|  18.8M|  for (m = 0; m < 5; m++) {
   54|  15.7M|    u000ijk[m] =  ce[m][0]
   55|  15.7M|      + (ce[m][1]
   56|  15.7M|      + (ce[m][4]
   57|  15.7M|      + (ce[m][7]
   58|  15.7M|      +  ce[m][10] * xi) * xi) * xi) * xi
   59|  15.7M|      + (ce[m][2]
   60|  15.7M|      + (ce[m][5]
   61|  15.7M|      + (ce[m][8]
   62|  15.7M|      +  ce[m][11] * eta) * eta) * eta) * eta
   63|  15.7M|      + (ce[m][3]
   64|  15.7M|      + (ce[m][6]
   65|  15.7M|      + (ce[m][9]
   66|  15.7M|      +  ce[m][12] * zeta) * zeta) * zeta) * zeta;
   67|  15.7M|  }
   68|  3.14M|}
   69|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/jacld.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// compute the lower triangular part of the jacobian matrix
   38|       |//---------------------------------------------------------------------
   39|       |void jacld(int k)
   40|      0|{
   41|      0|#pragma dvm interval
   42|       |  //---------------------------------------------------------------------
   43|       |  // local variables
   44|       |  //---------------------------------------------------------------------
   45|      0|  int i, j;
   46|      0|  double r43;
   47|      0|  double c1345;
   48|      0|  double c34;
   49|      0|  double tmp1, tmp2, tmp3;
   50|       |
   51|      0|  r43 = ( 4.0 / 3.0 );
   52|      0|  c1345 = C1 * C3 * C4 * C5;
   53|      0|  c34 = C3 * C4;
   54|       |
   55|      0|  for (j = jst; j < jend; j++) {
   56|      0|    for (i = ist; i < iend; i++) {
   57|       |      //---------------------------------------------------------------------
   58|       |      // form the block daigonal
   59|       |      //---------------------------------------------------------------------
   60|      0|      tmp1 = rho_i[k][j][i];
   61|      0|      tmp2 = tmp1 * tmp1;
   62|      0|      tmp3 = tmp1 * tmp2;
   63|       |
   64|      0|      d[j][i][0][0] =  1.0 + dt * 2.0 * ( tx1 * dx1 + ty1 * dy1 + tz1 * dz1 );
   65|      0|      d[j][i][1][0] =  0.0;
   66|      0|      d[j][i][2][0] =  0.0;
   67|      0|      d[j][i][3][0] =  0.0;
   68|      0|      d[j][i][4][0] =  0.0;
   69|       |
   70|      0|      d[j][i][0][1] = -dt * 2.0
   71|      0|        * ( tx1 * r43 + ty1 + tz1 ) * c34 * tmp2 * u[k][j][i][1];
   72|      0|      d[j][i][1][1] =  1.0
   73|      0|        + dt * 2.0 * c34 * tmp1 * ( tx1 * r43 + ty1 + tz1 )
   74|      0|        + dt * 2.0 * ( tx1 * dx2 + ty1 * dy2 + tz1 * dz2 );
   75|      0|      d[j][i][2][1] = 0.0;
   76|      0|      d[j][i][3][1] = 0.0;
   77|      0|      d[j][i][4][1] = 0.0;
   78|       |
   79|      0|      d[j][i][0][2] = -dt * 2.0 
   80|      0|        * ( tx1 + ty1 * r43 + tz1 ) * c34 * tmp2 * u[k][j][i][2];
   81|      0|      d[j][i][1][2] = 0.0;
   82|      0|      d[j][i][2][2] = 1.0
   83|      0|        + dt * 2.0 * c34 * tmp1 * ( tx1 + ty1 * r43 + tz1 )
   84|      0|        + dt * 2.0 * ( tx1 * dx3 + ty1 * dy3 + tz1 * dz3 );
   85|      0|      d[j][i][3][2] = 0.0;
   86|      0|      d[j][i][4][2] = 0.0;
   87|       |
   88|      0|      d[j][i][0][3] = -dt * 2.0
   89|      0|        * ( tx1 + ty1 + tz1 * r43 ) * c34 * tmp2 * u[k][j][i][3];
   90|      0|      d[j][i][1][3] = 0.0;
   91|      0|      d[j][i][2][3] = 0.0;
   92|      0|      d[j][i][3][3] = 1.0
   93|      0|        + dt * 2.0 * c34 * tmp1 * ( tx1 + ty1 + tz1 * r43 )
   94|      0|        + dt * 2.0 * ( tx1 * dx4 + ty1 * dy4 + tz1 * dz4 );
   95|      0|      d[j][i][4][3] = 0.0;
   96|       |
   97|      0|      d[j][i][0][4] = -dt * 2.0
   98|      0|        * ( ( ( tx1 * ( r43*c34 - c1345 )
   99|      0|                + ty1 * ( c34 - c1345 )
  100|      0|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][1]*u[k][j][i][1] )
  101|      0|              + ( tx1 * ( c34 - c1345 )
  102|      0|                + ty1 * ( r43*c34 - c1345 )
  103|      0|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][2]*u[k][j][i][2] )
  104|      0|              + ( tx1 * ( c34 - c1345 )
  105|      0|                + ty1 * ( c34 - c1345 )
  106|      0|                + tz1 * ( r43*c34 - c1345 ) ) * (u[k][j][i][3]*u[k][j][i][3])
  107|      0|            ) * tmp3
  108|      0|            + ( tx1 + ty1 + tz1 ) * c1345 * tmp2 * u[k][j][i][4] );
  109|       |
  110|      0|      d[j][i][1][4] = dt * 2.0 * tmp2 * u[k][j][i][1]
  111|      0|        * ( tx1 * ( r43*c34 - c1345 )
  112|      0|          + ty1 * (     c34 - c1345 )
  113|      0|          + tz1 * (     c34 - c1345 ) );
  114|      0|      d[j][i][2][4] = dt * 2.0 * tmp2 * u[k][j][i][2]
  115|      0|        * ( tx1 * ( c34 - c1345 )
  116|      0|          + ty1 * ( r43*c34 -c1345 )
  117|      0|          + tz1 * ( c34 - c1345 ) );
  118|      0|      d[j][i][3][4] = dt * 2.0 * tmp2 * u[k][j][i][3]
  119|      0|        * ( tx1 * ( c34 - c1345 )
  120|      0|          + ty1 * ( c34 - c1345 )
  121|      0|          + tz1 * ( r43*c34 - c1345 ) );
  122|      0|      d[j][i][4][4] = 1.0
  123|      0|        + dt * 2.0 * ( tx1  + ty1 + tz1 ) * c1345 * tmp1
  124|      0|        + dt * 2.0 * ( tx1 * dx5 +  ty1 * dy5 +  tz1 * dz5 );
  125|       |
  126|       |      //---------------------------------------------------------------------
  127|       |      // form the first block sub-diagonal
  128|       |      //---------------------------------------------------------------------
  129|      0|      tmp1 = rho_i[k-1][j][i];
  130|      0|      tmp2 = tmp1 * tmp1;
  131|      0|      tmp3 = tmp1 * tmp2;
  132|       |
  133|      0|      a[j][i][0][0] = - dt * tz1 * dz1;
  134|      0|      a[j][i][1][0] =   0.0;
  135|      0|      a[j][i][2][0] =   0.0;
  136|      0|      a[j][i][3][0] = - dt * tz2;
  137|      0|      a[j][i][4][0] =   0.0;
  138|       |
  139|      0|      a[j][i][0][1] = - dt * tz2
  140|      0|        * ( - ( u[k-1][j][i][1]*u[k-1][j][i][3] ) * tmp2 )
  141|      0|        - dt * tz1 * ( - c34 * tmp2 * u[k-1][j][i][1] );
  142|      0|      a[j][i][1][1] = - dt * tz2 * ( u[k-1][j][i][3] * tmp1 )
  143|      0|        - dt * tz1 * c34 * tmp1
  144|      0|        - dt * tz1 * dz2;
  145|      0|      a[j][i][2][1] = 0.0;
  146|      0|      a[j][i][3][1] = - dt * tz2 * ( u[k-1][j][i][1] * tmp1 );
  147|      0|      a[j][i][4][1] = 0.0;
  148|       |
  149|      0|      a[j][i][0][2] = - dt * tz2
  150|      0|        * ( - ( u[k-1][j][i][2]*u[k-1][j][i][3] ) * tmp2 )
  151|      0|        - dt * tz1 * ( - c34 * tmp2 * u[k-1][j][i][2] );
  152|      0|      a[j][i][1][2] = 0.0;
  153|      0|      a[j][i][2][2] = - dt * tz2 * ( u[k-1][j][i][3] * tmp1 )
  154|      0|        - dt * tz1 * ( c34 * tmp1 )
  155|      0|        - dt * tz1 * dz3;
  156|      0|      a[j][i][3][2] = - dt * tz2 * ( u[k-1][j][i][2] * tmp1 );
  157|      0|      a[j][i][4][2] = 0.0;
  158|       |
  159|      0|      a[j][i][0][3] = - dt * tz2
  160|      0|        * ( - ( u[k-1][j][i][3] * tmp1 ) * ( u[k-1][j][i][3] * tmp1 )
  161|      0|            + C2 * qs[k-1][j][i] * tmp1 )
  162|      0|        - dt * tz1 * ( - r43 * c34 * tmp2 * u[k-1][j][i][3] );
  163|      0|      a[j][i][1][3] = - dt * tz2
  164|      0|        * ( - C2 * ( u[k-1][j][i][1] * tmp1 ) );
  165|      0|      a[j][i][2][3] = - dt * tz2
  166|      0|        * ( - C2 * ( u[k-1][j][i][2] * tmp1 ) );
  167|      0|      a[j][i][3][3] = - dt * tz2 * ( 2.0 - C2 )
  168|      0|        * ( u[k-1][j][i][3] * tmp1 )
  169|      0|        - dt * tz1 * ( r43 * c34 * tmp1 )
  170|      0|        - dt * tz1 * dz4;
  171|      0|      a[j][i][4][3] = - dt * tz2 * C2;
  172|       |
  173|      0|      a[j][i][0][4] = - dt * tz2
  174|      0|        * ( ( C2 * 2.0 * qs[k-1][j][i] - C1 * u[k-1][j][i][4] )
  175|      0|            * u[k-1][j][i][3] * tmp2 )
  176|      0|        - dt * tz1
  177|      0|        * ( - ( c34 - c1345 ) * tmp3 * (u[k-1][j][i][1]*u[k-1][j][i][1])
  178|      0|            - ( c34 - c1345 ) * tmp3 * (u[k-1][j][i][2]*u[k-1][j][i][2])
  179|      0|            - ( r43*c34 - c1345 )* tmp3 * (u[k-1][j][i][3]*u[k-1][j][i][3])
  180|      0|            - c1345 * tmp2 * u[k-1][j][i][4] );
  181|      0|      a[j][i][1][4] = - dt * tz2
  182|      0|        * ( - C2 * ( u[k-1][j][i][1]*u[k-1][j][i][3] ) * tmp2 )
  183|      0|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k-1][j][i][1];
  184|      0|      a[j][i][2][4] = - dt * tz2
  185|      0|        * ( - C2 * ( u[k-1][j][i][2]*u[k-1][j][i][3] ) * tmp2 )
  186|      0|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k-1][j][i][2];
  187|      0|      a[j][i][3][4] = - dt * tz2
  188|      0|        * ( C1 * ( u[k-1][j][i][4] * tmp1 )
  189|      0|          - C2 * ( qs[k-1][j][i] * tmp1
  190|      0|                 + u[k-1][j][i][3]*u[k-1][j][i][3] * tmp2 ) )
  191|      0|        - dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[k-1][j][i][3];
  192|      0|      a[j][i][4][4] = - dt * tz2
  193|      0|        * ( C1 * ( u[k-1][j][i][3] * tmp1 ) )
  194|      0|        - dt * tz1 * c1345 * tmp1
  195|      0|        - dt * tz1 * dz5;
  196|       |
  197|       |      //---------------------------------------------------------------------
  198|       |      // form the second block sub-diagonal
  199|       |      //---------------------------------------------------------------------
  200|      0|      tmp1 = rho_i[k][j-1][i];
  201|      0|      tmp2 = tmp1 * tmp1;
  202|      0|      tmp3 = tmp1 * tmp2;
  203|       |
  204|      0|      b[j][i][0][0] = - dt * ty1 * dy1;
  205|      0|      b[j][i][1][0] =   0.0;
  206|      0|      b[j][i][2][0] = - dt * ty2;
  207|      0|      b[j][i][3][0] =   0.0;
  208|      0|      b[j][i][4][0] =   0.0;
  209|       |
  210|      0|      b[j][i][0][1] = - dt * ty2
  211|      0|        * ( - ( u[k][j-1][i][1]*u[k][j-1][i][2] ) * tmp2 )
  212|      0|        - dt * ty1 * ( - c34 * tmp2 * u[k][j-1][i][1] );
  213|      0|      b[j][i][1][1] = - dt * ty2 * ( u[k][j-1][i][2] * tmp1 )
  214|      0|        - dt * ty1 * ( c34 * tmp1 )
  215|      0|        - dt * ty1 * dy2;
  216|      0|      b[j][i][2][1] = - dt * ty2 * ( u[k][j-1][i][1] * tmp1 );
  217|      0|      b[j][i][3][1] = 0.0;
  218|      0|      b[j][i][4][1] = 0.0;
  219|       |
  220|      0|      b[j][i][0][2] = - dt * ty2
  221|      0|        * ( - ( u[k][j-1][i][2] * tmp1 ) * ( u[k][j-1][i][2] * tmp1 )
  222|      0|            + C2 * ( qs[k][j-1][i] * tmp1 ) )
  223|      0|        - dt * ty1 * ( - r43 * c34 * tmp2 * u[k][j-1][i][2] );
  224|      0|      b[j][i][1][2] = - dt * ty2
  225|      0|        * ( - C2 * ( u[k][j-1][i][1] * tmp1 ) );
  226|      0|      b[j][i][2][2] = - dt * ty2 * ( (2.0 - C2) * (u[k][j-1][i][2] * tmp1) )
  227|      0|        - dt * ty1 * ( r43 * c34 * tmp1 )
  228|      0|        - dt * ty1 * dy3;
  229|      0|      b[j][i][3][2] = - dt * ty2 * ( - C2 * ( u[k][j-1][i][3] * tmp1 ) );
  230|      0|      b[j][i][4][2] = - dt * ty2 * C2;
  231|       |
  232|      0|      b[j][i][0][3] = - dt * ty2
  233|      0|        * ( - ( u[k][j-1][i][2]*u[k][j-1][i][3] ) * tmp2 )
  234|      0|        - dt * ty1 * ( - c34 * tmp2 * u[k][j-1][i][3] );
  235|      0|      b[j][i][1][3] = 0.0;
  236|      0|      b[j][i][2][3] = - dt * ty2 * ( u[k][j-1][i][3] * tmp1 );
  237|      0|      b[j][i][3][3] = - dt * ty2 * ( u[k][j-1][i][2] * tmp1 )
  238|      0|        - dt * ty1 * ( c34 * tmp1 )
  239|      0|        - dt * ty1 * dy4;
  240|      0|      b[j][i][4][3] = 0.0;
  241|       |
  242|      0|      b[j][i][0][4] = - dt * ty2
  243|      0|        * ( ( C2 * 2.0 * qs[k][j-1][i] - C1 * u[k][j-1][i][4] )
  244|      0|            * ( u[k][j-1][i][2] * tmp2 ) )
  245|      0|        - dt * ty1
  246|      0|        * ( - (     c34 - c1345 )*tmp3*(u[k][j-1][i][1]*u[k][j-1][i][1])
  247|      0|            - ( r43*c34 - c1345 )*tmp3*(u[k][j-1][i][2]*u[k][j-1][i][2])
  248|      0|            - (     c34 - c1345 )*tmp3*(u[k][j-1][i][3]*u[k][j-1][i][3])
  249|      0|            - c1345*tmp2*u[k][j-1][i][4] );
  250|      0|      b[j][i][1][4] = - dt * ty2
  251|      0|        * ( - C2 * ( u[k][j-1][i][1]*u[k][j-1][i][2] ) * tmp2 )
  252|      0|        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[k][j-1][i][1];
  253|      0|      b[j][i][2][4] = - dt * ty2
  254|      0|        * ( C1 * ( u[k][j-1][i][4] * tmp1 )
  255|      0|          - C2 * ( qs[k][j-1][i] * tmp1
  256|      0|                 + u[k][j-1][i][2]*u[k][j-1][i][2] * tmp2 ) )
  257|      0|        - dt * ty1 * ( r43*c34 - c1345 ) * tmp2 * u[k][j-1][i][2];
  258|      0|      b[j][i][3][4] = - dt * ty2
  259|      0|        * ( - C2 * ( u[k][j-1][i][2]*u[k][j-1][i][3] ) * tmp2 )
  260|      0|        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[k][j-1][i][3];
  261|      0|      b[j][i][4][4] = - dt * ty2
  262|      0|        * ( C1 * ( u[k][j-1][i][2] * tmp1 ) )
  263|      0|        - dt * ty1 * c1345 * tmp1
  264|      0|        - dt * ty1 * dy5;
  265|       |
  266|       |      //---------------------------------------------------------------------
  267|       |      // form the third block sub-diagonal
  268|       |      //---------------------------------------------------------------------
  269|      0|      tmp1 = rho_i[k][j][i-1];
  270|      0|      tmp2 = tmp1 * tmp1;
  271|      0|      tmp3 = tmp1 * tmp2;
  272|       |
  273|      0|      c[j][i][0][0] = - dt * tx1 * dx1;
  274|      0|      c[j][i][1][0] = - dt * tx2;
  275|      0|      c[j][i][2][0] =   0.0;
  276|      0|      c[j][i][3][0] =   0.0;
  277|      0|      c[j][i][4][0] =   0.0;
  278|       |
  279|      0|      c[j][i][0][1] = - dt * tx2
  280|      0|        * ( - ( u[k][j][i-1][1] * tmp1 ) * ( u[k][j][i-1][1] * tmp1 )
  281|      0|            + C2 * qs[k][j][i-1] * tmp1 )
  282|      0|        - dt * tx1 * ( - r43 * c34 * tmp2 * u[k][j][i-1][1] );
  283|      0|      c[j][i][1][1] = - dt * tx2
  284|      0|        * ( ( 2.0 - C2 ) * ( u[k][j][i-1][1] * tmp1 ) )
  285|      0|        - dt * tx1 * ( r43 * c34 * tmp1 )
  286|      0|        - dt * tx1 * dx2;
  287|      0|      c[j][i][2][1] = - dt * tx2
  288|      0|        * ( - C2 * ( u[k][j][i-1][2] * tmp1 ) );
  289|      0|      c[j][i][3][1] = - dt * tx2
  290|      0|        * ( - C2 * ( u[k][j][i-1][3] * tmp1 ) );
  291|      0|      c[j][i][4][1] = - dt * tx2 * C2;
  292|       |
  293|      0|      c[j][i][0][2] = - dt * tx2
  294|      0|        * ( - ( u[k][j][i-1][1] * u[k][j][i-1][2] ) * tmp2 )
  295|      0|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i-1][2] );
  296|      0|      c[j][i][1][2] = - dt * tx2 * ( u[k][j][i-1][2] * tmp1 );
  297|      0|      c[j][i][2][2] = - dt * tx2 * ( u[k][j][i-1][1] * tmp1 )
  298|      0|        - dt * tx1 * ( c34 * tmp1 )
  299|      0|        - dt * tx1 * dx3;
  300|      0|      c[j][i][3][2] = 0.0;
  301|      0|      c[j][i][4][2] = 0.0;
  302|       |
  303|      0|      c[j][i][0][3] = - dt * tx2
  304|      0|        * ( - ( u[k][j][i-1][1]*u[k][j][i-1][3] ) * tmp2 )
  305|      0|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i-1][3] );
  306|      0|      c[j][i][1][3] = - dt * tx2 * ( u[k][j][i-1][3] * tmp1 );
  307|      0|      c[j][i][2][3] = 0.0;
  308|      0|      c[j][i][3][3] = - dt * tx2 * ( u[k][j][i-1][1] * tmp1 )
  309|      0|        - dt * tx1 * ( c34 * tmp1 ) - dt * tx1 * dx4;
  310|      0|      c[j][i][4][3] = 0.0;
  311|       |
  312|      0|      c[j][i][0][4] = - dt * tx2
  313|      0|        * ( ( C2 * 2.0 * qs[k][j][i-1] - C1 * u[k][j][i-1][4] )
  314|      0|            * u[k][j][i-1][1] * tmp2 )
  315|      0|        - dt * tx1
  316|      0|        * ( - ( r43*c34 - c1345 ) * tmp3 * ( u[k][j][i-1][1]*u[k][j][i-1][1] )
  317|      0|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i-1][2]*u[k][j][i-1][2] )
  318|      0|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i-1][3]*u[k][j][i-1][3] )
  319|      0|            - c1345 * tmp2 * u[k][j][i-1][4] );
  320|      0|      c[j][i][1][4] = - dt * tx2
  321|      0|        * ( C1 * ( u[k][j][i-1][4] * tmp1 )
  322|      0|          - C2 * ( u[k][j][i-1][1]*u[k][j][i-1][1] * tmp2
  323|      0|                 + qs[k][j][i-1] * tmp1 ) )
  324|      0|        - dt * tx1 * ( r43*c34 - c1345 ) * tmp2 * u[k][j][i-1][1];
  325|      0|      c[j][i][2][4] = - dt * tx2
  326|      0|        * ( - C2 * ( u[k][j][i-1][2]*u[k][j][i-1][1] ) * tmp2 )
  327|      0|        - dt * tx1 * (  c34 - c1345 ) * tmp2 * u[k][j][i-1][2];
  328|      0|      c[j][i][3][4] = - dt * tx2
  329|      0|        * ( - C2 * ( u[k][j][i-1][3]*u[k][j][i-1][1] ) * tmp2 )
  330|      0|        - dt * tx1 * (  c34 - c1345 ) * tmp2 * u[k][j][i-1][3];
  331|      0|      c[j][i][4][4] = - dt * tx2
  332|      0|        * ( C1 * ( u[k][j][i-1][1] * tmp1 ) )
  333|      0|        - dt * tx1 * c1345 * tmp1
  334|      0|        - dt * tx1 * dx5;
  335|      0|    }
  336|      0|  }
  337|      0|#pragma dvm endinterval
  338|      0|}
  339|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/jacu.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// compute the upper triangular part of the jacobian matrix
   38|       |//---------------------------------------------------------------------
   39|       |void jacu(int k)
   40|      0|{
   41|       |  //---------------------------------------------------------------------
   42|       |  // local variables
   43|       |  //---------------------------------------------------------------------
   44|      0|  int i, j;
   45|      0|  double r43;
   46|      0|  double c1345;
   47|      0|  double c34;
   48|      0|  double tmp1, tmp2, tmp3;
   49|       |
   50|      0|  r43 = ( 4.0 / 3.0 );
   51|      0|  c1345 = C1 * C3 * C4 * C5;
   52|      0|  c34 = C3 * C4;
   53|       |
   54|      0|  for (j = jst; j < jend; j++) {
   55|      0|    for (i = ist; i < iend; i++) {
   56|       |      //---------------------------------------------------------------------
   57|       |      // form the block daigonal
   58|       |      //---------------------------------------------------------------------
   59|      0|      tmp1 = rho_i[k][j][i];
   60|      0|      tmp2 = tmp1 * tmp1;
   61|      0|      tmp3 = tmp1 * tmp2;
   62|       |
   63|      0|      d[j][i][0][0] = 1.0 + dt * 2.0 * ( tx1 * dx1 + ty1 * dy1 + tz1 * dz1 );
   64|      0|      d[j][i][1][0] = 0.0;
   65|      0|      d[j][i][2][0] = 0.0;
   66|      0|      d[j][i][3][0] = 0.0;
   67|      0|      d[j][i][4][0] = 0.0;
   68|       |
   69|      0|      d[j][i][0][1] =  dt * 2.0
   70|      0|        * ( - tx1 * r43 - ty1 - tz1 )
   71|      0|        * ( c34 * tmp2 * u[k][j][i][1] );
   72|      0|      d[j][i][1][1] =  1.0
   73|      0|        + dt * 2.0 * c34 * tmp1 
   74|      0|        * (  tx1 * r43 + ty1 + tz1 )
   75|      0|        + dt * 2.0 * ( tx1 * dx2 + ty1 * dy2 + tz1 * dz2 );
   76|      0|      d[j][i][2][1] = 0.0;
   77|      0|      d[j][i][3][1] = 0.0;
   78|      0|      d[j][i][4][1] = 0.0;
   79|       |
   80|      0|      d[j][i][0][2] = dt * 2.0
   81|      0|        * ( - tx1 - ty1 * r43 - tz1 )
   82|      0|        * ( c34 * tmp2 * u[k][j][i][2] );
   83|      0|      d[j][i][1][2] = 0.0;
   84|      0|      d[j][i][2][2] = 1.0
   85|      0|        + dt * 2.0 * c34 * tmp1
   86|      0|        * (  tx1 + ty1 * r43 + tz1 )
   87|      0|        + dt * 2.0 * ( tx1 * dx3 + ty1 * dy3 + tz1 * dz3 );
   88|      0|      d[j][i][3][2] = 0.0;
   89|      0|      d[j][i][4][2] = 0.0;
   90|       |
   91|      0|      d[j][i][0][3] = dt * 2.0
   92|      0|        * ( - tx1 - ty1 - tz1 * r43 )
   93|      0|        * ( c34 * tmp2 * u[k][j][i][3] );
   94|      0|      d[j][i][1][3] = 0.0;
   95|      0|      d[j][i][2][3] = 0.0;
   96|      0|      d[j][i][3][3] = 1.0
   97|      0|        + dt * 2.0 * c34 * tmp1
   98|      0|        * (  tx1 + ty1 + tz1 * r43 )
   99|      0|        + dt * 2.0 * ( tx1 * dx4 + ty1 * dy4 + tz1 * dz4 );
  100|      0|      d[j][i][4][3] = 0.0;
  101|       |
  102|      0|      d[j][i][0][4] = -dt * 2.0
  103|      0|        * ( ( ( tx1 * ( r43*c34 - c1345 )
  104|      0|                + ty1 * ( c34 - c1345 )
  105|      0|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][1]*u[k][j][i][1] )
  106|      0|              + ( tx1 * ( c34 - c1345 )
  107|      0|                + ty1 * ( r43*c34 - c1345 )
  108|      0|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][2]*u[k][j][i][2] )
  109|      0|              + ( tx1 * ( c34 - c1345 )
  110|      0|                + ty1 * ( c34 - c1345 )
  111|      0|                + tz1 * ( r43*c34 - c1345 ) ) * (u[k][j][i][3]*u[k][j][i][3])
  112|      0|            ) * tmp3
  113|      0|            + ( tx1 + ty1 + tz1 ) * c1345 * tmp2 * u[k][j][i][4] );
  114|       |
  115|      0|      d[j][i][1][4] = dt * 2.0
  116|      0|        * ( tx1 * ( r43*c34 - c1345 )
  117|      0|          + ty1 * (     c34 - c1345 )
  118|      0|          + tz1 * (     c34 - c1345 ) ) * tmp2 * u[k][j][i][1];
  119|      0|      d[j][i][2][4] = dt * 2.0
  120|      0|        * ( tx1 * ( c34 - c1345 )
  121|      0|          + ty1 * ( r43*c34 -c1345 )
  122|      0|          + tz1 * ( c34 - c1345 ) ) * tmp2 * u[k][j][i][2];
  123|      0|      d[j][i][3][4] = dt * 2.0
  124|      0|        * ( tx1 * ( c34 - c1345 )
  125|      0|          + ty1 * ( c34 - c1345 )
  126|      0|          + tz1 * ( r43*c34 - c1345 ) ) * tmp2 * u[k][j][i][3];
  127|      0|      d[j][i][4][4] = 1.0
  128|      0|        + dt * 2.0 * ( tx1 + ty1 + tz1 ) * c1345 * tmp1
  129|      0|        + dt * 2.0 * ( tx1 * dx5 + ty1 * dy5 + tz1 * dz5 );
  130|       |
  131|       |      //---------------------------------------------------------------------
  132|       |      // form the first block sub-diagonal
  133|       |      //---------------------------------------------------------------------
  134|      0|      tmp1 = rho_i[k][j][i+1];
  135|      0|      tmp2 = tmp1 * tmp1;
  136|      0|      tmp3 = tmp1 * tmp2;
  137|       |
  138|      0|      a[j][i][0][0] = - dt * tx1 * dx1;
  139|      0|      a[j][i][1][0] =   dt * tx2;
  140|      0|      a[j][i][2][0] =   0.0;
  141|      0|      a[j][i][3][0] =   0.0;
  142|      0|      a[j][i][4][0] =   0.0;
  143|       |
  144|      0|      a[j][i][0][1] =  dt * tx2
  145|      0|        * ( - ( u[k][j][i+1][1] * tmp1 ) * ( u[k][j][i+1][1] * tmp1 )
  146|      0|            + C2 * qs[k][j][i+1] * tmp1 )
  147|      0|        - dt * tx1 * ( - r43 * c34 * tmp2 * u[k][j][i+1][1] );
  148|      0|      a[j][i][1][1] =  dt * tx2
  149|      0|        * ( ( 2.0 - C2 ) * ( u[k][j][i+1][1] * tmp1 ) )
  150|      0|        - dt * tx1 * ( r43 * c34 * tmp1 )
  151|      0|        - dt * tx1 * dx2;
  152|      0|      a[j][i][2][1] =  dt * tx2
  153|      0|        * ( - C2 * ( u[k][j][i+1][2] * tmp1 ) );
  154|      0|      a[j][i][3][1] =  dt * tx2
  155|      0|        * ( - C2 * ( u[k][j][i+1][3] * tmp1 ) );
  156|      0|      a[j][i][4][1] =  dt * tx2 * C2 ;
  157|       |
  158|      0|      a[j][i][0][2] =  dt * tx2
  159|      0|        * ( - ( u[k][j][i+1][1] * u[k][j][i+1][2] ) * tmp2 )
  160|      0|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i+1][2] );
  161|      0|      a[j][i][1][2] =  dt * tx2 * ( u[k][j][i+1][2] * tmp1 );
  162|      0|      a[j][i][2][2] =  dt * tx2 * ( u[k][j][i+1][1] * tmp1 )
  163|      0|        - dt * tx1 * ( c34 * tmp1 )
  164|      0|        - dt * tx1 * dx3;
  165|      0|      a[j][i][3][2] = 0.0;
  166|      0|      a[j][i][4][2] = 0.0;
  167|       |
  168|      0|      a[j][i][0][3] = dt * tx2
  169|      0|        * ( - ( u[k][j][i+1][1]*u[k][j][i+1][3] ) * tmp2 )
  170|      0|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i+1][3] );
  171|      0|      a[j][i][1][3] = dt * tx2 * ( u[k][j][i+1][3] * tmp1 );
  172|      0|      a[j][i][2][3] = 0.0;
  173|      0|      a[j][i][3][3] = dt * tx2 * ( u[k][j][i+1][1] * tmp1 )
  174|      0|        - dt * tx1 * ( c34 * tmp1 )
  175|      0|        - dt * tx1 * dx4;
  176|      0|      a[j][i][4][3] = 0.0;
  177|       |
  178|      0|      a[j][i][0][4] = dt * tx2
  179|      0|        * ( ( C2 * 2.0 * qs[k][j][i+1]
  180|      0|            - C1 * u[k][j][i+1][4] )
  181|      0|        * ( u[k][j][i+1][1] * tmp2 ) )
  182|      0|        - dt * tx1
  183|      0|        * ( - ( r43*c34 - c1345 ) * tmp3 * ( u[k][j][i+1][1]*u[k][j][i+1][1] )
  184|      0|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i+1][2]*u[k][j][i+1][2] )
  185|      0|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i+1][3]*u[k][j][i+1][3] )
  186|      0|            - c1345 * tmp2 * u[k][j][i+1][4] );
  187|      0|      a[j][i][1][4] = dt * tx2
  188|      0|        * ( C1 * ( u[k][j][i+1][4] * tmp1 )
  189|      0|            - C2
  190|      0|            * ( u[k][j][i+1][1]*u[k][j][i+1][1] * tmp2
  191|      0|              + qs[k][j][i+1] * tmp1 ) )
  192|      0|        - dt * tx1
  193|      0|        * ( r43*c34 - c1345 ) * tmp2 * u[k][j][i+1][1];
  194|      0|      a[j][i][2][4] = dt * tx2
  195|      0|        * ( - C2 * ( u[k][j][i+1][2]*u[k][j][i+1][1] ) * tmp2 )
  196|      0|        - dt * tx1
  197|      0|        * (  c34 - c1345 ) * tmp2 * u[k][j][i+1][2];
  198|      0|      a[j][i][3][4] = dt * tx2
  199|      0|        * ( - C2 * ( u[k][j][i+1][3]*u[k][j][i+1][1] ) * tmp2 )
  200|      0|        - dt * tx1
  201|      0|        * (  c34 - c1345 ) * tmp2 * u[k][j][i+1][3];
  202|      0|      a[j][i][4][4] = dt * tx2
  203|      0|        * ( C1 * ( u[k][j][i+1][1] * tmp1 ) )
  204|      0|        - dt * tx1 * c1345 * tmp1
  205|      0|        - dt * tx1 * dx5;
  206|       |
  207|       |      //---------------------------------------------------------------------
  208|       |      // form the second block sub-diagonal
  209|       |      //---------------------------------------------------------------------
  210|      0|      tmp1 = rho_i[k][j+1][i];
  211|      0|      tmp2 = tmp1 * tmp1;
  212|      0|      tmp3 = tmp1 * tmp2;
  213|       |
  214|      0|      b[j][i][0][0] = - dt * ty1 * dy1;
  215|      0|      b[j][i][1][0] =   0.0;
  216|      0|      b[j][i][2][0] =  dt * ty2;
  217|      0|      b[j][i][3][0] =   0.0;
  218|      0|      b[j][i][4][0] =   0.0;
  219|       |
  220|      0|      b[j][i][0][1] =  dt * ty2
  221|      0|        * ( - ( u[k][j+1][i][1]*u[k][j+1][i][2] ) * tmp2 )
  222|      0|        - dt * ty1 * ( - c34 * tmp2 * u[k][j+1][i][1] );
  223|      0|      b[j][i][1][1] =  dt * ty2 * ( u[k][j+1][i][2] * tmp1 )
  224|      0|        - dt * ty1 * ( c34 * tmp1 )
  225|      0|        - dt * ty1 * dy2;
  226|      0|      b[j][i][2][1] =  dt * ty2 * ( u[k][j+1][i][1] * tmp1 );
  227|      0|      b[j][i][3][1] = 0.0;
  228|      0|      b[j][i][4][1] = 0.0;
  229|       |
  230|      0|      b[j][i][0][2] =  dt * ty2
  231|      0|        * ( - ( u[k][j+1][i][2] * tmp1 ) * ( u[k][j+1][i][2] * tmp1 )
  232|      0|            + C2 * ( qs[k][j+1][i] * tmp1 ) )
  233|      0|        - dt * ty1 * ( - r43 * c34 * tmp2 * u[k][j+1][i][2] );
  234|      0|      b[j][i][1][2] =  dt * ty2
  235|      0|        * ( - C2 * ( u[k][j+1][i][1] * tmp1 ) );
  236|      0|      b[j][i][2][2] =  dt * ty2 * ( ( 2.0 - C2 )
  237|      0|          * ( u[k][j+1][i][2] * tmp1 ) )
  238|      0|        - dt * ty1 * ( r43 * c34 * tmp1 )
  239|      0|        - dt * ty1 * dy3;
  240|      0|      b[j][i][3][2] =  dt * ty2
  241|      0|        * ( - C2 * ( u[k][j+1][i][3] * tmp1 ) );
  242|      0|      b[j][i][4][2] =  dt * ty2 * C2;
  243|       |
  244|      0|      b[j][i][0][3] =  dt * ty2
  245|      0|        * ( - ( u[k][j+1][i][2]*u[k][j+1][i][3] ) * tmp2 )
  246|      0|        - dt * ty1 * ( - c34 * tmp2 * u[k][j+1][i][3] );
  247|      0|      b[j][i][1][3] = 0.0;
  248|      0|      b[j][i][2][3] =  dt * ty2 * ( u[k][j+1][i][3] * tmp1 );
  249|      0|      b[j][i][3][3] =  dt * ty2 * ( u[k][j+1][i][2] * tmp1 )
  250|      0|        - dt * ty1 * ( c34 * tmp1 )
  251|      0|        - dt * ty1 * dy4;
  252|      0|      b[j][i][4][3] = 0.0;
  253|       |
  254|      0|      b[j][i][0][4] =  dt * ty2
  255|      0|        * ( ( C2 * 2.0 * qs[k][j+1][i]
  256|      0|            - C1 * u[k][j+1][i][4] )
  257|      0|        * ( u[k][j+1][i][2] * tmp2 ) )
  258|      0|        - dt * ty1
  259|      0|        * ( - (     c34 - c1345 )*tmp3*(u[k][j+1][i][1]*u[k][j+1][i][1])
  260|      0|            - ( r43*c34 - c1345 )*tmp3*(u[k][j+1][i][2]*u[k][j+1][i][2])
  261|      0|            - (     c34 - c1345 )*tmp3*(u[k][j+1][i][3]*u[k][j+1][i][3])
  262|      0|            - c1345*tmp2*u[k][j+1][i][4] );
  263|      0|      b[j][i][1][4] =  dt * ty2
  264|      0|        * ( - C2 * ( u[k][j+1][i][1]*u[k][j+1][i][2] ) * tmp2 )
  265|      0|        - dt * ty1
  266|      0|        * ( c34 - c1345 ) * tmp2 * u[k][j+1][i][1];
  267|      0|      b[j][i][2][4] =  dt * ty2
  268|      0|        * ( C1 * ( u[k][j+1][i][4] * tmp1 )
  269|      0|            - C2 
  270|      0|            * ( qs[k][j+1][i] * tmp1
  271|      0|              + u[k][j+1][i][2]*u[k][j+1][i][2] * tmp2 ) )
  272|      0|        - dt * ty1
  273|      0|        * ( r43*c34 - c1345 ) * tmp2 * u[k][j+1][i][2];
  274|      0|      b[j][i][3][4] =  dt * ty2
  275|      0|        * ( - C2 * ( u[k][j+1][i][2]*u[k][j+1][i][3] ) * tmp2 )
  276|      0|        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[k][j+1][i][3];
  277|      0|      b[j][i][4][4] =  dt * ty2
  278|      0|        * ( C1 * ( u[k][j+1][i][2] * tmp1 ) )
  279|      0|        - dt * ty1 * c1345 * tmp1
  280|      0|        - dt * ty1 * dy5;
  281|       |
  282|       |      //---------------------------------------------------------------------
  283|       |      // form the third block sub-diagonal
  284|       |      //---------------------------------------------------------------------
  285|      0|      tmp1 = rho_i[k+1][j][i];
  286|      0|      tmp2 = tmp1 * tmp1;
  287|      0|      tmp3 = tmp1 * tmp2;
  288|       |
  289|      0|      c[j][i][0][0] = - dt * tz1 * dz1;
  290|      0|      c[j][i][1][0] =   0.0;
  291|      0|      c[j][i][2][0] =   0.0;
  292|      0|      c[j][i][3][0] = dt * tz2;
  293|      0|      c[j][i][4][0] =   0.0;
  294|       |
  295|      0|      c[j][i][0][1] = dt * tz2
  296|      0|        * ( - ( u[k+1][j][i][1]*u[k+1][j][i][3] ) * tmp2 )
  297|      0|        - dt * tz1 * ( - c34 * tmp2 * u[k+1][j][i][1] );
  298|      0|      c[j][i][1][1] = dt * tz2 * ( u[k+1][j][i][3] * tmp1 )
  299|      0|        - dt * tz1 * c34 * tmp1
  300|      0|        - dt * tz1 * dz2;
  301|      0|      c[j][i][2][1] = 0.0;
  302|      0|      c[j][i][3][1] = dt * tz2 * ( u[k+1][j][i][1] * tmp1 );
  303|      0|      c[j][i][4][1] = 0.0;
  304|       |
  305|      0|      c[j][i][0][2] = dt * tz2
  306|      0|        * ( - ( u[k+1][j][i][2]*u[k+1][j][i][3] ) * tmp2 )
  307|      0|        - dt * tz1 * ( - c34 * tmp2 * u[k+1][j][i][2] );
  308|      0|      c[j][i][1][2] = 0.0;
  309|      0|      c[j][i][2][2] = dt * tz2 * ( u[k+1][j][i][3] * tmp1 )
  310|      0|        - dt * tz1 * ( c34 * tmp1 )
  311|      0|        - dt * tz1 * dz3;
  312|      0|      c[j][i][3][2] = dt * tz2 * ( u[k+1][j][i][2] * tmp1 );
  313|      0|      c[j][i][4][2] = 0.0;
  314|       |
  315|      0|      c[j][i][0][3] = dt * tz2
  316|      0|        * ( - ( u[k+1][j][i][3] * tmp1 ) * ( u[k+1][j][i][3] * tmp1 )
  317|      0|            + C2 * ( qs[k+1][j][i] * tmp1 ) )
  318|      0|        - dt * tz1 * ( - r43 * c34 * tmp2 * u[k+1][j][i][3] );
  319|      0|      c[j][i][1][3] = dt * tz2
  320|      0|        * ( - C2 * ( u[k+1][j][i][1] * tmp1 ) );
  321|      0|      c[j][i][2][3] = dt * tz2
  322|      0|        * ( - C2 * ( u[k+1][j][i][2] * tmp1 ) );
  323|      0|      c[j][i][3][3] = dt * tz2 * ( 2.0 - C2 )
  324|      0|        * ( u[k+1][j][i][3] * tmp1 )
  325|      0|        - dt * tz1 * ( r43 * c34 * tmp1 )
  326|      0|        - dt * tz1 * dz4;
  327|      0|      c[j][i][4][3] = dt * tz2 * C2;
  328|       |
  329|      0|      c[j][i][0][4] = dt * tz2
  330|      0|        * ( ( C2 * 2.0 * qs[k+1][j][i]
  331|      0|            - C1 * u[k+1][j][i][4] )
  332|      0|                 * ( u[k+1][j][i][3] * tmp2 ) )
  333|      0|        - dt * tz1
  334|      0|        * ( - ( c34 - c1345 ) * tmp3 * (u[k+1][j][i][1]*u[k+1][j][i][1])
  335|      0|            - ( c34 - c1345 ) * tmp3 * (u[k+1][j][i][2]*u[k+1][j][i][2])
  336|      0|            - ( r43*c34 - c1345 )* tmp3 * (u[k+1][j][i][3]*u[k+1][j][i][3])
  337|      0|            - c1345 * tmp2 * u[k+1][j][i][4] );
  338|      0|      c[j][i][1][4] = dt * tz2
  339|      0|        * ( - C2 * ( u[k+1][j][i][1]*u[k+1][j][i][3] ) * tmp2 )
  340|      0|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k+1][j][i][1];
  341|      0|      c[j][i][2][4] = dt * tz2
  342|      0|        * ( - C2 * ( u[k+1][j][i][2]*u[k+1][j][i][3] ) * tmp2 )
  343|      0|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k+1][j][i][2];
  344|      0|      c[j][i][3][4] = dt * tz2
  345|      0|        * ( C1 * ( u[k+1][j][i][4] * tmp1 )
  346|      0|            - C2
  347|      0|            * ( qs[k+1][j][i] * tmp1
  348|      0|              + u[k+1][j][i][3]*u[k+1][j][i][3] * tmp2 ) )
  349|      0|        - dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[k+1][j][i][3];
  350|      0|      c[j][i][4][4] = dt * tz2
  351|      0|        * ( C1 * ( u[k+1][j][i][3] * tmp1 ) )
  352|      0|        - dt * tz1 * c1345 * tmp1
  353|      0|        - dt * tz1 * dz5;
  354|      0|    }
  355|      0|  }
  356|      0|}
  357|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/l2norm.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <math.h>
   35|       |#include "applu.incl"
   36|       |
   37|       |//---------------------------------------------------------------------
   38|       |// to compute the l2-norm of vector v.
   39|       |//---------------------------------------------------------------------
   40|       |//---------------------------------------------------------------------
   41|       |// To improve cache performance, second two dimensions padded by 1 
   42|       |// for even number sizes only.  Only needed in v.
   43|       |//---------------------------------------------------------------------
   44|       |#pragma dvm inherit(v)
   45|       |void l2norm (int ldx, int ldy, int ldz, int nx0, int ny0, int nz0,
   46|       |     int ist, int iend, int jst, int jend,
   47|       |     double v[][ldy/2*2+1][ldx/2*2+1][5], double sum[5])
   48|      4|{
   49|      4|#pragma dvm interval
   50|       |  //---------------------------------------------------------------------
   51|       |  // local variables
   52|       |  //---------------------------------------------------------------------
   53|      4|  int i, j, k, m;
   54|      4|  double sum_tmp[5];
   55|       |
   56|     24|  for (m = 0; m < 5; m++) {
   57|     20|    sum_tmp[m] = 0.0;
   58|     20|  }
   59|      4|#pragma dvm actual(sum_tmp)
   60|      4|#pragma dvm region
   61|      4|{
   62|      4|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m) reduction(sum(sum_tmp))
   63|    252|  for (k = 1; k < nz0-1; k++) {
   64|  15.6k|    for (j = jst; j < jend; j++) {
   65|   968k|      for (i = ist; i < iend; i++) {
   66|  5.71M|        for (m = 0; m < 5; m++) {
   67|  4.76M|          sum_tmp[m] = sum_tmp[m] + v[k][j][i][m] * v[k][j][i][m];
   68|  4.76M|        }
   69|   953k|      }
   70|  15.3k|    }
   71|    248|  }
   72|      4|}
   73|      4|#pragma dvm get_actual(sum_tmp)
   74|     24|  for (m = 0; m < 5; m++) {
   75|     20|    sum[m] = sqrt ( sum_tmp[m] / ( (nx0-2)*(ny0-2)*(nz0-2) ) );
   76|     20|  }
   77|      4|#pragma dvm endinterval
   78|      4|}
   79|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/lu.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |//---------------------------------------------------------------------
   35|       |//   program applu
   36|       |//---------------------------------------------------------------------
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |//
   40|       |//   driver for the performance evaluation of the solver for
   41|       |//   five coupled parabolic/elliptic partial differential equations.
   42|       |//
   43|       |//---------------------------------------------------------------------
   44|       |
   45|       |#include <stdio.h>
   46|       |#include <stdlib.h>
   47|       |#include <math.h>
   48|       |
   49|       |#include "applu.incl"
   50|       |#include "timers.h"
   51|       |#include "print_results.h"
   52|       |
   53|       |
   54|       |//---------------------------------------------------------------------
   55|       |// grid
   56|       |//---------------------------------------------------------------------
   57|       |/* common/cgcon/ */
   58|       |double dxi, deta, dzeta;
   59|       |double tx1, tx2, tx3;
   60|       |double ty1, ty2, ty3;
   61|       |double tz1, tz2, tz3;
   62|       |int nx, ny, nz;
   63|       |int nx0, ny0, nz0;
   64|       |int ist, iend;
   65|       |int jst, jend;
   66|       |int ii1, ii2;
   67|       |int ji1, ji2;
   68|       |int ki1, ki2;
   69|       |
   70|       |//---------------------------------------------------------------------
   71|       |// dissipation
   72|       |//---------------------------------------------------------------------
   73|       |/* common/disp/ */
   74|       |double dx1, dx2, dx3, dx4, dx5;
   75|       |double dy1, dy2, dy3, dy4, dy5;
   76|       |double dz1, dz2, dz3, dz4, dz5;
   77|       |double dssp;
   78|       |
   79|       |//---------------------------------------------------------------------
   80|       |// field variables and residuals
   81|       |// to improve cache performance, second two dimensions padded by 1 
   82|       |// for even number sizes only.
   83|       |// Note: corresponding array (called "v") in routines blts, buts, 
   84|       |// and l2norm are similarly padded
   85|       |//---------------------------------------------------------------------
   86|       |/* common/cvar/ */
   87|       |//#pragma dvm template [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1] distribute [][][]
   88|       |#pragma dvm template [ISIZ3+2][ISIZ3+2][ISIZ3+2] distribute [block][block][block]
   89|       |void *dvm_tpl;
   90|       |
   91|       |#pragma dvm array align ([i][j][k][] with dvm_tpl[i][j][k]) shadow[2][2][2][0]
   92|       |double u    [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   93|       |#pragma dvm array align ([i][j][k][] with dvm_tpl[i][j][k]) shadow[2][2][2][0]
   94|       |double rsd  [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   95|       |#pragma dvm array align ([i][j][k][] with dvm_tpl[i][j][k])
   96|       |double frct [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   97|       |double flux [ISIZ1][5];
   98|       |#pragma dvm array align ([i][j][k] with dvm_tpl[i][j][k]) shadow[1:2][1:2][1:2]
   99|       |double qs   [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
  100|       |#pragma dvm array align ([i][j][k] with dvm_tpl[i][j][k]) shadow[1:2][1:2][1:2]
  101|       |double rho_i[ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
  102|       |
  103|       |//---------------------------------------------------------------------
  104|       |// output control parameters
  105|       |//---------------------------------------------------------------------
  106|       |/* common/cprcon/ */
  107|       |int ipr, inorm;
  108|       |
  109|       |//---------------------------------------------------------------------
  110|       |// newton-raphson iteration control parameters
  111|       |//---------------------------------------------------------------------
  112|       |/* common/ctscon/ */
  113|       |double dt, omega, tolrsd[5], rsdnm[5], errnm[5], frc, ttotal;
  114|       |int itmax, invert;
  115|       |
  116|       |/* common/cjac/ */
  117|       |double a[ISIZ2][ISIZ1/2*2+1][5][5];
  118|       |double b[ISIZ2][ISIZ1/2*2+1][5][5];
  119|       |double c[ISIZ2][ISIZ1/2*2+1][5][5];
  120|       |double d[ISIZ2][ISIZ1/2*2+1][5][5];
  121|       |
  122|       |
  123|       |//---------------------------------------------------------------------
  124|       |// coefficients of the exact solution
  125|       |//---------------------------------------------------------------------
  126|       |/* common/cexact/ */
  127|       |double ce[5][13];
  128|       |
  129|       |
  130|       |//---------------------------------------------------------------------
  131|       |// timers
  132|       |//---------------------------------------------------------------------
  133|       |/* common/timer/ */
  134|       |double maxtime;
  135|       |logical timeron;
  136|       |
  137|       |
  138|       |int main(int argc, char *argv[])
  139|      1|{
  140|      1|  char Class;
  141|      1|  logical verified;
  142|      1|  double mflops;
  143|       |
  144|      1|  double t, tmax, trecs[t_last+1];
  145|      1|  int i;
  146|      1|  char *t_names[t_last+1];
  147|       |
  148|       |  //---------------------------------------------------------------------
  149|       |  // Setup info for timers
  150|       |  //---------------------------------------------------------------------
  151|      1|  FILE *fp;
  152|      1|  if ((fp = fopen("timer.flag", "r")) != NULL) {
  153|      0|    timeron = true;
  154|      0|    t_names[t_total] = "total";
  155|      0|    t_names[t_rhsx] = "rhsx";
  156|      0|    t_names[t_rhsy] = "rhsy";
  157|      0|    t_names[t_rhsz] = "rhsz";
  158|      0|    t_names[t_rhs] = "rhs";
  159|      0|    t_names[t_jacld] = "jacld";
  160|      0|    t_names[t_blts] = "blts";
  161|      0|    t_names[t_jacu] = "jacu";
  162|      0|    t_names[t_buts] = "buts";
  163|      0|    t_names[t_add] = "add";
  164|      0|    t_names[t_l2norm] = "l2norm";
  165|      0|    fclose(fp);
  166|      1|  } else {
  167|      1|    timeron = false;
  168|      1|  }
  169|       |
  170|       |  //---------------------------------------------------------------------
  171|       |  // read input data
  172|       |  //---------------------------------------------------------------------
  173|      1|  read_input();
  174|       |
  175|       |  //---------------------------------------------------------------------
  176|       |  // set up domain sizes
  177|       |  //---------------------------------------------------------------------
  178|      1|  domain();
  179|       |
  180|       |  //---------------------------------------------------------------------
  181|       |  // set up coefficients
  182|       |  //---------------------------------------------------------------------
  183|      1|  setcoeff();
  184|       |
  185|       |  //---------------------------------------------------------------------
  186|       |  // set the boundary values for dependent variables
  187|       |  //---------------------------------------------------------------------
  188|      1|  setbv();
  189|       |
  190|       |  //---------------------------------------------------------------------
  191|       |  // set the initial values for dependent variables
  192|       |  //---------------------------------------------------------------------
  193|      1|  setiv();
  194|       |
  195|       |  //---------------------------------------------------------------------
  196|       |  // compute the forcing term based on prescribed exact solution
  197|       |  //---------------------------------------------------------------------
  198|      1|  erhs();
  199|       |
  200|       |  //---------------------------------------------------------------------
  201|       |  // perform one SSOR iteration to touch all pages
  202|       |  //---------------------------------------------------------------------
  203|      1|  ssor(1);
  204|       |
  205|       |  //---------------------------------------------------------------------
  206|       |  // reset the boundary and initial values
  207|       |  //---------------------------------------------------------------------
  208|      1|  setbv();
  209|      1|  setiv();
  210|       |
  211|       |  //---------------------------------------------------------------------
  212|       |  // perform the SSOR iterations
  213|       |  //---------------------------------------------------------------------
  214|      1|  ssor(itmax);
  215|       |
  216|       |  //---------------------------------------------------------------------
  217|       |  // compute the solution error
  218|       |  //---------------------------------------------------------------------
  219|      1|  error();
  220|       |
  221|       |  //---------------------------------------------------------------------
  222|       |  // compute the surface integral
  223|       |  //---------------------------------------------------------------------
  224|      1|  pintgr();
  225|       |
  226|       |  //---------------------------------------------------------------------
  227|       |  // verification test
  228|       |  //---------------------------------------------------------------------
  229|      1|  verify ( rsdnm, errnm, frc, &Class, &verified );
  230|      1|  mflops = (double)itmax * (1984.77 * (double)nx0
  231|      1|      * (double)ny0
  232|      1|      * (double)nz0
  233|      1|      - 10923.3 * pow(((double)(nx0+ny0+nz0)/3.0), 2.0) 
  234|      1|      + 27770.9 * (double)(nx0+ny0+nz0)/3.0
  235|      1|      - 144010.0)
  236|      1|    / (maxtime*1000000.0);
  237|       |
  238|      1|  print_results("LU", Class, nx0,
  239|      1|                ny0, nz0, itmax,
  240|      1|                maxtime, mflops, "          floating point", verified, 
  241|      1|                NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, 
  242|      1|                "(none)");
  243|       |
  244|       |  //---------------------------------------------------------------------
  245|       |  // More timers
  246|       |  //---------------------------------------------------------------------
  247|      1|  if (timeron) {
  248|      0|    for (i = 1; i <= t_last; i++) {
  249|      0|      trecs[i] = timer_read(i);
  250|      0|    }
  251|      0|    tmax = maxtime;
  252|      0|    if (tmax == 0.0) tmax = 1.0;
  253|       |
  254|      0|    printf("  SECTION     Time (secs)\n");
  255|      0|    for (i = 1; i <= t_last; i++) {
  256|      0|      printf("  %-8s:%9.3f  (%6.2f%%)\n",
  257|      0|          t_names[i], trecs[i], trecs[i]*100./tmax);
  258|      0|      if (i == t_rhs) {
  259|      0|        t = trecs[t_rhsx] + trecs[t_rhsy] + trecs[t_rhsz];
  260|      0|        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "sub-rhs", t, t*100./tmax);
  261|      0|        t = trecs[i] - t;
  262|      0|        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "rest-rhs", t, t*100./tmax);
  263|      0|      }
  264|      0|    }
  265|      0|  }
  266|       |
  267|      1|  return 0;
  268|      1|}
  269|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/npbparams.h:
    1|       |/* CLASS = A */
    2|       |/*
    3|       |   This file is generated automatically by the setparams utility.
    4|       |   It sets the number of processors and the class of the NPB
    5|       |   in this directory. Do not modify it by hand.   
    6|       |*/
    7|       |
    8|       |/* full problem size */
    9|   119M|#define ISIZ1  64
   10|   119M|#define ISIZ2  64
   11|   119M|#define ISIZ3  64
   12|       |
   13|       |/* number of iterations and how often to print the norm */
   14|      1|#define ITMAX_DEFAULT  250
   15|      1|#define INORM_DEFAULT  250
   16|      1|#define DT_DEFAULT     2.0
   17|       |
   18|       |#define CONVERTDOUBLE  false
   19|      1|#define COMPILETIME "05 Apr 2024"
   20|      1|#define NPBVERSION "3.3.1"
   21|      1|#define CS1 "clang"
   22|      1|#define CS2 "clang"
   23|      1|#define CS3 "-lm"
   24|      1|#define CS4 "-I ../common"
   25|      1|#define CS5 "-c -g -O3 -fprofile-instr-generate -fcovera..."
   26|      1|#define CS6 "-O3 -fprofile-instr-generate -fcoverage-map..."
   27|       |#define CS7 "randdp"

/home/dvmuser3/andrey/npb-3.3-c/LU/pintgr.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include "applu.incl"
   36|       |
   37|       |void pintgr()
   38|      1|{
   39|       |  //---------------------------------------------------------------------
   40|       |  // local variables
   41|       |  //---------------------------------------------------------------------
   42|      1|  int i, j, k;
   43|      1|  int ibeg, ifin, ifin1;
   44|      1|  int jbeg, jfin, jfin1;
   45|      1|  #pragma dvm array shadow[0:1][0:1]
   46|      1|  double phi1k[ISIZ3+2][ISIZ2+2];
   47|      1|  #pragma dvm array shadow[0:1][0:1]
   48|      1|  double phi2k[ISIZ3+2][ISIZ2+2];
   49|      1|  #pragma dvm array shadow[0:1][0:1]
   50|      1|  double phi1j[ISIZ3+2][ISIZ2+2];
   51|      1|  #pragma dvm array shadow[0:1][0:1]
   52|      1|  double phi2j[ISIZ3+2][ISIZ2+2];
   53|      1|  #pragma dvm array shadow[0:1][0:1]
   54|      1|  double phi1i[ISIZ3+2][ISIZ2+2];
   55|      1|  #pragma dvm array shadow[0:1][0:1]
   56|      1|  double phi2i[ISIZ3+2][ISIZ2+2];
   57|      1|  double frc1, frc2, frc3;
   58|       |
   59|       |  //---------------------------------------------------------------------
   60|       |  // set up the sub-domains for integeration in each processor
   61|       |  //---------------------------------------------------------------------
   62|      1|  ibeg = ii1;
   63|      1|  ifin = ii2;
   64|      1|  jbeg = ji1;
   65|      1|  jfin = ji2;
   66|      1|  ifin1 = ifin - 1;
   67|      1|  jfin1 = jfin - 1;
   68|       |
   69|       |
   70|       |  //---------------------------------------------------------------------
   71|       |  // initialize
   72|       |  //---------------------------------------------------------------------
   73|      1|#pragma dvm realign(phi1k[j][i] with dvm_tpl[ki1][j][i])
   74|      1|#pragma dvm realign(phi2k[j][i] with dvm_tpl[ki2-1][j][i])
   75|       |
   76|      1|#pragma dvm parallel ([k][i] on dvm_tpl[ki1][k][i]) private(k, i)
   77|     67|  for (k = 0; k <= ISIZ3+1; k++) {
   78|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
   79|  4.35k|      phi1k[k][i] = 0.0;
   80|  4.35k|    }
   81|     66|  }
   82|       |
   83|      1|#pragma dvm parallel ([k][i] on dvm_tpl[ki2-1][k][i]) private(k, i)
   84|     67|  for (k = 0; k <= ISIZ3+1; k++) {
   85|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
   86|  4.35k|      phi2k[k][i] = 0.0;
   87|  4.35k|    }
   88|     66|  }
   89|       |
   90|      1|#pragma dvm parallel ([j][i] on dvm_tpl[ki1][j][i]) private(k, j, i)
   91|     62|  for (j = jbeg; j < jfin; j++) {
   92|  3.84k|    for (i = ibeg; i < ifin; i++) {
   93|  3.78k|      k = ki1;
   94|       |
   95|  3.78k|      phi1k[j][i] = C2*(  u[k][j][i][4]
   96|  3.78k|          - 0.50 * (  u[k][j][i][1] * u[k][j][i][1]
   97|  3.78k|                    + u[k][j][i][2] * u[k][j][i][2]
   98|  3.78k|                    + u[k][j][i][3] * u[k][j][i][3] )
   99|  3.78k|                   / u[k][j][i][0] );
  100|  3.78k|    }
  101|     61|  }
  102|       |
  103|      1|#pragma dvm parallel ([j][i] on dvm_tpl[ki2-1][j][i]) private(k, j, i)
  104|     62|  for (j = jbeg; j < jfin; j++) {
  105|  3.84k|    for (i = ibeg; i < ifin; i++) {
  106|  3.78k|      k = ki2 - 1;
  107|       |
  108|  3.78k|      phi2k[j][i] = C2*(  u[k][j][i][4]
  109|  3.78k|          - 0.50 * (  u[k][j][i][1] * u[k][j][i][1]
  110|  3.78k|                    + u[k][j][i][2] * u[k][j][i][2]
  111|  3.78k|                    + u[k][j][i][3] * u[k][j][i][3] )
  112|  3.78k|                   / u[k][j][i][0] );
  113|  3.78k|    }
  114|     61|  }
  115|       |
  116|      1|  frc1 = 0.0;
  117|      1|#pragma dvm parallel ([j][i] on dvm_tpl[ki1][j][i]) private(k, j, i) reduction(sum(frc1)) shadow_renew(phi1k[0:1][0:1](corner))
  118|     61|  for (j = jbeg; j < jfin1; j++) {
  119|  3.72k|    for (i = ibeg; i < ifin1; i++) {
  120|  3.66k|      frc1 = frc1 + (  phi1k[j][i]
  121|  3.66k|                     + phi1k[j][i+1]
  122|  3.66k|                     + phi1k[j+1][i]
  123|  3.66k|                     + phi1k[j+1][i+1] );
  124|  3.66k|    }
  125|     60|  }
  126|       |
  127|      1|#pragma dvm parallel ([j][i] on dvm_tpl[ki2-1][j][i]) private(k, j, i) reduction(sum(frc1)) shadow_renew(phi2k[0:1][0:1](corner))
  128|     61|  for (j = jbeg; j < jfin1; j++) {
  129|  3.72k|    for (i = ibeg; i < ifin1; i++) {
  130|  3.66k|      frc1 = frc1 + (  phi2k[j][i]
  131|  3.66k|                     + phi2k[j][i+1]
  132|  3.66k|                     + phi2k[j+1][i]
  133|  3.66k|                     + phi2k[j+1][i+1] );
  134|  3.66k|    }
  135|     60|  }
  136|      1|  frc1 = dxi * deta * frc1;
  137|       |
  138|       |  //---------------------------------------------------------------------
  139|       |  // initialize
  140|       |  //---------------------------------------------------------------------
  141|      1|#pragma dvm realign(phi1j[k][i] with dvm_tpl[k][jbeg][i])
  142|      1|#pragma dvm realign(phi2j[k][i] with dvm_tpl[k][jfin-1][i])
  143|       |
  144|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][jbeg][i]) private(k, i)
  145|     67|  for (k = 0; k <= ISIZ3+1; k++) {
  146|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
  147|  4.35k|      phi1j[k][i] = 0.0;
  148|  4.35k|    }
  149|     66|  }
  150|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][jfin-1][i]) private(k, i)
  151|     67|  for (k = 0; k <= ISIZ3+1; k++) {
  152|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
  153|  4.35k|      phi2j[k][i] = 0.0;
  154|  4.35k|    }
  155|     66|  }
  156|      1|  if (jbeg == ji1) {
  157|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][jbeg][i]) private(k, i)
  158|     62|    for (k = ki1; k < ki2; k++) {
  159|  3.84k|      for (i = ibeg; i < ifin; i++) {
  160|  3.78k|        phi1j[k][i] = C2*(  u[k][jbeg][i][4]
  161|  3.78k|            - 0.50 * (  u[k][jbeg][i][1] * u[k][jbeg][i][1]
  162|  3.78k|                      + u[k][jbeg][i][2] * u[k][jbeg][i][2]
  163|  3.78k|                      + u[k][jbeg][i][3] * u[k][jbeg][i][3] )
  164|  3.78k|                     / u[k][jbeg][i][0] );
  165|  3.78k|      }
  166|     61|    }
  167|      1|  }
  168|       |
  169|      1|  if (jfin == ji2) {
  170|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][jfin-1][i]) private(k, i)
  171|     62|    for (k = ki1; k < ki2; k++) {
  172|  3.84k|      for (i = ibeg; i < ifin; i++) {
  173|  3.78k|        phi2j[k][i] = C2*(  u[k][jfin-1][i][4]
  174|  3.78k|            - 0.50 * (  u[k][jfin-1][i][1] * u[k][jfin-1][i][1]
  175|  3.78k|                      + u[k][jfin-1][i][2] * u[k][jfin-1][i][2]
  176|  3.78k|                      + u[k][jfin-1][i][3] * u[k][jfin-1][i][3] )
  177|  3.78k|                     / u[k][jfin-1][i][0] );
  178|  3.78k|      }
  179|     61|    }
  180|      1|  }
  181|       |
  182|      1|  frc2 = 0.0;
  183|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][jbeg][i]) private(k, i) reduction(sum(frc2)) shadow_renew(phi1j[0:1][0:1](corner))
  184|     61|  for (k = ki1; k < ki2-1; k++) {
  185|  3.72k|    for (i = ibeg; i < ifin1; i++) {
  186|  3.66k|      frc2 = frc2 + (  phi1j[k][i]
  187|  3.66k|                     + phi1j[k][i+1]
  188|  3.66k|                     + phi1j[k+1][i]
  189|  3.66k|                     + phi1j[k+1][i+1] );
  190|  3.66k|    }
  191|     60|  }
  192|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][jfin-1][i]) private(k, i) reduction(sum(frc2)) shadow_renew(phi2j[0:1][0:1](corner))
  193|     61|  for (k = ki1; k < ki2-1; k++) {
  194|  3.72k|    for (i = ibeg; i < ifin1; i++) {
  195|  3.66k|      frc2 = frc2 + (  phi2j[k][i]
  196|  3.66k|                     + phi2j[k][i+1]
  197|  3.66k|                     + phi2j[k+1][i]
  198|  3.66k|                     + phi2j[k+1][i+1] );
  199|  3.66k|    }
  200|     60|  }
  201|      1|  frc2 = dxi * dzeta * frc2;
  202|       |
  203|       |  //---------------------------------------------------------------------
  204|       |  // initialize
  205|       |  //---------------------------------------------------------------------
  206|      1|#pragma dvm realign(phi1i[k][j] with dvm_tpl[k][j][ibeg])
  207|      1|#pragma dvm realign(phi2i[k][j] with dvm_tpl[k][j][ifin-1])
  208|       |
  209|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][i][ibeg]) private(k, i)
  210|     67|  for (k = 0; k <= ISIZ3+1; k++) {
  211|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
  212|  4.35k|      phi1i[k][i] = 0.0;
  213|  4.35k|    }
  214|     66|  }
  215|      1|#pragma dvm parallel([k][i] on dvm_tpl[k][i][ifin-1]) private(k, i)
  216|     67|  for (k = 0; k <= ISIZ3+1; k++) {
  217|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
  218|  4.35k|      phi2i[k][i] = 0.0;
  219|  4.35k|    }
  220|     66|  }
  221|      1|  if (ibeg == ii1) {
  222|      1|#pragma dvm parallel([k][j] on dvm_tpl[k][j][ibeg]) private(k, j)
  223|     62|    for (k = ki1; k < ki2; k++) {
  224|  3.78k|      for (j = jbeg; j < jfin; j++) {
  225|  3.72k|        phi1i[k][j] = C2*(  u[k][j][ibeg][4]
  226|  3.72k|            - 0.50 * (  u[k][j][ibeg][1] * u[k][j][ibeg][1]
  227|  3.72k|                      + u[k][j][ibeg][2] * u[k][j][ibeg][2]
  228|  3.72k|                      + u[k][j][ibeg][3] * u[k][j][ibeg][3] )
  229|  3.72k|                     / u[k][j][ibeg][0] );
  230|  3.72k|      }
  231|     61|    }
  232|      1|  }
  233|       |
  234|      1|  if (ifin == ii2) {
  235|      1|#pragma dvm parallel([k][j] on dvm_tpl[k][j][ifin-1]) private(k, j)
  236|     62|    for (k = ki1; k < ki2; k++) {
  237|  3.78k|      for (j = jbeg; j < jfin; j++) {
  238|  3.72k|        phi2i[k][j] = C2*(  u[k][j][ifin-1][4]
  239|  3.72k|            - 0.50 * (  u[k][j][ifin-1][1] * u[k][j][ifin-1][1]
  240|  3.72k|                      + u[k][j][ifin-1][2] * u[k][j][ifin-1][2]
  241|  3.72k|                      + u[k][j][ifin-1][3] * u[k][j][ifin-1][3] )
  242|  3.72k|                     / u[k][j][ifin-1][0] );
  243|  3.72k|      }
  244|     61|    }
  245|      1|  }
  246|       |
  247|      1|  frc3 = 0.0;
  248|      1|#pragma dvm parallel([k][j] on dvm_tpl[k][j][ibeg]) private(k, j) reduction(sum(frc3)) shadow_renew(phi1i[0:1][0:1](corner))
  249|     61|  for (k = ki1; k < ki2-1; k++) {
  250|  3.66k|    for (j = jbeg; j < jfin1; j++) {
  251|  3.60k|      frc3 = frc3 + (  phi1i[k][j]
  252|  3.60k|                     + phi1i[k][j+1]
  253|  3.60k|                     + phi1i[k+1][j]
  254|  3.60k|                     + phi1i[k+1][j+1] );
  255|  3.60k|    }
  256|     60|  }
  257|      1|#pragma dvm parallel([k][j] on dvm_tpl[k][j][ifin-1]) private(k, j) reduction(sum(frc3)) shadow_renew(phi2i[0:1][0:1](corner))
  258|     61|  for (k = ki1; k < ki2-1; k++) {
  259|  3.66k|    for (j = jbeg; j < jfin1; j++) {
  260|  3.60k|      frc3 = frc3 + (  phi2i[k][j]
  261|  3.60k|                     + phi2i[k][j+1]
  262|  3.60k|                     + phi2i[k+1][j]
  263|  3.60k|                     + phi2i[k+1][j+1] );
  264|  3.60k|    }
  265|     60|  }
  266|      1|  frc3 = deta * dzeta * frc3;
  267|       |
  268|      1|  frc = 0.25 * ( frc1 + frc2 + frc3 );
  269|       |  //printf("\n\n     surface integral = %12.5E\n\n\n", frc);
  270|      1|}
  271|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/read_input.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <stdlib.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |void read_input()
   39|      1|{
   40|      1|  FILE *fp;
   41|      1|  int result;
   42|       |
   43|       |  //---------------------------------------------------------------------
   44|       |  // if input file does not exist, it uses defaults
   45|       |  //    ipr = 1 for detailed progress output
   46|       |  //    inorm = how often the norm is printed (once every inorm iterations)
   47|       |  //    itmax = number of pseudo time steps
   48|       |  //    dt = time step
   49|       |  //    omega 1 over-relaxation factor for SSOR
   50|       |  //    tolrsd = steady state residual tolerance levels
   51|       |  //    nx, ny, nz = number of grid points in x, y, z directions
   52|       |  //---------------------------------------------------------------------
   53|       |
   54|      1|  printf("\n\n NAS Parallel Benchmarks (NPB3.3-SER-C) - LU Benchmark\n\n");
   55|       |
   56|      1|  if ((fp = fopen("inputlu.data", "r")) != NULL) {
   57|      0|    printf("Reading from input file inputlu.data\n");
   58|       |
   59|      0|    while (fgetc(fp) != '\n');
   60|      0|    while (fgetc(fp) != '\n');
   61|      0|    result = fscanf(fp, "%d%d", &ipr, &inorm); 
   62|      0|    while (fgetc(fp) != '\n');
   63|       |
   64|      0|    while (fgetc(fp) != '\n');
   65|      0|    while (fgetc(fp) != '\n');
   66|      0|    result = fscanf(fp, "%d", &itmax);
   67|      0|    while (fgetc(fp) != '\n');
   68|       |
   69|      0|    while (fgetc(fp) != '\n');
   70|      0|    while (fgetc(fp) != '\n');
   71|      0|    result = fscanf(fp, "%lf", &dt);
   72|      0|    while (fgetc(fp) != '\n');
   73|       |
   74|      0|    while (fgetc(fp) != '\n');
   75|      0|    while (fgetc(fp) != '\n');
   76|      0|    result = fscanf(fp, "%lf", &omega);
   77|      0|    while (fgetc(fp) != '\n');
   78|       |
   79|      0|    while (fgetc(fp) != '\n');
   80|      0|    while (fgetc(fp) != '\n');
   81|      0|    result = fscanf(fp, "%lf%lf%lf%lf%lf",
   82|      0|        &tolrsd[0], &tolrsd[1], &tolrsd[2], &tolrsd[3], &tolrsd[4]);
   83|      0|    while (fgetc(fp) != '\n');
   84|      0|    while (fgetc(fp) != '\n');
   85|      0|    result = fscanf(fp, "%d%d%d", &nx0, &ny0, &nz0);
   86|      0|    fclose(fp);
   87|      1|  } else {
   88|      1|    ipr = IPR_DEFAULT;
   89|      1|    inorm = INORM_DEFAULT;
   90|      1|    itmax = ITMAX_DEFAULT;
   91|      1|    dt = DT_DEFAULT;
   92|      1|    omega = OMEGA_DEFAULT;
   93|      1|    tolrsd[0] = TOLRSD1_DEF;
   94|      1|    tolrsd[1] = TOLRSD2_DEF;
   95|      1|    tolrsd[2] = TOLRSD3_DEF;
   96|      1|    tolrsd[3] = TOLRSD4_DEF;
   97|      1|    tolrsd[4] = TOLRSD5_DEF;
   98|      1|    nx0 = ISIZ1;
   99|      1|    ny0 = ISIZ2;
  100|      1|    nz0 = ISIZ3;
  101|      1|  }
  102|       |
  103|       |  //---------------------------------------------------------------------
  104|       |  // check problem size
  105|       |  //---------------------------------------------------------------------
  106|      1|  if ( ( nx0 < 4 ) || ( ny0 < 4 ) || ( nz0 < 4 ) ) {
  107|      0|    printf("     PROBLEM SIZE IS TOO SMALL - \n"
  108|      0|           "     SET EACH OF NX, NY AND NZ AT LEAST EQUAL TO 5\n");
  109|      0|    exit(EXIT_FAILURE);
  110|      0|  }
  111|       |
  112|      1|  if ( ( nx0 > ISIZ1 ) || ( ny0 > ISIZ2 ) || ( nz0 > ISIZ3 ) ) {
  113|      0|    printf("     PROBLEM SIZE IS TOO LARGE - \n"
  114|      0|           "     NX, NY AND NZ SHOULD BE EQUAL TO \n"
  115|      0|           "     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY\n");
  116|      0|    exit(EXIT_FAILURE);
  117|      0|  }
  118|       |
  119|      1|  printf(" Size: %4dx%4dx%4d\n", nx0, ny0, nz0);
  120|      1|  printf(" Iterations: %4d\n", itmax);
  121|      1|  printf("\n");
  122|      1|}

/home/dvmuser3/andrey/npb-3.3-c/LU/rhs.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |#include "timers.h"
   36|       |
   37|       |//---------------------------------------------------------------------
   38|       |// compute the right hand sides
   39|       |//---------------------------------------------------------------------
   40|       |void rhs()
   41|    253|{
   42|    253|#pragma dvm interval
   43|       |  //---------------------------------------------------------------------
   44|       |  // local variables
   45|       |  //---------------------------------------------------------------------
   46|    253|  int i, j, k, m;
   47|    253|  double q;
   48|    253|  double tmp;
   49|    253|  double u21, u31, u41;
   50|    253|  double u21i, u31i, u41i, u51i;
   51|    253|  double u21j, u31j, u41j, u51j;
   52|    253|  double u21k, u31k, u41k, u51k;
   53|    253|  double u21im1, u31im1, u41im1, u51im1;
   54|    253|  double u21jm1, u31jm1, u41jm1, u51jm1;
   55|    253|  double u21km1, u31km1, u41km1, u51km1;
   56|       |
   57|    253|  if (timeron) timer_start(t_rhs);
   58|    253|#pragma dvm region
   59|    253|{
   60|    253|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, tmp)
   61|  16.4k|  for (k = 0; k < nz; k++) {
   62|  1.05M|    for (j = 0; j < ny; j++) {
   63|  67.3M|      for (i = 0; i < nx; i++) {
   64|   397M|        for (m = 0; m < 5; m++) {
   65|   331M|          rsd[k][j][i][m] = - frct[k][j][i][m];
   66|   331M|        }
   67|  66.3M|        tmp = 1.0 / u[k][j][i][0];
   68|  66.3M|        rho_i[k][j][i] = tmp;
   69|  66.3M|        qs[k][j][i] = 0.50 * (  u[k][j][i][1] * u[k][j][i][1]
   70|  66.3M|                              + u[k][j][i][2] * u[k][j][i][2]
   71|  66.3M|                              + u[k][j][i][3] * u[k][j][i][3] )
   72|  66.3M|                           * tmp;
   73|  66.3M|      }
   74|  1.03M|    }
   75|  16.1k|  }
   76|    253|}
   77|    253|  if (timeron) timer_start(t_rhsx);
   78|       |  //---------------------------------------------------------------------
   79|       |  // xi-direction flux differences
   80|       |  //---------------------------------------------------------------------
   81|    253|#pragma dvm region
   82|    253|{
   83|    253|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) shadow_renew(u, rho_i, qs) private(k, m, u21im1, q, j, u21i, u31i, u41i, u51i, tmp, i, u31im1, u41im1, u51im1, u21)
   84|  15.9k|  for (k = 1; k < nz - 1; k++) {
   85|   988k|    for (j = jst; j < jend; j++) {
   86|  61.2M|      for (i = ist; i < iend; i++) {
   87|  60.2M|        double fluxPrivate[3][5];
   88|  60.2M|        int fluxI;
   89|   241M|        for (fluxI = 0; fluxI < 3; ++fluxI) {
   90|   180M|          fluxPrivate[fluxI][0] = u[k][j][i-1+fluxI][1];
   91|   180M|          u21 = u[k][j][i-1+fluxI][1] * rho_i[k][j][i-1+fluxI];
   92|       |
   93|   180M|          q = qs[k][j][i-1+fluxI];
   94|       |
   95|   180M|          fluxPrivate[fluxI][1] = u[k][j][i-1+fluxI][1] * u21 + C2 * ( u[k][j][i-1+fluxI][4] - q );
   96|   180M|          fluxPrivate[fluxI][2] = u[k][j][i-1+fluxI][2] * u21;
   97|   180M|          fluxPrivate[fluxI][3] = u[k][j][i-1+fluxI][3] * u21;
   98|   180M|          fluxPrivate[fluxI][4] = ( C1 * u[k][j][i-1+fluxI][4] - C2 * q ) * u21;
   99|   180M|        }
  100|       |
  101|   361M|        for (m = 0; m < 5; m++) {
  102|   301M|          rsd[k][j][i][m] =  rsd[k][j][i][m]
  103|   301M|            - tx2 * ( fluxPrivate[2][m] - fluxPrivate[0][m] );
  104|   301M|        }
  105|       |
  106|   180M|        for (fluxI = 1; fluxI < 3; ++fluxI) {
  107|   120M|          tmp = rho_i[k][j][i-1+fluxI];
  108|       |
  109|   120M|          u21i = tmp * u[k][j][i-1+fluxI][1];
  110|   120M|          u31i = tmp * u[k][j][i-1+fluxI][2];
  111|   120M|          u41i = tmp * u[k][j][i-1+fluxI][3];
  112|   120M|          u51i = tmp * u[k][j][i-1+fluxI][4];
  113|       |
  114|   120M|          tmp = rho_i[k][j][i-2+fluxI];
  115|       |
  116|   120M|          u21im1 = tmp * u[k][j][i-2+fluxI][1];
  117|   120M|          u31im1 = tmp * u[k][j][i-2+fluxI][2];
  118|   120M|          u41im1 = tmp * u[k][j][i-2+fluxI][3];
  119|   120M|          u51im1 = tmp * u[k][j][i-2+fluxI][4];
  120|       |
  121|   120M|          fluxPrivate[fluxI][1] = (4.0/3.0) * tx3 * (u21i-u21im1);
  122|   120M|          fluxPrivate[fluxI][2] = tx3 * ( u31i - u31im1 );
  123|   120M|          fluxPrivate[fluxI][3] = tx3 * ( u41i - u41im1 );
  124|   120M|          fluxPrivate[fluxI][4] = 0.50 * ( 1.0 - C1*C5 )
  125|   120M|            * tx3 * ( ( u21i*u21i     + u31i*u31i     + u41i*u41i )
  126|   120M|                    - ( u21im1*u21im1 + u31im1*u31im1 + u41im1*u41im1 ) )
  127|   120M|            + (1.0/6.0)
  128|   120M|            * tx3 * ( u21i*u21i - u21im1*u21im1 )
  129|   120M|            + C1 * C5 * tx3 * ( u51i - u51im1 );
  130|   120M|        }
  131|       |
  132|  60.2M|        rsd[k][j][i][0] = rsd[k][j][i][0]
  133|  60.2M|          + dx1 * tx1 * (        u[k][j][i-1][0]
  134|  60.2M|                         - 2.0 * u[k][j][i][0]
  135|  60.2M|                         +       u[k][j][i+1][0] );
  136|  60.2M|        rsd[k][j][i][1] = rsd[k][j][i][1]
  137|  60.2M|          + tx3 * C3 * C4 * ( fluxPrivate[2][1] - fluxPrivate[1][1] )
  138|  60.2M|          + dx2 * tx1 * (        u[k][j][i-1][1]
  139|  60.2M|                         - 2.0 * u[k][j][i][1]
  140|  60.2M|                         +       u[k][j][i+1][1] );
  141|  60.2M|        rsd[k][j][i][2] = rsd[k][j][i][2]
  142|  60.2M|          + tx3 * C3 * C4 * ( fluxPrivate[2][2] - fluxPrivate[1][2] )
  143|  60.2M|          + dx3 * tx1 * (        u[k][j][i-1][2]
  144|  60.2M|                         - 2.0 * u[k][j][i][2]
  145|  60.2M|                         +       u[k][j][i+1][2] );
  146|  60.2M|        rsd[k][j][i][3] = rsd[k][j][i][3]
  147|  60.2M|          + tx3 * C3 * C4 * ( fluxPrivate[2][3] - fluxPrivate[1][3] )
  148|  60.2M|          + dx4 * tx1 * (        u[k][j][i-1][3]
  149|  60.2M|                         - 2.0 * u[k][j][i][3]
  150|  60.2M|                         +       u[k][j][i+1][3] );
  151|  60.2M|        rsd[k][j][i][4] = rsd[k][j][i][4]
  152|  60.2M|          + tx3 * C3 * C4 * ( fluxPrivate[2][4] - fluxPrivate[1][4] )
  153|  60.2M|          + dx5 * tx1 * (        u[k][j][i-1][4]
  154|  60.2M|                         - 2.0 * u[k][j][i][4]
  155|  60.2M|                         +       u[k][j][i+1][4] );
  156|       |
  157|       |      //---------------------------------------------------------------------
  158|       |      // Fourth-order dissipation
  159|       |      //---------------------------------------------------------------------
  160|  60.2M|      if (i == 1)
  161|  5.83M|        for (m = 0; m < 5; m++)
  162|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  163|  4.86M|            - dssp * ( + 5.0 * u[k][j][i][m]
  164|  4.86M|                       - 4.0 * u[k][j][i+1][m]
  165|  4.86M|                       +       u[k][j][i+2][m] );
  166|  59.3M|      else if (i == 2)
  167|  5.83M|        for (m = 0; m < 5; m++)
  168|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  169|  4.86M|            - dssp * ( - 4.0 * u[k][j][i-1][m]
  170|  4.86M|                       + 6.0 * u[k][j][i][m]
  171|  4.86M|                       - 4.0 * u[k][j][i+1][m]
  172|  4.86M|                       +       u[k][j][i+2][m] );
  173|  58.3M|      else if (i == nx-3)
  174|  5.83M|        for (m = 0; m < 5; m++)
  175|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  176|  4.86M|            - dssp * (         u[k][j][i-2][m]
  177|  4.86M|                       - 4.0 * u[k][j][i-1][m]
  178|  4.86M|                       + 6.0 * u[k][j][i][m]
  179|  4.86M|                       - 4.0 * u[k][j][i+1][m] );
  180|  57.3M|      else if (i == nx-2)
  181|  5.83M|        for (m = 0; m < 5; m++)
  182|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  183|  4.86M|            - dssp * (         u[k][j][i-2][m]
  184|  4.86M|                       - 4.0 * u[k][j][i-1][m]
  185|  4.86M|                       + 5.0 * u[k][j][i][m] );
  186|  56.4M|      else
  187|   338M|        for (m = 0; m < 5; m++)
  188|   282M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  189|   282M|            - dssp * (         u[k][j][i-2][m]
  190|   282M|                       - 4.0 * u[k][j][i-1][m]
  191|   282M|                       + 6.0 * u[k][j][i][m]
  192|   282M|                       - 4.0 * u[k][j][i+1][m]
  193|   282M|                       +       u[k][j][i+2][m] );
  194|  60.2M|      }
  195|   972k|    }
  196|  15.6k|  }
  197|    253|}
  198|    253|  if (timeron) timer_stop(t_rhsx);
  199|       |
  200|    253|  if (timeron) timer_start(t_rhsy);
  201|       |  //---------------------------------------------------------------------
  202|       |  // eta-direction flux differences
  203|       |  //---------------------------------------------------------------------
  204|    253|#pragma dvm region
  205|    253|{
  206|    253|#pragma dvm parallel([k][i][j] on dvm_tpl[k][j][i]) private(k, u31jm1, u21jm1, u41jm1, i, u31, u41j, u31j, q, u21j, u51j, j, u51jm1, tmp, m)
  207|  15.9k|  for (k = 1; k < nz - 1; k++) {
  208|   988k|    for (i = ist; i < iend; i++) {
  209|  61.2M|      for (j = jst; j < jend; j++) {
  210|  60.2M|        double fluxPrivate[3][5];
  211|  60.2M|        int fluxI;
  212|   241M|        for (fluxI = 0; fluxI < 3; ++fluxI) {
  213|   180M|          fluxPrivate[fluxI][0] = u[k][j-1+fluxI][i][2];
  214|   180M|          u31 = u[k][j-1+fluxI][i][2] * rho_i[k][j-1+fluxI][i];
  215|       |
  216|   180M|          q = qs[k][j-1+fluxI][i];
  217|       |
  218|   180M|          fluxPrivate[fluxI][1] = u[k][j-1+fluxI][i][1] * u31;
  219|   180M|          fluxPrivate[fluxI][2] = u[k][j-1+fluxI][i][2] * u31 + C2 * (u[k][j-1+fluxI][i][4]-q);
  220|   180M|          fluxPrivate[fluxI][3] = u[k][j-1+fluxI][i][3] * u31;
  221|   180M|          fluxPrivate[fluxI][4] = ( C1 * u[k][j-1+fluxI][i][4] - C2 * q ) * u31;
  222|   180M|        }
  223|       |
  224|   361M|        for (m = 0; m < 5; m++) {
  225|   301M|          rsd[k][j][i][m] =  rsd[k][j][i][m]
  226|   301M|            - ty2 * ( fluxPrivate[2][m] - fluxPrivate[0][m] );
  227|   301M|        }
  228|       |
  229|   180M|        for (fluxI = 1; fluxI < 3; ++fluxI) {
  230|   120M|          tmp = rho_i[k][j-1+fluxI][i];
  231|       |
  232|   120M|          u21j = tmp * u[k][j-1+fluxI][i][1];
  233|   120M|          u31j = tmp * u[k][j-1+fluxI][i][2];
  234|   120M|          u41j = tmp * u[k][j-1+fluxI][i][3];
  235|   120M|          u51j = tmp * u[k][j-1+fluxI][i][4];
  236|       |
  237|   120M|          tmp = rho_i[k][j-2+fluxI][i];
  238|   120M|          u21jm1 = tmp * u[k][j-2+fluxI][i][1];
  239|   120M|          u31jm1 = tmp * u[k][j-2+fluxI][i][2];
  240|   120M|          u41jm1 = tmp * u[k][j-2+fluxI][i][3];
  241|   120M|          u51jm1 = tmp * u[k][j-2+fluxI][i][4];
  242|       |
  243|   120M|          fluxPrivate[fluxI][1] = ty3 * ( u21j - u21jm1 );
  244|   120M|          fluxPrivate[fluxI][2] = (4.0/3.0) * ty3 * (u31j-u31jm1);
  245|   120M|          fluxPrivate[fluxI][3] = ty3 * ( u41j - u41jm1 );
  246|   120M|          fluxPrivate[fluxI][4] = 0.50 * ( 1.0 - C1*C5 )
  247|   120M|            * ty3 * ( ( u21j*u21j     + u31j*u31j     + u41j*u41j )
  248|   120M|                    - ( u21jm1*u21jm1 + u31jm1*u31jm1 + u41jm1*u41jm1 ) )
  249|   120M|            + (1.0/6.0)
  250|   120M|            * ty3 * ( u31j*u31j - u31jm1*u31jm1 )
  251|   120M|            + C1 * C5 * ty3 * ( u51j - u51jm1 );
  252|   120M|        }
  253|       |
  254|  60.2M|        rsd[k][j][i][0] = rsd[k][j][i][0]
  255|  60.2M|          + dy1 * ty1 * (         u[k][j-1][i][0]
  256|  60.2M|                          - 2.0 * u[k][j][i][0]
  257|  60.2M|                          +       u[k][j+1][i][0] );
  258|       |
  259|  60.2M|        rsd[k][j][i][1] = rsd[k][j][i][1]
  260|  60.2M|          + ty3 * C3 * C4 * ( fluxPrivate[2][1] - fluxPrivate[1][1] )
  261|  60.2M|          + dy2 * ty1 * (         u[k][j-1][i][1]
  262|  60.2M|                          - 2.0 * u[k][j][i][1]
  263|  60.2M|                          +       u[k][j+1][i][1] );
  264|       |
  265|  60.2M|        rsd[k][j][i][2] = rsd[k][j][i][2]
  266|  60.2M|          + ty3 * C3 * C4 * ( fluxPrivate[2][2] - fluxPrivate[1][2] )
  267|  60.2M|          + dy3 * ty1 * (         u[k][j-1][i][2]
  268|  60.2M|                          - 2.0 * u[k][j][i][2]
  269|  60.2M|                          +       u[k][j+1][i][2] );
  270|       |
  271|  60.2M|        rsd[k][j][i][3] = rsd[k][j][i][3]
  272|  60.2M|          + ty3 * C3 * C4 * ( fluxPrivate[2][3] - fluxPrivate[1][3] )
  273|  60.2M|          + dy4 * ty1 * (         u[k][j-1][i][3]
  274|  60.2M|                          - 2.0 * u[k][j][i][3]
  275|  60.2M|                          +       u[k][j+1][i][3] );
  276|       |
  277|  60.2M|        rsd[k][j][i][4] = rsd[k][j][i][4]
  278|  60.2M|          + ty3 * C3 * C4 * ( fluxPrivate[2][4] - fluxPrivate[1][4] )
  279|  60.2M|          + dy5 * ty1 * (         u[k][j-1][i][4]
  280|  60.2M|                          - 2.0 * u[k][j][i][4]
  281|  60.2M|                           +       u[k][j+1][i][4] );
  282|       |
  283|       |        //---------------------------------------------------------------------
  284|       |        // fourth-order dissipation
  285|       |        //---------------------------------------------------------------------
  286|  60.2M|        if (j == 1)
  287|  5.83M|          for (m = 0; m < 5; m++)
  288|  4.86M|            rsd[k][j][i][m] = rsd[k][j][i][m]
  289|  4.86M|              - dssp * ( + 5.0 * u[k][j][i][m]
  290|  4.86M|                         - 4.0 * u[k][j+1][i][m]
  291|  4.86M|                       +       u[k][j+2][i][m] );
  292|  59.3M|        else if (j == 2)
  293|  5.83M|          for (m = 0; m < 5; m++)
  294|  4.86M|            rsd[k][j][i][m] = rsd[k][j][i][m]
  295|  4.86M|              - dssp * ( - 4.0 * u[k][j-1][i][m]
  296|  4.86M|                         + 6.0 * u[k][j][i][m]
  297|  4.86M|                         - 4.0 * u[k][j+1][i][m]
  298|  4.86M|                         +       u[k][j+2][i][m] );
  299|  58.3M|        else if (j == ny-3)
  300|  5.83M|          for (m = 0; m < 5; m++)
  301|  4.86M|            rsd[k][j][i][m] = rsd[k][j][i][m]
  302|  4.86M|              - dssp * (         u[k][j-2][i][m]
  303|  4.86M|                         - 4.0 * u[k][j-1][i][m]
  304|  4.86M|                         + 6.0 * u[k][j][i][m]
  305|  4.86M|                         - 4.0 * u[k][j+1][i][m] );
  306|  57.3M|        else if (j == ny-2)
  307|  5.83M|          for (m = 0; m < 5; m++)
  308|  4.86M|            rsd[k][j][i][m] = rsd[k][j][i][m]
  309|  4.86M|              - dssp * (         u[k][j-2][i][m]
  310|  4.86M|                         - 4.0 * u[k][j-1][i][m]
  311|  4.86M|                         + 5.0 * u[k][j][i][m] );
  312|  56.4M|        else
  313|   338M|          for (m = 0; m < 5; m++)
  314|   282M|            rsd[k][j][i][m] = rsd[k][j][i][m]
  315|   282M|              - dssp * (         u[k][j-2][i][m]
  316|   282M|                         - 4.0 * u[k][j-1][i][m]
  317|   282M|                         + 6.0 * u[k][j][i][m]
  318|   282M|                         - 4.0 * u[k][j+1][i][m]
  319|   282M|                         +       u[k][j+2][i][m] );
  320|  60.2M|      }
  321|   972k|    }
  322|  15.6k|  }
  323|    253|}
  324|    253|  if (timeron) timer_stop(t_rhsy);
  325|       |
  326|    253|  if (timeron) timer_start(t_rhsz);
  327|       |  //---------------------------------------------------------------------
  328|       |  // zeta-direction flux differences
  329|       |  //---------------------------------------------------------------------
  330|    253|#pragma dvm region
  331|    253|{
  332|    253|#pragma dvm parallel([j][i][k] on dvm_tpl[k][j][i]) private(j, u41km1, q, u41k, u31k, u21k, u41, u51k, u31km1, m, i, k, u21km1, tmp, u51km1)
  333|  15.9k|  for (j = jst; j < jend; j++) {
  334|   988k|    for (i = ist; i < iend; i++) {
  335|  61.2M|      for (k = 1; k < nz - 1; k++) {
  336|  60.2M|        double fluxPrivate[3][5];
  337|  60.2M|        int fluxI;
  338|   241M|        for (fluxI = 0; fluxI < 3; ++fluxI) {
  339|   180M|          fluxPrivate[fluxI][0] = u[k-1+fluxI][j][i][3];
  340|   180M|          u41 = u[k-1+fluxI][j][i][3] * rho_i[k-1+fluxI][j][i];
  341|       |
  342|   180M|          q = qs[k-1+fluxI][j][i];
  343|       |
  344|   180M|          fluxPrivate[fluxI][1] = u[k-1+fluxI][j][i][1] * u41;
  345|   180M|          fluxPrivate[fluxI][2] = u[k-1+fluxI][j][i][2] * u41;
  346|   180M|          fluxPrivate[fluxI][3] = u[k-1+fluxI][j][i][3] * u41 + C2 * (u[k-1+fluxI][j][i][4]-q);
  347|   180M|          fluxPrivate[fluxI][4] = ( C1 * u[k-1+fluxI][j][i][4] - C2 * q ) * u41;
  348|   180M|        }
  349|   361M|        for (m = 0; m < 5; m++) {
  350|   301M|          rsd[k][j][i][m] =  rsd[k][j][i][m]
  351|   301M|            - tz2 * ( fluxPrivate[2][m] - fluxPrivate[0][m] );
  352|   301M|        }
  353|       |
  354|   180M|        for (fluxI = 1; fluxI < 3; ++fluxI) {
  355|   120M|          tmp = rho_i[k-1+fluxI][j][i];
  356|       |
  357|   120M|          u21k = tmp * u[k-1+fluxI][j][i][1];
  358|   120M|          u31k = tmp * u[k-1+fluxI][j][i][2];
  359|   120M|          u41k = tmp * u[k-1+fluxI][j][i][3];
  360|   120M|          u51k = tmp * u[k-1+fluxI][j][i][4];
  361|       |
  362|   120M|          tmp = rho_i[k-2+fluxI][j][i];
  363|       |
  364|   120M|          u21km1 = tmp * u[k-2+fluxI][j][i][1];
  365|   120M|          u31km1 = tmp * u[k-2+fluxI][j][i][2];
  366|   120M|          u41km1 = tmp * u[k-2+fluxI][j][i][3];
  367|   120M|          u51km1 = tmp * u[k-2+fluxI][j][i][4];
  368|       |
  369|   120M|          fluxPrivate[fluxI][1] = tz3 * ( u21k - u21km1 );
  370|   120M|          fluxPrivate[fluxI][2] = tz3 * ( u31k - u31km1 );
  371|   120M|          fluxPrivate[fluxI][3] = (4.0/3.0) * tz3 * (u41k-u41km1);
  372|   120M|          fluxPrivate[fluxI][4] = 0.50 * ( 1.0 - C1*C5 )
  373|   120M|            * tz3 * ( ( u21k*u21k     + u31k*u31k     + u41k*u41k )
  374|   120M|                    - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) )
  375|   120M|            + (1.0/6.0)
  376|   120M|            * tz3 * ( u41k*u41k - u41km1*u41km1 )
  377|   120M|            + C1 * C5 * tz3 * ( u51k - u51km1 );
  378|   120M|        }
  379|       |
  380|  60.2M|        rsd[k][j][i][0] = rsd[k][j][i][0]
  381|  60.2M|          + dz1 * tz1 * (         u[k-1][j][i][0]
  382|  60.2M|                          - 2.0 * u[k][j][i][0]
  383|  60.2M|                          +       u[k+1][j][i][0] );
  384|  60.2M|        rsd[k][j][i][1] = rsd[k][j][i][1]
  385|  60.2M|          + tz3 * C3 * C4 * ( fluxPrivate[2][1] - fluxPrivate[1][1] )
  386|  60.2M|          + dz2 * tz1 * (         u[k-1][j][i][1]
  387|  60.2M|                          - 2.0 * u[k][j][i][1]
  388|  60.2M|                          +       u[k+1][j][i][1] );
  389|  60.2M|        rsd[k][j][i][2] = rsd[k][j][i][2]
  390|  60.2M|          + tz3 * C3 * C4 * ( fluxPrivate[2][2] - fluxPrivate[1][2] )
  391|  60.2M|          + dz3 * tz1 * (         u[k-1][j][i][2]
  392|  60.2M|                          - 2.0 * u[k][j][i][2]
  393|  60.2M|                          +       u[k+1][j][i][2] );
  394|  60.2M|        rsd[k][j][i][3] = rsd[k][j][i][3]
  395|  60.2M|          + tz3 * C3 * C4 * ( fluxPrivate[2][3] - fluxPrivate[1][3] )
  396|  60.2M|          + dz4 * tz1 * (         u[k-1][j][i][3]
  397|  60.2M|                          - 2.0 * u[k][j][i][3]
  398|  60.2M|                          +       u[k+1][j][i][3] );
  399|  60.2M|        rsd[k][j][i][4] = rsd[k][j][i][4]
  400|  60.2M|          + tz3 * C3 * C4 * ( fluxPrivate[2][4] - fluxPrivate[1][4] )
  401|  60.2M|          + dz5 * tz1 * (         u[k-1][j][i][4]
  402|  60.2M|                          - 2.0 * u[k][j][i][4]
  403|  60.2M|                          +       u[k+1][j][i][4] );
  404|       |
  405|       |      //---------------------------------------------------------------------
  406|       |      // fourth-order dissipation
  407|       |      //---------------------------------------------------------------------
  408|  60.2M|      if (k == 1)
  409|  5.83M|        for (m = 0; m < 5; m++)
  410|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  411|  4.86M|            - dssp * ( + 5.0 * u[k][j][i][m]
  412|  4.86M|                     - 4.0 * u[k+1][j][i][m]
  413|  4.86M|                     +       u[k+2][j][i][m] );
  414|  59.3M|      else if (k == 2)
  415|  5.83M|        for (m = 0; m < 5; m++)
  416|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  417|  4.86M|            - dssp * ( - 4.0 * u[k-1][j][i][m]
  418|  4.86M|                       + 6.0 * u[k][j][i][m]
  419|  4.86M|                       - 4.0 * u[k+1][j][i][m]
  420|  4.86M|                       +       u[k+2][j][i][m] );
  421|  58.3M|      else if (k == nz-3)
  422|  5.83M|        for (m = 0; m < 5; m++)
  423|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  424|  4.86M|            - dssp * (         u[k-2][j][i][m]
  425|  4.86M|                       - 4.0 * u[k-1][j][i][m]
  426|  4.86M|                       + 6.0 * u[k][j][i][m]
  427|  4.86M|                       - 4.0 * u[k+1][j][i][m] );
  428|  57.3M|      else if (k == nz-2)
  429|  5.83M|        for (m = 0; m < 5; m++)
  430|  4.86M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  431|  4.86M|            - dssp * (         u[k-2][j][i][m]
  432|  4.86M|                       - 4.0 * u[k-1][j][i][m]
  433|  4.86M|                       + 5.0 * u[k][j][i][m] );
  434|  56.4M|      else
  435|   338M|        for (m = 0; m < 5; m++)
  436|   282M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  437|   282M|            - dssp * (         u[k-2][j][i][m]
  438|   282M|                       - 4.0 * u[k-1][j][i][m]
  439|   282M|                       + 6.0 * u[k][j][i][m]
  440|   282M|                       - 4.0 * u[k+1][j][i][m]
  441|   282M|                       +       u[k+2][j][i][m] );
  442|  60.2M|      }
  443|   972k|    }
  444|  15.6k|  }
  445|    253|}
  446|    253|  if (timeron) timer_stop(t_rhsz);
  447|    253|  if (timeron) timer_stop(t_rhs);
  448|    253|#pragma dvm endinterval
  449|    253|}
  450|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/setbv.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// set the boundary values of dependent variables
   38|       |//---------------------------------------------------------------------
   39|       |void setbv()
   40|      2|{
   41|       |  //---------------------------------------------------------------------
   42|       |  // local variables
   43|       |  //---------------------------------------------------------------------
   44|      2|  int i, j, k, m;
   45|      2|  double temp1[5], temp2[5];
   46|       |
   47|       |  //---------------------------------------------------------------------
   48|       |  // set the dependent variable values along the top and bottom faces
   49|       |  //---------------------------------------------------------------------
   50|      2|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, temp1, temp2)
   51|      4|  for (k = 0; k < 1; k++) { 
   52|    130|    for (j = 0; j < ny; j++) {
   53|  8.32k|      for (i = 0; i < nx; i++) {
   54|  8.19k|        exact( i, j, k, temp1 );
   55|  49.1k|        for (m = 0; m < 5; m++) {
   56|  40.9k|          u[k][j][i][m] = temp1[m];
   57|  40.9k|        }
   58|  8.19k|      }
   59|    128|    }
   60|      2|  }
   61|      2|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, temp1, temp2)
   62|      4|  for (k = nz-1; k < nz; k++) {
   63|    130|    for (j = 0; j < ny; j++) {
   64|  8.32k|      for (i = 0; i < nx; i++) {
   65|  8.19k|        exact( i, j, k, temp2 );
   66|  49.1k|        for (m = 0; m < 5; m++) {
   67|  40.9k|          u[k][j][i][m] = temp2[m];
   68|  40.9k|        }
   69|  8.19k|      }
   70|    128|    }
   71|      2|  }
   72|       |
   73|       |  //---------------------------------------------------------------------
   74|       |  // set the dependent variable values along north and south faces
   75|       |  //---------------------------------------------------------------------
   76|      2|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, temp1, temp2)
   77|    130|  for (k = 0; k < nz; k++) {
   78|    256|    for (j = 0; j < 1; j++) {
   79|  8.32k|      for (i = 0; i < nx; i++) {
   80|  8.19k|        exact( i, j, k, temp1 );
   81|  49.1k|        for (m = 0; m < 5; m++) {
   82|  40.9k|          u[k][j][i][m] = temp1[m];
   83|  40.9k|        }
   84|  8.19k|      }
   85|    128|    }
   86|    128|  }
   87|      2|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, temp1, temp2)
   88|    130|  for (k = 0; k < nz; k++) {
   89|    256|    for (j = ny-1; j < ny; j++) {
   90|  8.32k|      for (i = 0; i < nx; i++) {
   91|  8.19k|        exact( i, j, k, temp2 );
   92|  49.1k|        for (m = 0; m < 5; m++) {
   93|  40.9k|          u[k][j][i][m] = temp2[m];
   94|  40.9k|        }
   95|  8.19k|      }
   96|    128|    }
   97|    128|  }
   98|       |
   99|       |  //---------------------------------------------------------------------
  100|       |  // set the dependent variable values along east and west faces
  101|       |  //---------------------------------------------------------------------
  102|      2|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, temp1, temp2)
  103|    130|  for (k = 0; k < nz; k++) {
  104|  8.32k|    for (j = 0; j < ny; j++) {
  105|  16.3k|      for (i = 0; i < 1; i++) {
  106|  8.19k|        exact( i, j, k, temp1 );
  107|  49.1k|        for (m = 0; m < 5; m++) {
  108|  40.9k|          u[k][j][i][m] = temp1[m];
  109|  40.9k|        }
  110|  8.19k|      }
  111|  8.19k|    }
  112|    128|  }
  113|      2|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m, temp1, temp2)
  114|    130|  for (k = 0; k < nz; k++) {
  115|  8.32k|    for (j = 0; j < ny; j++) {
  116|  16.3k|      for (i = nx-1; i < nx; i++) {
  117|  8.19k|        exact( i, j, k, temp2 );
  118|  49.1k|        for (m = 0; m < 5; m++) {
  119|  40.9k|          u[k][j][i][m] = temp2[m];
  120|  40.9k|        }
  121|  8.19k|      }
  122|  8.19k|    }
  123|    128|  }
  124|      2|}
  125|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/setcoeff.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |void setcoeff()
   37|      1|{
   38|       |  //---------------------------------------------------------------------
   39|       |  // local variables
   40|       |  //---------------------------------------------------------------------
   41|       |
   42|       |  //---------------------------------------------------------------------
   43|       |  // set up coefficients
   44|       |  //---------------------------------------------------------------------
   45|      1|  dxi = 1.0 / ( nx0 - 1 );
   46|      1|  deta = 1.0 / ( ny0 - 1 );
   47|      1|  dzeta = 1.0 / ( nz0 - 1 );
   48|       |
   49|      1|  tx1 = 1.0 / ( dxi * dxi );
   50|      1|  tx2 = 1.0 / ( 2.0 * dxi );
   51|      1|  tx3 = 1.0 / dxi;
   52|       |
   53|      1|  ty1 = 1.0 / ( deta * deta );
   54|      1|  ty2 = 1.0 / ( 2.0 * deta );
   55|      1|  ty3 = 1.0 / deta;
   56|       |
   57|      1|  tz1 = 1.0 / ( dzeta * dzeta );
   58|      1|  tz2 = 1.0 / ( 2.0 * dzeta );
   59|      1|  tz3 = 1.0 / dzeta;
   60|       |
   61|       |  //---------------------------------------------------------------------
   62|       |  // diffusion coefficients
   63|       |  //---------------------------------------------------------------------
   64|      1|  dx1 = 0.75;
   65|      1|  dx2 = dx1;
   66|      1|  dx3 = dx1;
   67|      1|  dx4 = dx1;
   68|      1|  dx5 = dx1;
   69|       |
   70|      1|  dy1 = 0.75;
   71|      1|  dy2 = dy1;
   72|      1|  dy3 = dy1;
   73|      1|  dy4 = dy1;
   74|      1|  dy5 = dy1;
   75|       |
   76|      1|  dz1 = 1.00;
   77|      1|  dz2 = dz1;
   78|      1|  dz3 = dz1;
   79|      1|  dz4 = dz1;
   80|      1|  dz5 = dz1;
   81|       |
   82|       |  //---------------------------------------------------------------------
   83|       |  // fourth difference dissipation
   84|       |  //---------------------------------------------------------------------
   85|      1|  dssp = ( max(max(dx1, dy1), dz1) ) / 4.0;
   86|       |
   87|       |  //---------------------------------------------------------------------
   88|       |  // coefficients of the exact solution to the first pde
   89|       |  //---------------------------------------------------------------------
   90|      1|  ce[0][0] = 2.0;
   91|      1|  ce[0][1] = 0.0;
   92|      1|  ce[0][2] = 0.0;
   93|      1|  ce[0][3] = 4.0;
   94|      1|  ce[0][4] = 5.0;
   95|      1|  ce[0][5] = 3.0;
   96|      1|  ce[0][6] = 5.0e-01;
   97|      1|  ce[0][7] = 2.0e-02;
   98|      1|  ce[0][8] = 1.0e-02;
   99|      1|  ce[0][9] = 3.0e-02;
  100|      1|  ce[0][10] = 5.0e-01;
  101|      1|  ce[0][11] = 4.0e-01;
  102|      1|  ce[0][12] = 3.0e-01;
  103|       |
  104|       |  //---------------------------------------------------------------------
  105|       |  // coefficients of the exact solution to the second pde
  106|       |  //---------------------------------------------------------------------
  107|      1|  ce[1][0] = 1.0;
  108|      1|  ce[1][1] = 0.0;
  109|      1|  ce[1][2] = 0.0;
  110|      1|  ce[1][3] = 0.0;
  111|      1|  ce[1][4] = 1.0;
  112|      1|  ce[1][5] = 2.0;
  113|      1|  ce[1][6] = 3.0;
  114|      1|  ce[1][7] = 1.0e-02;
  115|      1|  ce[1][8] = 3.0e-02;
  116|      1|  ce[1][9] = 2.0e-02;
  117|      1|  ce[1][10] = 4.0e-01;
  118|      1|  ce[1][11] = 3.0e-01;
  119|      1|  ce[1][12] = 5.0e-01;
  120|       |
  121|       |  //---------------------------------------------------------------------
  122|       |  // coefficients of the exact solution to the third pde
  123|       |  //---------------------------------------------------------------------
  124|      1|  ce[2][0] = 2.0;
  125|      1|  ce[2][1] = 2.0;
  126|      1|  ce[2][2] = 0.0;
  127|      1|  ce[2][3] = 0.0;
  128|      1|  ce[2][4] = 0.0;
  129|      1|  ce[2][5] = 2.0;
  130|      1|  ce[2][6] = 3.0;
  131|      1|  ce[2][7] = 4.0e-02;
  132|      1|  ce[2][8] = 3.0e-02;
  133|      1|  ce[2][9] = 5.0e-02;
  134|      1|  ce[2][10] = 3.0e-01;
  135|      1|  ce[2][11] = 5.0e-01;
  136|      1|  ce[2][12] = 4.0e-01;
  137|       |
  138|       |  //---------------------------------------------------------------------
  139|       |  // coefficients of the exact solution to the fourth pde
  140|       |  //---------------------------------------------------------------------
  141|      1|  ce[3][0] = 2.0;
  142|      1|  ce[3][1] = 2.0;
  143|      1|  ce[3][2] = 0.0;
  144|      1|  ce[3][3] = 0.0;
  145|      1|  ce[3][4] = 0.0;
  146|      1|  ce[3][5] = 2.0;
  147|      1|  ce[3][6] = 3.0;
  148|      1|  ce[3][7] = 3.0e-02;
  149|      1|  ce[3][8] = 5.0e-02;
  150|      1|  ce[3][9] = 4.0e-02;
  151|      1|  ce[3][10] = 2.0e-01;
  152|      1|  ce[3][11] = 1.0e-01;
  153|      1|  ce[3][12] = 3.0e-01;
  154|       |
  155|       |  //---------------------------------------------------------------------
  156|       |  // coefficients of the exact solution to the fifth pde
  157|       |  //---------------------------------------------------------------------
  158|      1|  ce[4][0] = 5.0;
  159|      1|  ce[4][1] = 4.0;
  160|      1|  ce[4][2] = 3.0;
  161|      1|  ce[4][3] = 2.0;
  162|      1|  ce[4][4] = 1.0e-01;
  163|      1|  ce[4][5] = 4.0e-01;
  164|      1|  ce[4][6] = 3.0e-01;
  165|      1|  ce[4][7] = 5.0e-02;
  166|      1|  ce[4][8] = 4.0e-02;
  167|      1|  ce[4][9] = 3.0e-02;
  168|      1|  ce[4][10] = 1.0e-01;
  169|      1|  ce[4][11] = 3.0e-01;
  170|      1|  ce[4][12] = 2.0e-01;
  171|      1|}

/home/dvmuser3/andrey/npb-3.3-c/LU/setiv.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |//
   38|       |// set the initial values of independent variables based on tri-linear
   39|       |// interpolation of boundary values in the computational space.
   40|       |//
   41|       |//---------------------------------------------------------------------
   42|       |void setiv()
   43|      2|{
   44|       |  //---------------------------------------------------------------------
   45|       |  // local variables
   46|       |  //---------------------------------------------------------------------
   47|      2|  int i, j, k, m;
   48|      2|  double xi, eta, zeta;
   49|      2|  double pxi, peta, pzeta;
   50|      2|  double ue_1jk[5], ue_nx0jk[5], ue_i1k[5];
   51|      2|  double ue_iny0k[5], ue_ij1[5], ue_ijnz[5];
   52|       |
   53|      2|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i])  \
   54|      2|            private(m, k, i, eta, pzeta, j, xi, pxi, zeta, peta, j, xi, i, zeta, m, ue_1jk, ue_i1k, ue_nx0jk, ue_ij1, ue_iny0k, ue_ijnz)
   55|    126|  for (k = 1; k < nz - 1; k++) {
   56|  7.81k|    for (j = 1; j < ny - 1; j++) {
   57|   484k|      for (i = 1; i < nx - 1; i++) {
   58|   476k|        zeta = ( (double)k ) / (nz-1);
   59|   476k|        eta = ( (double)j ) / (ny0-1);
   60|   476k|        xi = ( (double)i ) / (nx0-1);
   61|   476k|        exact(0, j, k, ue_1jk);
   62|   476k|        exact(nx0-1, j, k, ue_nx0jk);
   63|   476k|        exact(i, 0, k, ue_i1k);
   64|   476k|        exact(i, ny0-1, k, ue_iny0k);
   65|   476k|        exact(i, j, 0, ue_ij1);
   66|   476k|        exact(i, j, nz-1, ue_ijnz);
   67|       |
   68|  2.85M|        for (m = 0; m < 5; m++) {
   69|  2.38M|          pxi =   ( 1.0 - xi ) * ue_1jk[m]
   70|  2.38M|                        + xi   * ue_nx0jk[m];
   71|  2.38M|          peta =  ( 1.0 - eta ) * ue_i1k[m]
   72|  2.38M|                        + eta   * ue_iny0k[m];
   73|  2.38M|          pzeta = ( 1.0 - zeta ) * ue_ij1[m]
   74|  2.38M|                        + zeta   * ue_ijnz[m];
   75|       |
   76|  2.38M|          u[k][j][i][m] = pxi + peta + pzeta
   77|  2.38M|            - pxi * peta - peta * pzeta - pzeta * pxi
   78|  2.38M|            + pxi * peta * pzeta;
   79|  2.38M|        }
   80|   476k|      }
   81|  7.68k|    }
   82|    124|  }
   83|      2|}
   84|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/ssor.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include "applu.incl"
   36|       |#include "timers.h"
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |// to perform pseudo-time stepping SSOR iterations
   40|       |// for five nonlinear pde's.
   41|       |//---------------------------------------------------------------------
   42|      2|void ssor(int niter) {
   43|       |  //---------------------------------------------------------------------
   44|       |  // local variables
   45|       |  //---------------------------------------------------------------------
   46|      2|  int i, j, k, m, n;
   47|      2|  int istep;
   48|      2|  double tmp, tv[ISIZ2][ISIZ1][5];
   49|      2|  double delunm[5];
   50|       |
   51|       |
   52|       |  //---------------------------------------------------------------------
   53|       |  // begin pseudo-time stepping iterations
   54|       |  //---------------------------------------------------------------------
   55|      2|  tmp = 1.0 / (omega * (2.0 - omega));
   56|       |
   57|     24|  for (i = 1; i <= t_last; i++) {
   58|     22|    timer_clear(i);
   59|     22|  }
   60|       |
   61|      2|#pragma dvm actual(u, frct)
   62|       |
   63|       |  //---------------------------------------------------------------------
   64|       |  // compute the steady-state residuals
   65|       |  //---------------------------------------------------------------------
   66|      2|  rhs();
   67|       |
   68|       |  //---------------------------------------------------------------------
   69|       |  // compute the L2 norms of newton iteration residuals
   70|       |  //---------------------------------------------------------------------
   71|      2|  l2norm(ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0, ist, iend, jst, jend, rsd, rsdnm);
   72|       |
   73|       |  /*
   74|       |  if ( ipr == 1 ) {
   75|       |    printf("           Initial residual norms\n");
   76|       |    printf("\n");
   77|       |    printf(" \n RMS-norm of steady-state residual for "
   78|       |           "first pde  = %12.5E\n"
   79|       |           " RMS-norm of steady-state residual for "
   80|       |           "second pde = %12.5E\n"
   81|       |           " RMS-norm of steady-state residual for "
   82|       |           "third pde  = %12.5E\n"
   83|       |           " RMS-norm of steady-state residual for "
   84|       |           "fourth pde = %12.5E\n"
   85|       |           " RMS-norm of steady-state residual for "
   86|       |           "fifth pde  = %12.5E\n",
   87|       |           rsdnm[0], rsdnm[1], rsdnm[2], rsdnm[3], rsdnm[4]);
   88|       |    printf("\nIteration RMS-residual of 5th PDE\n");
   89|       |  }
   90|       |  */
   91|       |
   92|     24|  for (i = 1; i <= t_last; i++) {
   93|     22|    timer_clear(i);
   94|     22|  }
   95|      2|  timer_start(1);
   96|       |
   97|      2|#pragma dvm interval
   98|       |  //---------------------------------------------------------------------
   99|       |  // the timestep loop
  100|       |  //---------------------------------------------------------------------
  101|    253|  for (istep = 1; istep <= niter; istep++) {
  102|       |
  103|       |    // if ( ( (istep % inorm) == 0 ) && ipr == 1 ) {
  104|       |    //  printf(" \n     pseudo-time SSOR iteration no.=%4d\n\n", istep);
  105|       |    //}
  106|    251|    if ((istep % 20) == 0 || istep == itmax || istep == 1) {
  107|     15|      if (niter > 1)
  108|     14|        printf(" Time step %4d\n", istep);
  109|     15|    }
  110|       |
  111|       |    //---------------------------------------------------------------------
  112|       |    // perform SSOR iteration
  113|       |    //---------------------------------------------------------------------
  114|    251|    if (timeron)
  115|      0|      timer_start(t_rhs);
  116|    251|#pragma dvm region
  117|    251|{
  118|    251|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(m)
  119|  15.8k|    for (k = 1; k < nz - 1; k++) {
  120|   980k|      for (j = jst; j < jend; j++) {
  121|  60.7M|        for (i = ist; i < iend; i++) {
  122|   358M|          for (m = 0; m < 5; m++) {
  123|   299M|            rsd[k][j][i][m] = dt * rsd[k][j][i][m];
  124|   299M|          }
  125|  59.8M|        }
  126|   964k|      }
  127|  15.5k|    }
  128|    251|}
  129|    251|    if (timeron)
  130|      0|      timer_stop(t_rhs);
  131|    251|#pragma dvm region
  132|    251|{
  133|    251|#pragma dvm parallel([k][j][i] on rsd[k][j][i][]) across(rsd[1:0][1:0][1:0][0]) private(k, j, i)
  134|       |// We have already made shadow_renew in rhs():
  135|       |//  shadow_renew(u[1:0][1:0][1:0][0], rho_i[1:0][1:0][1:0], qs[1:0][1:0][1:0]).
  136|  15.8k|    for (k = 1; k < nz - 1; k++) {
  137|       |      //---------------------------------------------------------------------
  138|       |      // form the lower triangular part of the jacobian matrix
  139|       |      //---------------------------------------------------------------------
  140|       |      /* jacld(k) is inlined below */
  141|   980k|      for (j = jst; j < jend; j++) {
  142|  60.7M|        for (i = ist; i < iend; i++) {
  143|  59.8M|          int k1 = k;
  144|       |
  145|  59.8M|          double r43;
  146|  59.8M|          double c1345;
  147|  59.8M|          double c34;
  148|  59.8M|          double tmp1, tmp2, tmp3;
  149|       |
  150|  59.8M|          int ldmx0 = ISIZ1;
  151|  59.8M|          int ldmy0 = ISIZ2;
  152|  59.8M|          int ldmz0 = ISIZ3;
  153|  59.8M|          int nx1 = nx;
  154|  59.8M|          int ny1 = ny;
  155|  59.8M|          int nz1 = nz;
  156|  59.8M|          int k0 = k;
  157|  59.8M|          double omega0 = omega;
  158|  59.8M|          int nx00 = nx0;
  159|  59.8M|          int ny00 = ny0;
  160|       |
  161|  59.8M|          int m;
  162|  59.8M|          double tmp;
  163|  59.8M|          double tmat[5][5], tv[5];
  164|       |
  165|  59.8M|          double a_private[5][5];
  166|  59.8M|          double b_private[5][5];
  167|  59.8M|          double c_private[5][5];
  168|  59.8M|          double d_private[5][5];
  169|       |
  170|  59.8M|          r43 = (4.0 / 3.0);
  171|  59.8M|          c1345 = C1 * C3 * C4 * C5;
  172|  59.8M|          c34 = C3 * C4;
  173|       |
  174|       |          //---------------------------------------------------------------------
  175|       |          // form the block daigonal
  176|       |          //---------------------------------------------------------------------
  177|  59.8M|          tmp1 = rho_i[k1][j][i];
  178|  59.8M|          tmp2 = tmp1 * tmp1;
  179|  59.8M|          tmp3 = tmp1 * tmp2;
  180|       |
  181|  59.8M|          d_private[0][0] =
  182|  59.8M|              1.0 + dt * 2.0 * (tx1 * dx1 + ty1 * dy1 + tz1 * dz1);
  183|  59.8M|          d_private[1][0] = 0.0;
  184|  59.8M|          d_private[2][0] = 0.0;
  185|  59.8M|          d_private[3][0] = 0.0;
  186|  59.8M|          d_private[4][0] = 0.0;
  187|       |
  188|  59.8M|          d_private[0][1] =
  189|  59.8M|              -dt * 2.0 * (tx1 * r43 + ty1 + tz1) * c34 * tmp2 * u[k1][j][i][1];
  190|  59.8M|          d_private[1][1] = 1.0 +
  191|  59.8M|                            dt * 2.0 * c34 * tmp1 * (tx1 * r43 + ty1 + tz1) +
  192|  59.8M|                            dt * 2.0 * (tx1 * dx2 + ty1 * dy2 + tz1 * dz2);
  193|  59.8M|          d_private[2][1] = 0.0;
  194|  59.8M|          d_private[3][1] = 0.0;
  195|  59.8M|          d_private[4][1] = 0.0;
  196|  59.8M|          d_private[0][2] =
  197|  59.8M|              -dt * 2.0 * (tx1 + ty1 * r43 + tz1) * c34 * tmp2 * u[k1][j][i][2];
  198|  59.8M|          d_private[1][2] = 0.0;
  199|  59.8M|          d_private[2][2] = 1.0 +
  200|  59.8M|                            dt * 2.0 * c34 * tmp1 * (tx1 + ty1 * r43 + tz1) +
  201|  59.8M|                            dt * 2.0 * (tx1 * dx3 + ty1 * dy3 + tz1 * dz3);
  202|  59.8M|          d_private[3][2] = 0.0;
  203|  59.8M|          d_private[4][2] = 0.0;
  204|       |
  205|  59.8M|          d_private[0][3] =
  206|  59.8M|              -dt * 2.0 * (tx1 + ty1 + tz1 * r43) * c34 * tmp2 * u[k1][j][i][3];
  207|  59.8M|          d_private[1][3] = 0.0;
  208|  59.8M|          d_private[2][3] = 0.0;
  209|  59.8M|          d_private[3][3] = 1.0 +
  210|  59.8M|                            dt * 2.0 * c34 * tmp1 * (tx1 + ty1 + tz1 * r43) +
  211|  59.8M|                            dt * 2.0 * (tx1 * dx4 + ty1 * dy4 + tz1 * dz4);
  212|  59.8M|          d_private[4][3] = 0.0;
  213|       |
  214|  59.8M|          d_private[0][4] =
  215|  59.8M|              -dt * 2.0 * (((tx1 * (r43 * c34 - c1345) + ty1 * (c34 - c1345) +
  216|  59.8M|                             tz1 * (c34 - c1345)) *
  217|  59.8M|                                (u[k1][j][i][1] * u[k1][j][i][1]) +
  218|  59.8M|                            (tx1 * (c34 - c1345) + ty1 * (r43 * c34 - c1345) +
  219|  59.8M|                             tz1 * (c34 - c1345)) *
  220|  59.8M|                                (u[k1][j][i][2] * u[k1][j][i][2]) +
  221|  59.8M|                            (tx1 * (c34 - c1345) + ty1 * (c34 - c1345) +
  222|  59.8M|                             tz1 * (r43 * c34 - c1345)) *
  223|  59.8M|                                (u[k1][j][i][3] * u[k1][j][i][3])) *
  224|  59.8M|                               tmp3 +
  225|  59.8M|                           (tx1 + ty1 + tz1) * c1345 * tmp2 * u[k1][j][i][4]);
  226|       |
  227|  59.8M|          d_private[1][4] = dt * 2.0 * tmp2 * u[k1][j][i][1] *
  228|  59.8M|                            (tx1 * (r43 * c34 - c1345) + ty1 * (c34 - c1345) +
  229|  59.8M|                             tz1 * (c34 - c1345));
  230|  59.8M|          d_private[2][4] = dt * 2.0 * tmp2 * u[k1][j][i][2] *
  231|  59.8M|                            (tx1 * (c34 - c1345) + ty1 * (r43 * c34 - c1345) +
  232|  59.8M|                             tz1 * (c34 - c1345));
  233|  59.8M|          d_private[3][4] = dt * 2.0 * tmp2 * u[k1][j][i][3] *
  234|  59.8M|                            (tx1 * (c34 - c1345) + ty1 * (c34 - c1345) +
  235|  59.8M|                             tz1 * (r43 * c34 - c1345));
  236|  59.8M|          d_private[4][4] = 1.0 + dt * 2.0 * (tx1 + ty1 + tz1) * c1345 * tmp1 +
  237|  59.8M|                            dt * 2.0 * (tx1 * dx5 + ty1 * dy5 + tz1 * dz5);
  238|       |
  239|       |          //---------------------------------------------------------------------
  240|       |          // form the first block sub-diagonal
  241|       |          //---------------------------------------------------------------------
  242|  59.8M|          tmp1 = rho_i[k1 - 1][j][i];
  243|  59.8M|          tmp2 = tmp1 * tmp1;
  244|  59.8M|          tmp3 = tmp1 * tmp2;
  245|       |
  246|  59.8M|          a_private[0][0] = -dt * tz1 * dz1;
  247|  59.8M|          a_private[1][0] = 0.0;
  248|  59.8M|          a_private[2][0] = 0.0;
  249|  59.8M|          a_private[3][0] = -dt * tz2;
  250|  59.8M|          a_private[4][0] = 0.0;
  251|       |
  252|  59.8M|          a_private[0][1] =
  253|  59.8M|              -dt * tz2 * (-(u[k1 - 1][j][i][1] * u[k1 - 1][j][i][3]) * tmp2) -
  254|  59.8M|              dt * tz1 * (-c34 * tmp2 * u[k1 - 1][j][i][1]);
  255|  59.8M|          a_private[1][1] = -dt * tz2 * (u[k1 - 1][j][i][3] * tmp1) -
  256|  59.8M|                            dt * tz1 * c34 * tmp1 - dt * tz1 * dz2;
  257|  59.8M|          a_private[2][1] = 0.0;
  258|  59.8M|          a_private[3][1] = -dt * tz2 * (u[k1 - 1][j][i][1] * tmp1);
  259|  59.8M|          a_private[4][1] = 0.0;
  260|       |
  261|  59.8M|          a_private[0][2] =
  262|  59.8M|              -dt * tz2 * (-(u[k1 - 1][j][i][2] * u[k1 - 1][j][i][3]) * tmp2) -
  263|  59.8M|              dt * tz1 * (-c34 * tmp2 * u[k1 - 1][j][i][2]);
  264|  59.8M|          a_private[1][2] = 0.0;
  265|  59.8M|          a_private[2][2] = -dt * tz2 * (u[k1 - 1][j][i][3] * tmp1) -
  266|  59.8M|                            dt * tz1 * (c34 * tmp1) - dt * tz1 * dz3;
  267|  59.8M|          a_private[3][2] = -dt * tz2 * (u[k1 - 1][j][i][2] * tmp1);
  268|  59.8M|          a_private[4][2] = 0.0;
  269|       |
  270|  59.8M|          a_private[0][3] = -dt * tz2 * (-(u[k1 - 1][j][i][3] * tmp1) *
  271|  59.8M|                                             (u[k1 - 1][j][i][3] * tmp1) +
  272|  59.8M|                                         C2 * qs[k1 - 1][j][i] * tmp1) -
  273|  59.8M|                            dt * tz1 * (-r43 * c34 * tmp2 * u[k1 - 1][j][i][3]);
  274|  59.8M|          a_private[1][3] = -dt * tz2 * (-C2 * (u[k1 - 1][j][i][1] * tmp1));
  275|  59.8M|          a_private[2][3] = -dt * tz2 * (-C2 * (u[k1 - 1][j][i][2] * tmp1));
  276|  59.8M|          a_private[3][3] =
  277|  59.8M|              -dt * tz2 * (2.0 - C2) * (u[k1 - 1][j][i][3] * tmp1) -
  278|  59.8M|              dt * tz1 * (r43 * c34 * tmp1) - dt * tz1 * dz4;
  279|  59.8M|          a_private[4][3] = -dt * tz2 * C2;
  280|       |
  281|  59.8M|          a_private[0][4] =
  282|  59.8M|              -dt * tz2 *
  283|  59.8M|                  ((C2 * 2.0 * qs[k1 - 1][j][i] - C1 * u[k1 - 1][j][i][4]) *
  284|  59.8M|                   u[k1 - 1][j][i][3] * tmp2) -
  285|  59.8M|              dt * tz1 * (-(c34 - c1345) * tmp3 *
  286|  59.8M|                              (u[k1 - 1][j][i][1] * u[k1 - 1][j][i][1]) -
  287|  59.8M|                          (c34 - c1345) * tmp3 *
  288|  59.8M|                              (u[k1 - 1][j][i][2] * u[k1 - 1][j][i][2]) -
  289|  59.8M|                          (r43 * c34 - c1345) * tmp3 *
  290|  59.8M|                              (u[k1 - 1][j][i][3] * u[k1 - 1][j][i][3]) -
  291|  59.8M|                          c1345 * tmp2 * u[k1 - 1][j][i][4]);
  292|  59.8M|          a_private[1][4] =
  293|  59.8M|              -dt * tz2 *
  294|  59.8M|                  (-C2 * (u[k1 - 1][j][i][1] * u[k1 - 1][j][i][3]) * tmp2) -
  295|  59.8M|              dt * tz1 * (c34 - c1345) * tmp2 * u[k1 - 1][j][i][1];
  296|  59.8M|          a_private[2][4] =
  297|  59.8M|              -dt * tz2 *
  298|  59.8M|                  (-C2 * (u[k1 - 1][j][i][2] * u[k1 - 1][j][i][3]) * tmp2) -
  299|  59.8M|              dt * tz1 * (c34 - c1345) * tmp2 * u[k1 - 1][j][i][2];
  300|  59.8M|          a_private[3][4] =
  301|  59.8M|              -dt * tz2 *
  302|  59.8M|                  (C1 * (u[k1 - 1][j][i][4] * tmp1) -
  303|  59.8M|                   C2 * (qs[k1 - 1][j][i] * tmp1 +
  304|  59.8M|                         u[k1 - 1][j][i][3] * u[k1 - 1][j][i][3] * tmp2)) -
  305|  59.8M|              dt * tz1 * (r43 * c34 - c1345) * tmp2 * u[k1 - 1][j][i][3];
  306|  59.8M|          a_private[4][4] = -dt * tz2 * (C1 * (u[k1 - 1][j][i][3] * tmp1)) -
  307|  59.8M|                            dt * tz1 * c1345 * tmp1 - dt * tz1 * dz5;
  308|       |
  309|       |          //---------------------------------------------------------------------
  310|       |          // form the second block sub-diagonal
  311|       |          //---------------------------------------------------------------------
  312|  59.8M|          tmp1 = rho_i[k1][j - 1][i];
  313|  59.8M|          tmp2 = tmp1 * tmp1;
  314|  59.8M|          tmp3 = tmp1 * tmp2;
  315|       |
  316|  59.8M|          b_private[0][0] = -dt * ty1 * dy1;
  317|  59.8M|          b_private[1][0] = 0.0;
  318|  59.8M|          b_private[2][0] = -dt * ty2;
  319|  59.8M|          b_private[3][0] = 0.0;
  320|  59.8M|          b_private[4][0] = 0.0;
  321|       |
  322|  59.8M|          b_private[0][1] =
  323|  59.8M|              -dt * ty2 * (-(u[k1][j - 1][i][1] * u[k1][j - 1][i][2]) * tmp2) -
  324|  59.8M|              dt * ty1 * (-c34 * tmp2 * u[k1][j - 1][i][1]);
  325|  59.8M|          b_private[1][1] = -dt * ty2 * (u[k1][j - 1][i][2] * tmp1) -
  326|  59.8M|                            dt * ty1 * (c34 * tmp1) - dt * ty1 * dy2;
  327|  59.8M|          b_private[2][1] = -dt * ty2 * (u[k1][j - 1][i][1] * tmp1);
  328|  59.8M|          b_private[3][1] = 0.0;
  329|  59.8M|          b_private[4][1] = 0.0;
  330|       |
  331|  59.8M|          b_private[0][2] = -dt * ty2 * (-(u[k1][j - 1][i][2] * tmp1) *
  332|  59.8M|                                             (u[k1][j - 1][i][2] * tmp1) +
  333|  59.8M|                                         C2 * (qs[k1][j - 1][i] * tmp1)) -
  334|  59.8M|                            dt * ty1 * (-r43 * c34 * tmp2 * u[k1][j - 1][i][2]);
  335|  59.8M|          b_private[1][2] = -dt * ty2 * (-C2 * (u[k1][j - 1][i][1] * tmp1));
  336|  59.8M|          b_private[2][2] =
  337|  59.8M|              -dt * ty2 * ((2.0 - C2) * (u[k1][j - 1][i][2] * tmp1)) -
  338|  59.8M|              dt * ty1 * (r43 * c34 * tmp1) - dt * ty1 * dy3;
  339|  59.8M|          b_private[3][2] = -dt * ty2 * (-C2 * (u[k1][j - 1][i][3] * tmp1));
  340|  59.8M|          b_private[4][2] = -dt * ty2 * C2;
  341|       |
  342|  59.8M|          b_private[0][3] =
  343|  59.8M|              -dt * ty2 * (-(u[k1][j - 1][i][2] * u[k1][j - 1][i][3]) * tmp2) -
  344|  59.8M|              dt * ty1 * (-c34 * tmp2 * u[k1][j - 1][i][3]);
  345|  59.8M|          b_private[1][3] = 0.0;
  346|  59.8M|          b_private[2][3] = -dt * ty2 * (u[k1][j - 1][i][3] * tmp1);
  347|  59.8M|          b_private[3][3] = -dt * ty2 * (u[k1][j - 1][i][2] * tmp1) -
  348|  59.8M|                            dt * ty1 * (c34 * tmp1) - dt * ty1 * dy4;
  349|  59.8M|          b_private[4][3] = 0.0;
  350|       |
  351|  59.8M|          b_private[0][4] =
  352|  59.8M|              -dt * ty2 *
  353|  59.8M|                  ((C2 * 2.0 * qs[k1][j - 1][i] - C1 * u[k1][j - 1][i][4]) *
  354|  59.8M|                   (u[k1][j - 1][i][2] * tmp2)) -
  355|  59.8M|              dt * ty1 * (-(c34 - c1345) * tmp3 *
  356|  59.8M|                              (u[k1][j - 1][i][1] * u[k1][j - 1][i][1]) -
  357|  59.8M|                          (r43 * c34 - c1345) * tmp3 *
  358|  59.8M|                              (u[k1][j - 1][i][2] * u[k1][j - 1][i][2]) -
  359|  59.8M|                          (c34 - c1345) * tmp3 *
  360|  59.8M|                              (u[k1][j - 1][i][3] * u[k1][j - 1][i][3]) -
  361|  59.8M|                          c1345 * tmp2 * u[k1][j - 1][i][4]);
  362|  59.8M|          b_private[1][4] =
  363|  59.8M|              -dt * ty2 *
  364|  59.8M|                  (-C2 * (u[k1][j - 1][i][1] * u[k1][j - 1][i][2]) * tmp2) -
  365|  59.8M|              dt * ty1 * (c34 - c1345) * tmp2 * u[k1][j - 1][i][1];
  366|  59.8M|          b_private[2][4] =
  367|  59.8M|              -dt * ty2 *
  368|  59.8M|                  (C1 * (u[k1][j - 1][i][4] * tmp1) -
  369|  59.8M|                   C2 * (qs[k1][j - 1][i] * tmp1 +
  370|  59.8M|                         u[k1][j - 1][i][2] * u[k1][j - 1][i][2] * tmp2)) -
  371|  59.8M|              dt * ty1 * (r43 * c34 - c1345) * tmp2 * u[k1][j - 1][i][2];
  372|  59.8M|          b_private[3][4] =
  373|  59.8M|              -dt * ty2 *
  374|  59.8M|                  (-C2 * (u[k1][j - 1][i][2] * u[k1][j - 1][i][3]) * tmp2) -
  375|  59.8M|              dt * ty1 * (c34 - c1345) * tmp2 * u[k1][j - 1][i][3];
  376|  59.8M|          b_private[4][4] = -dt * ty2 * (C1 * (u[k1][j - 1][i][2] * tmp1)) -
  377|  59.8M|                            dt * ty1 * c1345 * tmp1 - dt * ty1 * dy5;
  378|       |
  379|       |          //---------------------------------------------------------------------
  380|       |          // form the third block sub-diagonal
  381|       |          //---------------------------------------------------------------------
  382|  59.8M|          tmp1 = rho_i[k1][j][i - 1];
  383|  59.8M|          tmp2 = tmp1 * tmp1;
  384|  59.8M|          tmp3 = tmp1 * tmp2;
  385|       |
  386|  59.8M|          c_private[0][0] = -dt * tx1 * dx1;
  387|  59.8M|          c_private[1][0] = -dt * tx2;
  388|  59.8M|          c_private[2][0] = 0.0;
  389|  59.8M|          c_private[3][0] = 0.0;
  390|  59.8M|          c_private[4][0] = 0.0;
  391|       |
  392|  59.8M|          c_private[0][1] = -dt * tx2 * (-(u[k1][j][i - 1][1] * tmp1) *
  393|  59.8M|                                             (u[k1][j][i - 1][1] * tmp1) +
  394|  59.8M|                                         C2 * qs[k1][j][i - 1] * tmp1) -
  395|  59.8M|                            dt * tx1 * (-r43 * c34 * tmp2 * u[k1][j][i - 1][1]);
  396|  59.8M|          c_private[1][1] =
  397|  59.8M|              -dt * tx2 * ((2.0 - C2) * (u[k1][j][i - 1][1] * tmp1)) -
  398|  59.8M|              dt * tx1 * (r43 * c34 * tmp1) - dt * tx1 * dx2;
  399|  59.8M|          c_private[2][1] = -dt * tx2 * (-C2 * (u[k1][j][i - 1][2] * tmp1));
  400|  59.8M|          c_private[3][1] = -dt * tx2 * (-C2 * (u[k1][j][i - 1][3] * tmp1));
  401|  59.8M|          c_private[4][1] = -dt * tx2 * C2;
  402|       |
  403|  59.8M|          c_private[0][2] =
  404|  59.8M|              -dt * tx2 * (-(u[k1][j][i - 1][1] * u[k1][j][i - 1][2]) * tmp2) -
  405|  59.8M|              dt * tx1 * (-c34 * tmp2 * u[k1][j][i - 1][2]);
  406|  59.8M|          c_private[1][2] = -dt * tx2 * (u[k1][j][i - 1][2] * tmp1);
  407|  59.8M|          c_private[2][2] = -dt * tx2 * (u[k1][j][i - 1][1] * tmp1) -
  408|  59.8M|                            dt * tx1 * (c34 * tmp1) - dt * tx1 * dx3;
  409|  59.8M|          c_private[3][2] = 0.0;
  410|  59.8M|          c_private[4][2] = 0.0;
  411|       |
  412|  59.8M|          c_private[0][3] =
  413|  59.8M|              -dt * tx2 * (-(u[k1][j][i - 1][1] * u[k1][j][i - 1][3]) * tmp2) -
  414|  59.8M|              dt * tx1 * (-c34 * tmp2 * u[k1][j][i - 1][3]);
  415|  59.8M|          c_private[1][3] = -dt * tx2 * (u[k1][j][i - 1][3] * tmp1);
  416|  59.8M|          c_private[2][3] = 0.0;
  417|  59.8M|          c_private[3][3] = -dt * tx2 * (u[k1][j][i - 1][1] * tmp1) -
  418|  59.8M|                            dt * tx1 * (c34 * tmp1) - dt * tx1 * dx4;
  419|  59.8M|          c_private[4][3] = 0.0;
  420|       |
  421|  59.8M|          c_private[0][4] =
  422|  59.8M|              -dt * tx2 *
  423|  59.8M|                  ((C2 * 2.0 * qs[k1][j][i - 1] - C1 * u[k1][j][i - 1][4]) *
  424|  59.8M|                   u[k1][j][i - 1][1] * tmp2) -
  425|  59.8M|              dt * tx1 * (-(r43 * c34 - c1345) * tmp3 *
  426|  59.8M|                              (u[k1][j][i - 1][1] * u[k1][j][i - 1][1]) -
  427|  59.8M|                          (c34 - c1345) * tmp3 *
  428|  59.8M|                              (u[k1][j][i - 1][2] * u[k1][j][i - 1][2]) -
  429|  59.8M|                          (c34 - c1345) * tmp3 *
  430|  59.8M|                              (u[k1][j][i - 1][3] * u[k1][j][i - 1][3]) -
  431|  59.8M|                          c1345 * tmp2 * u[k1][j][i - 1][4]);
  432|  59.8M|          c_private[1][4] =
  433|  59.8M|              -dt * tx2 *
  434|  59.8M|                  (C1 * (u[k1][j][i - 1][4] * tmp1) -
  435|  59.8M|                   C2 * (u[k1][j][i - 1][1] * u[k1][j][i - 1][1] * tmp2 +
  436|  59.8M|                         qs[k1][j][i - 1] * tmp1)) -
  437|  59.8M|              dt * tx1 * (r43 * c34 - c1345) * tmp2 * u[k1][j][i - 1][1];
  438|  59.8M|          c_private[2][4] =
  439|  59.8M|              -dt * tx2 *
  440|  59.8M|                  (-C2 * (u[k1][j][i - 1][2] * u[k1][j][i - 1][1]) * tmp2) -
  441|  59.8M|              dt * tx1 * (c34 - c1345) * tmp2 * u[k1][j][i - 1][2];
  442|  59.8M|          c_private[3][4] =
  443|  59.8M|              -dt * tx2 *
  444|  59.8M|                  (-C2 * (u[k1][j][i - 1][3] * u[k1][j][i - 1][1]) * tmp2) -
  445|  59.8M|              dt * tx1 * (c34 - c1345) * tmp2 * u[k1][j][i - 1][3];
  446|  59.8M|          c_private[4][4] = -dt * tx2 * (C1 * (u[k1][j][i - 1][1] * tmp1)) -
  447|  59.8M|                            dt * tx1 * c1345 * tmp1 - dt * tx1 * dx5;
  448|       |
  449|       |          //---------------------------------------------------------------------
  450|       |          // perform the lower triangular solution
  451|       |          //---------------------------------------------------------------------
  452|       |          /* blts( ISIZ1, ISIZ2, ISIZ3,
  453|       |                nx, ny, nz, k,
  454|       |                omega,
  455|       |                rsd,
  456|       |                a, b, c, d,
  457|       |                ist, iend, jst, jend,
  458|       |                nx0, ny0 ) is inlined below */
  459|       |
  460|       |          // Since gcc 4.4.3 generates the following warning for v:
  461|       |          // warning: '({anonymous})' may be used uninitialized in this function
  462|       |          // we use casted pointers.
  463|       |
  464|   358M|          for (m = 0; m < 5; m++) {
  465|   299M|            rsd[k0][j][i][m] =
  466|   299M|                rsd[k0][j][i][m] -
  467|   299M|                omega0 * (a_private[0][m] * rsd[k0 - 1][j][i][0] +
  468|   299M|                          a_private[1][m] * rsd[k0 - 1][j][i][1] +
  469|   299M|                          a_private[2][m] * rsd[k0 - 1][j][i][2] +
  470|   299M|                          a_private[3][m] * rsd[k0 - 1][j][i][3] +
  471|   299M|                          a_private[4][m] * rsd[k0 - 1][j][i][4]);
  472|   299M|          }
  473|       |
  474|   358M|          for (m = 0; m < 5; m++) {
  475|   299M|            tv[m] = rsd[k0][j][i][m] -
  476|   299M|                    omega0 * (b_private[0][m] * rsd[k0][j - 1][i][0] +
  477|   299M|                              c_private[0][m] * rsd[k0][j][i - 1][0] +
  478|   299M|                              b_private[1][m] * rsd[k0][j - 1][i][1] +
  479|   299M|                              c_private[1][m] * rsd[k0][j][i - 1][1] +
  480|   299M|                              b_private[2][m] * rsd[k0][j - 1][i][2] +
  481|   299M|                              c_private[2][m] * rsd[k0][j][i - 1][2] +
  482|   299M|                              b_private[3][m] * rsd[k0][j - 1][i][3] +
  483|   299M|                              c_private[3][m] * rsd[k0][j][i - 1][3] +
  484|   299M|                              b_private[4][m] * rsd[k0][j - 1][i][4] +
  485|   299M|                              c_private[4][m] * rsd[k0][j][i - 1][4]);
  486|   299M|          }
  487|       |
  488|       |          //---------------------------------------------------------------------
  489|       |          // diagonal block inversion
  490|       |          //
  491|       |          // forward elimination
  492|       |          //---------------------------------------------------------------------
  493|   358M|          for (m = 0; m < 5; m++) {
  494|   299M|            tmat[m][0] = d_private[0][m];
  495|   299M|            tmat[m][1] = d_private[1][m];
  496|   299M|            tmat[m][2] = d_private[2][m];
  497|   299M|            tmat[m][3] = d_private[3][m];
  498|   299M|            tmat[m][4] = d_private[4][m];
  499|   299M|          }
  500|       |
  501|  59.8M|          tmp1 = 1.0 / tmat[0][0];
  502|  59.8M|          tmp = tmp1 * tmat[1][0];
  503|  59.8M|          tmat[1][1] = tmat[1][1] - tmp * tmat[0][1];
  504|  59.8M|          tmat[1][2] = tmat[1][2] - tmp * tmat[0][2];
  505|  59.8M|          tmat[1][3] = tmat[1][3] - tmp * tmat[0][3];
  506|  59.8M|          tmat[1][4] = tmat[1][4] - tmp * tmat[0][4];
  507|  59.8M|          tv[1] = tv[1] - tv[0] * tmp;
  508|       |
  509|  59.8M|          tmp = tmp1 * tmat[2][0];
  510|  59.8M|          tmat[2][1] = tmat[2][1] - tmp * tmat[0][1];
  511|  59.8M|          tmat[2][2] = tmat[2][2] - tmp * tmat[0][2];
  512|  59.8M|          tmat[2][3] = tmat[2][3] - tmp * tmat[0][3];
  513|  59.8M|          tmat[2][4] = tmat[2][4] - tmp * tmat[0][4];
  514|  59.8M|          tv[2] = tv[2] - tv[0] * tmp;
  515|       |
  516|  59.8M|          tmp = tmp1 * tmat[3][0];
  517|  59.8M|          tmat[3][1] = tmat[3][1] - tmp * tmat[0][1];
  518|  59.8M|          tmat[3][2] = tmat[3][2] - tmp * tmat[0][2];
  519|  59.8M|          tmat[3][3] = tmat[3][3] - tmp * tmat[0][3];
  520|  59.8M|          tmat[3][4] = tmat[3][4] - tmp * tmat[0][4];
  521|  59.8M|          tv[3] = tv[3] - tv[0] * tmp;
  522|       |
  523|  59.8M|          tmp = tmp1 * tmat[4][0];
  524|  59.8M|          tmat[4][1] = tmat[4][1] - tmp * tmat[0][1];
  525|  59.8M|          tmat[4][2] = tmat[4][2] - tmp * tmat[0][2];
  526|  59.8M|          tmat[4][3] = tmat[4][3] - tmp * tmat[0][3];
  527|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[0][4];
  528|  59.8M|          tv[4] = tv[4] - tv[0] * tmp;
  529|       |
  530|  59.8M|          tmp1 = 1.0 / tmat[1][1];
  531|  59.8M|          tmp = tmp1 * tmat[2][1];
  532|  59.8M|          tmat[2][2] = tmat[2][2] - tmp * tmat[1][2];
  533|  59.8M|          tmat[2][3] = tmat[2][3] - tmp * tmat[1][3];
  534|  59.8M|          tmat[2][4] = tmat[2][4] - tmp * tmat[1][4];
  535|  59.8M|          tv[2] = tv[2] - tv[1] * tmp;
  536|       |
  537|  59.8M|          tmp = tmp1 * tmat[3][1];
  538|  59.8M|          tmat[3][2] = tmat[3][2] - tmp * tmat[1][2];
  539|  59.8M|          tmat[3][3] = tmat[3][3] - tmp * tmat[1][3];
  540|  59.8M|          tmat[3][4] = tmat[3][4] - tmp * tmat[1][4];
  541|  59.8M|          tv[3] = tv[3] - tv[1] * tmp;
  542|       |
  543|  59.8M|          tmp = tmp1 * tmat[4][1];
  544|  59.8M|          tmat[4][2] = tmat[4][2] - tmp * tmat[1][2];
  545|  59.8M|          tmat[4][3] = tmat[4][3] - tmp * tmat[1][3];
  546|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[1][4];
  547|  59.8M|          tv[4] = tv[4] - tv[1] * tmp;
  548|       |
  549|  59.8M|          tmp1 = 1.0 / tmat[2][2];
  550|  59.8M|          tmp = tmp1 * tmat[3][2];
  551|  59.8M|          tmat[3][3] = tmat[3][3] - tmp * tmat[2][3];
  552|  59.8M|          tmat[3][4] = tmat[3][4] - tmp * tmat[2][4];
  553|  59.8M|          tv[3] = tv[3] - tv[2] * tmp;
  554|       |
  555|  59.8M|          tmp = tmp1 * tmat[4][2];
  556|  59.8M|          tmat[4][3] = tmat[4][3] - tmp * tmat[2][3];
  557|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[2][4];
  558|  59.8M|          tv[4] = tv[4] - tv[2] * tmp;
  559|       |
  560|  59.8M|          tmp1 = 1.0 / tmat[3][3];
  561|  59.8M|          tmp = tmp1 * tmat[4][3];
  562|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[3][4];
  563|  59.8M|          tv[4] = tv[4] - tv[3] * tmp;
  564|       |
  565|       |          //---------------------------------------------------------------------
  566|       |          // back substitution
  567|       |          //---------------------------------------------------------------------
  568|  59.8M|          rsd[k0][j][i][4] = tv[4] / tmat[4][4];
  569|       |
  570|  59.8M|          tv[3] = tv[3] - tmat[3][4] * rsd[k0][j][i][4];
  571|  59.8M|          rsd[k0][j][i][3] = tv[3] / tmat[3][3];
  572|       |
  573|  59.8M|          tv[2] = tv[2] - tmat[2][3] * rsd[k0][j][i][3] -
  574|  59.8M|                  tmat[2][4] * rsd[k0][j][i][4];
  575|  59.8M|          rsd[k0][j][i][2] = tv[2] / tmat[2][2];
  576|       |
  577|  59.8M|          tv[1] = tv[1] - tmat[1][2] * rsd[k0][j][i][2] -
  578|  59.8M|                  tmat[1][3] * rsd[k0][j][i][3] - tmat[1][4] * rsd[k0][j][i][4];
  579|  59.8M|          rsd[k0][j][i][1] = tv[1] / tmat[1][1];
  580|       |
  581|  59.8M|          tv[0] = tv[0] - tmat[0][1] * rsd[k0][j][i][1] -
  582|  59.8M|                  tmat[0][2] * rsd[k0][j][i][2] -
  583|  59.8M|                  tmat[0][3] * rsd[k0][j][i][3] - tmat[0][4] * rsd[k0][j][i][4];
  584|  59.8M|          rsd[k0][j][i][0] = tv[0] / tmat[0][0];
  585|  59.8M|        }
  586|   964k|      }
  587|  15.5k|    }
  588|    251|}
  589|    251|#pragma dvm region
  590|    251|{
  591|    251|#pragma dvm parallel([k][j][i] on rsd[k][j][i][]) across(rsd[0:1][0:1][0:1][0]) private(k, j, i)
  592|       |// We have already made shadow_renew in rhs():
  593|       |//  shadow_renew(u[0:1][0:1][0:1][0], rho_i[0:1][0:1][0:1], qs[0:1][0:1][0:1]).
  594|  15.8k|    for (k = nz - 2; k > 0; k--) {
  595|       |      //---------------------------------------------------------------------
  596|       |      // form the strictly upper triangular part of the jacobian matrix
  597|       |      //---------------------------------------------------------------------
  598|       |      /* jacu(k) is inlined below */
  599|   980k|      for (j = jend - 1; j >= jst; j--) {
  600|  60.7M|        for (i = iend - 1; i >= ist; i--) {
  601|  59.8M|          int k2 = k;
  602|       |
  603|  59.8M|          double r43;
  604|  59.8M|          double c1345;
  605|  59.8M|          double c34;
  606|  59.8M|          double tmp1, tmp2, tmp3;
  607|       |
  608|  59.8M|          int ldmx1 = ISIZ1;
  609|  59.8M|          int ldmy1 = ISIZ2;
  610|  59.8M|          int ldmz1 = ISIZ3;
  611|  59.8M|          int nx2 = nx;
  612|  59.8M|          int ny2 = ny;
  613|  59.8M|          int nz2 = nz;
  614|  59.8M|          int k3 = k;
  615|  59.8M|          double omega1 = omega;
  616|  59.8M|          int nx01 = nx0;
  617|  59.8M|          int ny01 = ny0;
  618|  59.8M|          int m;
  619|  59.8M|          double tmp;
  620|  59.8M|          double tmat[5][5];
  621|       |
  622|  59.8M|          double a_private[5][5];
  623|  59.8M|          double b_private[5][5];
  624|  59.8M|          double c_private[5][5];
  625|  59.8M|          double d_private[5][5];
  626|       |
  627|  59.8M|          r43 = (4.0 / 3.0);
  628|  59.8M|          c1345 = C1 * C3 * C4 * C5;
  629|  59.8M|          c34 = C3 * C4;
  630|       |          //---------------------------------------------------------------------
  631|       |          // form the block daigonal
  632|       |          //---------------------------------------------------------------------
  633|  59.8M|          tmp1 = rho_i[k2][j][i];
  634|  59.8M|          tmp2 = tmp1 * tmp1;
  635|  59.8M|          tmp3 = tmp1 * tmp2;
  636|       |
  637|  59.8M|          d_private[0][0] =
  638|  59.8M|              1.0 + dt * 2.0 * (tx1 * dx1 + ty1 * dy1 + tz1 * dz1);
  639|  59.8M|          d_private[1][0] = 0.0;
  640|  59.8M|          d_private[2][0] = 0.0;
  641|  59.8M|          d_private[3][0] = 0.0;
  642|  59.8M|          d_private[4][0] = 0.0;
  643|       |
  644|  59.8M|          d_private[0][1] = dt * 2.0 * (-tx1 * r43 - ty1 - tz1) *
  645|  59.8M|                          (c34 * tmp2 * u[k2][j][i][1]);
  646|  59.8M|          d_private[1][1] = 1.0 +
  647|  59.8M|                          dt * 2.0 * c34 * tmp1 * (tx1 * r43 + ty1 + tz1) +
  648|  59.8M|                          dt * 2.0 * (tx1 * dx2 + ty1 * dy2 + tz1 * dz2);
  649|  59.8M|          d_private[2][1] = 0.0;
  650|  59.8M|          d_private[3][1] = 0.0;
  651|  59.8M|          d_private[4][1] = 0.0;
  652|       |
  653|  59.8M|          d_private[0][2] = dt * 2.0 * (-tx1 - ty1 * r43 - tz1) *
  654|  59.8M|                          (c34 * tmp2 * u[k2][j][i][2]);
  655|  59.8M|          d_private[1][2] = 0.0;
  656|  59.8M|          d_private[2][2] = 1.0 +
  657|  59.8M|                          dt * 2.0 * c34 * tmp1 * (tx1 + ty1 * r43 + tz1) +
  658|  59.8M|                          dt * 2.0 * (tx1 * dx3 + ty1 * dy3 + tz1 * dz3);
  659|  59.8M|          d_private[3][2] = 0.0;
  660|  59.8M|          d_private[4][2] = 0.0;
  661|       |
  662|  59.8M|          d_private[0][3] = dt * 2.0 * (-tx1 - ty1 - tz1 * r43) *
  663|  59.8M|                          (c34 * tmp2 * u[k2][j][i][3]);
  664|  59.8M|          d_private[1][3] = 0.0;
  665|  59.8M|          d_private[2][3] = 0.0;
  666|  59.8M|          d_private[3][3] = 1.0 +
  667|  59.8M|                          dt * 2.0 * c34 * tmp1 * (tx1 + ty1 + tz1 * r43) +
  668|  59.8M|                          dt * 2.0 * (tx1 * dx4 + ty1 * dy4 + tz1 * dz4);
  669|  59.8M|          d_private[4][3] = 0.0;
  670|       |
  671|  59.8M|          d_private[0][4] =
  672|  59.8M|              -dt * 2.0 * (((tx1 * (r43 * c34 - c1345) + ty1 * (c34 - c1345) +
  673|  59.8M|                             tz1 * (c34 - c1345)) *
  674|  59.8M|                                (u[k2][j][i][1] * u[k2][j][i][1]) +
  675|  59.8M|                            (tx1 * (c34 - c1345) + ty1 * (r43 * c34 - c1345) +
  676|  59.8M|                             tz1 * (c34 - c1345)) *
  677|  59.8M|                                (u[k2][j][i][2] * u[k2][j][i][2]) +
  678|  59.8M|                            (tx1 * (c34 - c1345) + ty1 * (c34 - c1345) +
  679|  59.8M|                             tz1 * (r43 * c34 - c1345)) *
  680|  59.8M|                                (u[k2][j][i][3] * u[k2][j][i][3])) *
  681|  59.8M|                               tmp3 +
  682|  59.8M|                           (tx1 + ty1 + tz1) * c1345 * tmp2 * u[k2][j][i][4]);
  683|       |
  684|  59.8M|          d_private[1][4] = dt * 2.0 *
  685|  59.8M|                          (tx1 * (r43 * c34 - c1345) + ty1 * (c34 - c1345) +
  686|  59.8M|                           tz1 * (c34 - c1345)) *
  687|  59.8M|                          tmp2 * u[k2][j][i][1];
  688|  59.8M|          d_private[2][4] = dt * 2.0 *
  689|  59.8M|                          (tx1 * (c34 - c1345) + ty1 * (r43 * c34 - c1345) +
  690|  59.8M|                           tz1 * (c34 - c1345)) *
  691|  59.8M|                          tmp2 * u[k2][j][i][2];
  692|  59.8M|          d_private[3][4] = dt * 2.0 *
  693|  59.8M|                          (tx1 * (c34 - c1345) + ty1 * (c34 - c1345) +
  694|  59.8M|                           tz1 * (r43 * c34 - c1345)) *
  695|  59.8M|                          tmp2 * u[k2][j][i][3];
  696|  59.8M|          d_private[4][4] = 1.0 + dt * 2.0 * (tx1 + ty1 + tz1) * c1345 * tmp1 +
  697|  59.8M|                          dt * 2.0 * (tx1 * dx5 + ty1 * dy5 + tz1 * dz5);
  698|       |
  699|       |          //---------------------------------------------------------------------
  700|       |          // form the first block sub-diagonal
  701|       |          //---------------------------------------------------------------------
  702|  59.8M|          tmp1 = rho_i[k2][j][i + 1];
  703|  59.8M|          tmp2 = tmp1 * tmp1;
  704|  59.8M|          tmp3 = tmp1 * tmp2;
  705|       |
  706|  59.8M|          a_private[0][0] = -dt * tx1 * dx1;
  707|  59.8M|          a_private[1][0] = dt * tx2;
  708|  59.8M|          a_private[2][0] = 0.0;
  709|  59.8M|          a_private[3][0] = 0.0;
  710|  59.8M|          a_private[4][0] = 0.0;
  711|       |
  712|  59.8M|          a_private[0][1] = dt * tx2 * (-(u[k2][j][i + 1][1] * tmp1) *
  713|  59.8M|                                          (u[k2][j][i + 1][1] * tmp1) +
  714|  59.8M|                                      C2 * qs[k2][j][i + 1] * tmp1) -
  715|  59.8M|                          dt * tx1 * (-r43 * c34 * tmp2 * u[k2][j][i + 1][1]);
  716|  59.8M|          a_private[1][1] =
  717|  59.8M|              dt * tx2 * ((2.0 - C2) * (u[k2][j][i + 1][1] * tmp1)) -
  718|  59.8M|              dt * tx1 * (r43 * c34 * tmp1) - dt * tx1 * dx2;
  719|  59.8M|          a_private[2][1] = dt * tx2 * (-C2 * (u[k2][j][i + 1][2] * tmp1));
  720|  59.8M|          a_private[3][1] = dt * tx2 * (-C2 * (u[k2][j][i + 1][3] * tmp1));
  721|  59.8M|          a_private[4][1] = dt * tx2 * C2;
  722|       |
  723|  59.8M|          a_private[0][2] =
  724|  59.8M|              dt * tx2 * (-(u[k2][j][i + 1][1] * u[k2][j][i + 1][2]) * tmp2) -
  725|  59.8M|              dt * tx1 * (-c34 * tmp2 * u[k2][j][i + 1][2]);
  726|  59.8M|          a_private[1][2] = dt * tx2 * (u[k2][j][i + 1][2] * tmp1);
  727|  59.8M|          a_private[2][2] = dt * tx2 * (u[k2][j][i + 1][1] * tmp1) -
  728|  59.8M|                          dt * tx1 * (c34 * tmp1) - dt * tx1 * dx3;
  729|  59.8M|          a_private[3][2] = 0.0;
  730|  59.8M|          a_private[4][2] = 0.0;
  731|       |
  732|  59.8M|          a_private[0][3] =
  733|  59.8M|              dt * tx2 * (-(u[k2][j][i + 1][1] * u[k2][j][i + 1][3]) * tmp2) -
  734|  59.8M|              dt * tx1 * (-c34 * tmp2 * u[k2][j][i + 1][3]);
  735|  59.8M|          a_private[1][3] = dt * tx2 * (u[k2][j][i + 1][3] * tmp1);
  736|  59.8M|          a_private[2][3] = 0.0;
  737|  59.8M|          a_private[3][3] = dt * tx2 * (u[k2][j][i + 1][1] * tmp1) -
  738|  59.8M|                          dt * tx1 * (c34 * tmp1) - dt * tx1 * dx4;
  739|  59.8M|          a_private[4][3] = 0.0;
  740|       |
  741|  59.8M|          a_private[0][4] =
  742|  59.8M|              dt * tx2 *
  743|  59.8M|                  ((C2 * 2.0 * qs[k2][j][i + 1] - C1 * u[k2][j][i + 1][4]) *
  744|  59.8M|                   (u[k2][j][i + 1][1] * tmp2)) -
  745|  59.8M|              dt * tx1 * (-(r43 * c34 - c1345) * tmp3 *
  746|  59.8M|                              (u[k2][j][i + 1][1] * u[k2][j][i + 1][1]) -
  747|  59.8M|                          (c34 - c1345) * tmp3 *
  748|  59.8M|                              (u[k2][j][i + 1][2] * u[k2][j][i + 1][2]) -
  749|  59.8M|                          (c34 - c1345) * tmp3 *
  750|  59.8M|                              (u[k2][j][i + 1][3] * u[k2][j][i + 1][3]) -
  751|  59.8M|                          c1345 * tmp2 * u[k2][j][i + 1][4]);
  752|  59.8M|          a_private[1][4] =
  753|  59.8M|              dt * tx2 *
  754|  59.8M|                  (C1 * (u[k2][j][i + 1][4] * tmp1) -
  755|  59.8M|                   C2 * (u[k2][j][i + 1][1] * u[k2][j][i + 1][1] * tmp2 +
  756|  59.8M|                         qs[k2][j][i + 1] * tmp1)) -
  757|  59.8M|              dt * tx1 * (r43 * c34 - c1345) * tmp2 * u[k2][j][i + 1][1];
  758|  59.8M|          a_private[2][4] =
  759|  59.8M|              dt * tx2 *
  760|  59.8M|                  (-C2 * (u[k2][j][i + 1][2] * u[k2][j][i + 1][1]) * tmp2) -
  761|  59.8M|              dt * tx1 * (c34 - c1345) * tmp2 * u[k2][j][i + 1][2];
  762|  59.8M|          a_private[3][4] =
  763|  59.8M|              dt * tx2 *
  764|  59.8M|                  (-C2 * (u[k2][j][i + 1][3] * u[k2][j][i + 1][1]) * tmp2) -
  765|  59.8M|              dt * tx1 * (c34 - c1345) * tmp2 * u[k2][j][i + 1][3];
  766|  59.8M|          a_private[4][4] = dt * tx2 * (C1 * (u[k2][j][i + 1][1] * tmp1)) -
  767|  59.8M|                          dt * tx1 * c1345 * tmp1 - dt * tx1 * dx5;
  768|       |
  769|       |          //---------------------------------------------------------------------
  770|       |          // form the second block sub-diagonal
  771|       |          //---------------------------------------------------------------------
  772|  59.8M|          tmp1 = rho_i[k2][j + 1][i];
  773|  59.8M|          tmp2 = tmp1 * tmp1;
  774|  59.8M|          tmp3 = tmp1 * tmp2;
  775|       |
  776|  59.8M|          b_private[0][0] = -dt * ty1 * dy1;
  777|  59.8M|          b_private[1][0] = 0.0;
  778|  59.8M|          b_private[2][0] = dt * ty2;
  779|  59.8M|          b_private[3][0] = 0.0;
  780|  59.8M|          b_private[4][0] = 0.0;
  781|       |
  782|  59.8M|          b_private[0][1] =
  783|  59.8M|              dt * ty2 * (-(u[k2][j + 1][i][1] * u[k2][j + 1][i][2]) * tmp2) -
  784|  59.8M|              dt * ty1 * (-c34 * tmp2 * u[k2][j + 1][i][1]);
  785|  59.8M|          b_private[1][1] = dt * ty2 * (u[k2][j + 1][i][2] * tmp1) -
  786|  59.8M|                          dt * ty1 * (c34 * tmp1) - dt * ty1 * dy2;
  787|  59.8M|          b_private[2][1] = dt * ty2 * (u[k2][j + 1][i][1] * tmp1);
  788|  59.8M|          b_private[3][1] = 0.0;
  789|  59.8M|          b_private[4][1] = 0.0;
  790|       |
  791|  59.8M|          b_private[0][2] = dt * ty2 * (-(u[k2][j + 1][i][2] * tmp1) *
  792|  59.8M|                                          (u[k2][j + 1][i][2] * tmp1) +
  793|  59.8M|                                      C2 * (qs[k2][j + 1][i] * tmp1)) -
  794|  59.8M|                          dt * ty1 * (-r43 * c34 * tmp2 * u[k2][j + 1][i][2]);
  795|  59.8M|          b_private[1][2] = dt * ty2 * (-C2 * (u[k2][j + 1][i][1] * tmp1));
  796|  59.8M|          b_private[2][2] =
  797|  59.8M|              dt * ty2 * ((2.0 - C2) * (u[k2][j + 1][i][2] * tmp1)) -
  798|  59.8M|              dt * ty1 * (r43 * c34 * tmp1) - dt * ty1 * dy3;
  799|  59.8M|          b_private[3][2] = dt * ty2 * (-C2 * (u[k2][j + 1][i][3] * tmp1));
  800|  59.8M|          b_private[4][2] = dt * ty2 * C2;
  801|       |
  802|  59.8M|          b_private[0][3] =
  803|  59.8M|              dt * ty2 * (-(u[k2][j + 1][i][2] * u[k2][j + 1][i][3]) * tmp2) -
  804|  59.8M|              dt * ty1 * (-c34 * tmp2 * u[k2][j + 1][i][3]);
  805|  59.8M|          b_private[1][3] = 0.0;
  806|  59.8M|          b_private[2][3] = dt * ty2 * (u[k2][j + 1][i][3] * tmp1);
  807|  59.8M|          b_private[3][3] = dt * ty2 * (u[k2][j + 1][i][2] * tmp1) -
  808|  59.8M|                          dt * ty1 * (c34 * tmp1) - dt * ty1 * dy4;
  809|  59.8M|          b_private[4][3] = 0.0;
  810|       |
  811|  59.8M|          b_private[0][4] =
  812|  59.8M|              dt * ty2 *
  813|  59.8M|                  ((C2 * 2.0 * qs[k2][j + 1][i] - C1 * u[k2][j + 1][i][4]) *
  814|  59.8M|                   (u[k2][j + 1][i][2] * tmp2)) -
  815|  59.8M|              dt * ty1 * (-(c34 - c1345) * tmp3 *
  816|  59.8M|                              (u[k2][j + 1][i][1] * u[k2][j + 1][i][1]) -
  817|  59.8M|                          (r43 * c34 - c1345) * tmp3 *
  818|  59.8M|                              (u[k2][j + 1][i][2] * u[k2][j + 1][i][2]) -
  819|  59.8M|                          (c34 - c1345) * tmp3 *
  820|  59.8M|                              (u[k2][j + 1][i][3] * u[k2][j + 1][i][3]) -
  821|  59.8M|                          c1345 * tmp2 * u[k2][j + 1][i][4]);
  822|  59.8M|          b_private[1][4] =
  823|  59.8M|              dt * ty2 *
  824|  59.8M|                  (-C2 * (u[k2][j + 1][i][1] * u[k2][j + 1][i][2]) * tmp2) -
  825|  59.8M|              dt * ty1 * (c34 - c1345) * tmp2 * u[k2][j + 1][i][1];
  826|  59.8M|          b_private[2][4] =
  827|  59.8M|              dt * ty2 *
  828|  59.8M|                  (C1 * (u[k2][j + 1][i][4] * tmp1) -
  829|  59.8M|                   C2 * (qs[k2][j + 1][i] * tmp1 +
  830|  59.8M|                         u[k2][j + 1][i][2] * u[k2][j + 1][i][2] * tmp2)) -
  831|  59.8M|              dt * ty1 * (r43 * c34 - c1345) * tmp2 * u[k2][j + 1][i][2];
  832|  59.8M|          b_private[3][4] =
  833|  59.8M|              dt * ty2 *
  834|  59.8M|                  (-C2 * (u[k2][j + 1][i][2] * u[k2][j + 1][i][3]) * tmp2) -
  835|  59.8M|              dt * ty1 * (c34 - c1345) * tmp2 * u[k2][j + 1][i][3];
  836|  59.8M|          b_private[4][4] = dt * ty2 * (C1 * (u[k2][j + 1][i][2] * tmp1)) -
  837|  59.8M|                          dt * ty1 * c1345 * tmp1 - dt * ty1 * dy5;
  838|       |
  839|       |          //---------------------------------------------------------------------
  840|       |          // form the third block sub-diagonal
  841|       |          //---------------------------------------------------------------------
  842|  59.8M|          tmp1 = rho_i[k2 + 1][j][i];
  843|  59.8M|          tmp2 = tmp1 * tmp1;
  844|  59.8M|          tmp3 = tmp1 * tmp2;
  845|       |
  846|  59.8M|          c_private[0][0] = -dt * tz1 * dz1;
  847|  59.8M|          c_private[1][0] = 0.0;
  848|  59.8M|          c_private[2][0] = 0.0;
  849|  59.8M|          c_private[3][0] = dt * tz2;
  850|  59.8M|          c_private[4][0] = 0.0;
  851|       |
  852|  59.8M|          c_private[0][1] =
  853|  59.8M|              dt * tz2 * (-(u[k2 + 1][j][i][1] * u[k2 + 1][j][i][3]) * tmp2) -
  854|  59.8M|              dt * tz1 * (-c34 * tmp2 * u[k2 + 1][j][i][1]);
  855|  59.8M|          c_private[1][1] = dt * tz2 * (u[k2 + 1][j][i][3] * tmp1) -
  856|  59.8M|                          dt * tz1 * c34 * tmp1 - dt * tz1 * dz2;
  857|  59.8M|          c_private[2][1] = 0.0;
  858|  59.8M|          c_private[3][1] = dt * tz2 * (u[k2 + 1][j][i][1] * tmp1);
  859|  59.8M|          c_private[4][1] = 0.0;
  860|       |
  861|  59.8M|          c_private[0][2] =
  862|  59.8M|              dt * tz2 * (-(u[k2 + 1][j][i][2] * u[k2 + 1][j][i][3]) * tmp2) -
  863|  59.8M|              dt * tz1 * (-c34 * tmp2 * u[k2 + 1][j][i][2]);
  864|  59.8M|          c_private[1][2] = 0.0;
  865|  59.8M|          c_private[2][2] = dt * tz2 * (u[k2 + 1][j][i][3] * tmp1) -
  866|  59.8M|                          dt * tz1 * (c34 * tmp1) - dt * tz1 * dz3;
  867|  59.8M|          c_private[3][2] = dt * tz2 * (u[k2 + 1][j][i][2] * tmp1);
  868|  59.8M|          c_private[4][2] = 0.0;
  869|       |
  870|  59.8M|          c_private[0][3] = dt * tz2 * (-(u[k2 + 1][j][i][3] * tmp1) *
  871|  59.8M|                                          (u[k2 + 1][j][i][3] * tmp1) +
  872|  59.8M|                                      C2 * (qs[k2 + 1][j][i] * tmp1)) -
  873|  59.8M|                          dt * tz1 * (-r43 * c34 * tmp2 * u[k2 + 1][j][i][3]);
  874|  59.8M|          c_private[1][3] = dt * tz2 * (-C2 * (u[k2 + 1][j][i][1] * tmp1));
  875|  59.8M|          c_private[2][3] = dt * tz2 * (-C2 * (u[k2 + 1][j][i][2] * tmp1));
  876|  59.8M|          c_private[3][3] =
  877|  59.8M|              dt * tz2 * (2.0 - C2) * (u[k2 + 1][j][i][3] * tmp1) -
  878|  59.8M|              dt * tz1 * (r43 * c34 * tmp1) - dt * tz1 * dz4;
  879|  59.8M|          c_private[4][3] = dt * tz2 * C2;
  880|       |
  881|  59.8M|          c_private[0][4] =
  882|  59.8M|              dt * tz2 *
  883|  59.8M|                  ((C2 * 2.0 * qs[k2 + 1][j][i] - C1 * u[k2 + 1][j][i][4]) *
  884|  59.8M|                   (u[k2 + 1][j][i][3] * tmp2)) -
  885|  59.8M|              dt * tz1 * (-(c34 - c1345) * tmp3 *
  886|  59.8M|                              (u[k2 + 1][j][i][1] * u[k2 + 1][j][i][1]) -
  887|  59.8M|                          (c34 - c1345) * tmp3 *
  888|  59.8M|                              (u[k2 + 1][j][i][2] * u[k2 + 1][j][i][2]) -
  889|  59.8M|                          (r43 * c34 - c1345) * tmp3 *
  890|  59.8M|                              (u[k2 + 1][j][i][3] * u[k2 + 1][j][i][3]) -
  891|  59.8M|                          c1345 * tmp2 * u[k2 + 1][j][i][4]);
  892|  59.8M|          c_private[1][4] =
  893|  59.8M|              dt * tz2 *
  894|  59.8M|                  (-C2 * (u[k2 + 1][j][i][1] * u[k2 + 1][j][i][3]) * tmp2) -
  895|  59.8M|              dt * tz1 * (c34 - c1345) * tmp2 * u[k2 + 1][j][i][1];
  896|  59.8M|          c_private[2][4] =
  897|  59.8M|              dt * tz2 *
  898|  59.8M|                  (-C2 * (u[k2 + 1][j][i][2] * u[k2 + 1][j][i][3]) * tmp2) -
  899|  59.8M|              dt * tz1 * (c34 - c1345) * tmp2 * u[k2 + 1][j][i][2];
  900|  59.8M|          c_private[3][4] =
  901|  59.8M|              dt * tz2 *
  902|  59.8M|                  (C1 * (u[k2 + 1][j][i][4] * tmp1) -
  903|  59.8M|                   C2 * (qs[k2 + 1][j][i] * tmp1 +
  904|  59.8M|                         u[k2 + 1][j][i][3] * u[k2 + 1][j][i][3] * tmp2)) -
  905|  59.8M|              dt * tz1 * (r43 * c34 - c1345) * tmp2 * u[k2 + 1][j][i][3];
  906|  59.8M|          c_private[4][4] = dt * tz2 * (C1 * (u[k2 + 1][j][i][3] * tmp1)) -
  907|  59.8M|                          dt * tz1 * c1345 * tmp1 - dt * tz1 * dz5;
  908|       |          //---------------------------------------------------------------------
  909|       |          // perform the upper triangular solution
  910|       |          //---------------------------------------------------------------------
  911|       |          /* buts(ISIZ1, ISIZ2, ISIZ3, nx, ny, nz, k, omega, rsd, tv, d, a, b, c, ist,
  912|       |             iend, jst, jend, nx0, ny0) is inlined below */
  913|       |
  914|   358M|          for (m = 0; m < 5; m++) {
  915|   299M|            tv[j][i][m] = omega1 * (c_private[0][m] * rsd[k3 + 1][j][i][0] +
  916|   299M|                                     c_private[1][m] * rsd[k3 + 1][j][i][1] +
  917|   299M|                                     c_private[2][m] * rsd[k3 + 1][j][i][2] +
  918|   299M|                                     c_private[3][m] * rsd[k3 + 1][j][i][3] +
  919|   299M|                                     c_private[4][m] * rsd[k3 + 1][j][i][4]);
  920|   299M|          }
  921|       |
  922|   358M|          for (m = 0; m < 5; m++) {
  923|   299M|            tv[j][i][m] = tv[j][i][m] +
  924|   299M|                           omega1 * (b_private[0][m] * rsd[k3][j + 1][i][0] +
  925|   299M|                                     a_private[0][m] * rsd[k3][j][i + 1][0] +
  926|   299M|                                     b_private[1][m] * rsd[k3][j + 1][i][1] +
  927|   299M|                                     a_private[1][m] * rsd[k3][j][i + 1][1] +
  928|   299M|                                     b_private[2][m] * rsd[k3][j + 1][i][2] +
  929|   299M|                                     a_private[2][m] * rsd[k3][j][i + 1][2] +
  930|   299M|                                     b_private[3][m] * rsd[k3][j + 1][i][3] +
  931|   299M|                                     a_private[3][m] * rsd[k3][j][i + 1][3] +
  932|   299M|                                     b_private[4][m] * rsd[k3][j + 1][i][4] +
  933|   299M|                                     a_private[4][m] * rsd[k3][j][i + 1][4]);
  934|   299M|          }
  935|       |
  936|       |          //---------------------------------------------------------------------
  937|       |          // diagonal block inversion
  938|       |          //---------------------------------------------------------------------
  939|   358M|          for (m = 0; m < 5; m++) {
  940|   299M|            tmat[m][0] = d_private[0][m];
  941|   299M|            tmat[m][1] = d_private[1][m];
  942|   299M|            tmat[m][2] = d_private[2][m];
  943|   299M|            tmat[m][3] = d_private[3][m];
  944|   299M|            tmat[m][4] = d_private[4][m];
  945|   299M|          }
  946|       |
  947|  59.8M|          tmp1 = 1.0 / tmat[0][0];
  948|  59.8M|          tmp = tmp1 * tmat[1][0];
  949|  59.8M|          tmat[1][1] = tmat[1][1] - tmp * tmat[0][1];
  950|  59.8M|          tmat[1][2] = tmat[1][2] - tmp * tmat[0][2];
  951|  59.8M|          tmat[1][3] = tmat[1][3] - tmp * tmat[0][3];
  952|  59.8M|          tmat[1][4] = tmat[1][4] - tmp * tmat[0][4];
  953|  59.8M|          tv[j][i][1] = tv[j][i][1] - tv[j][i][0] * tmp;
  954|       |
  955|  59.8M|          tmp = tmp1 * tmat[2][0];
  956|  59.8M|          tmat[2][1] = tmat[2][1] - tmp * tmat[0][1];
  957|  59.8M|          tmat[2][2] = tmat[2][2] - tmp * tmat[0][2];
  958|  59.8M|          tmat[2][3] = tmat[2][3] - tmp * tmat[0][3];
  959|  59.8M|          tmat[2][4] = tmat[2][4] - tmp * tmat[0][4];
  960|  59.8M|          tv[j][i][2] = tv[j][i][2] - tv[j][i][0] * tmp;
  961|       |
  962|  59.8M|          tmp = tmp1 * tmat[3][0];
  963|  59.8M|          tmat[3][1] = tmat[3][1] - tmp * tmat[0][1];
  964|  59.8M|          tmat[3][2] = tmat[3][2] - tmp * tmat[0][2];
  965|  59.8M|          tmat[3][3] = tmat[3][3] - tmp * tmat[0][3];
  966|  59.8M|          tmat[3][4] = tmat[3][4] - tmp * tmat[0][4];
  967|  59.8M|          tv[j][i][3] = tv[j][i][3] - tv[j][i][0] * tmp;
  968|       |
  969|  59.8M|          tmp = tmp1 * tmat[4][0];
  970|  59.8M|          tmat[4][1] = tmat[4][1] - tmp * tmat[0][1];
  971|  59.8M|          tmat[4][2] = tmat[4][2] - tmp * tmat[0][2];
  972|  59.8M|          tmat[4][3] = tmat[4][3] - tmp * tmat[0][3];
  973|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[0][4];
  974|  59.8M|          tv[j][i][4] = tv[j][i][4] - tv[j][i][0] * tmp;
  975|       |
  976|  59.8M|          tmp1 = 1.0 / tmat[1][1];
  977|  59.8M|          tmp = tmp1 * tmat[2][1];
  978|  59.8M|          tmat[2][2] = tmat[2][2] - tmp * tmat[1][2];
  979|  59.8M|          tmat[2][3] = tmat[2][3] - tmp * tmat[1][3];
  980|  59.8M|          tmat[2][4] = tmat[2][4] - tmp * tmat[1][4];
  981|  59.8M|          tv[j][i][2] = tv[j][i][2] - tv[j][i][1] * tmp;
  982|       |
  983|  59.8M|          tmp = tmp1 * tmat[3][1];
  984|  59.8M|          tmat[3][2] = tmat[3][2] - tmp * tmat[1][2];
  985|  59.8M|          tmat[3][3] = tmat[3][3] - tmp * tmat[1][3];
  986|  59.8M|          tmat[3][4] = tmat[3][4] - tmp * tmat[1][4];
  987|  59.8M|          tv[j][i][3] = tv[j][i][3] - tv[j][i][1] * tmp;
  988|       |
  989|  59.8M|          tmp = tmp1 * tmat[4][1];
  990|  59.8M|          tmat[4][2] = tmat[4][2] - tmp * tmat[1][2];
  991|  59.8M|          tmat[4][3] = tmat[4][3] - tmp * tmat[1][3];
  992|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[1][4];
  993|  59.8M|          tv[j][i][4] = tv[j][i][4] - tv[j][i][1] * tmp;
  994|       |
  995|  59.8M|          tmp1 = 1.0 / tmat[2][2];
  996|  59.8M|          tmp = tmp1 * tmat[3][2];
  997|  59.8M|          tmat[3][3] = tmat[3][3] - tmp * tmat[2][3];
  998|  59.8M|          tmat[3][4] = tmat[3][4] - tmp * tmat[2][4];
  999|  59.8M|          tv[j][i][3] = tv[j][i][3] - tv[j][i][2] * tmp;
 1000|       |
 1001|  59.8M|          tmp = tmp1 * tmat[4][2];
 1002|  59.8M|          tmat[4][3] = tmat[4][3] - tmp * tmat[2][3];
 1003|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[2][4];
 1004|  59.8M|          tv[j][i][4] = tv[j][i][4] - tv[j][i][2] * tmp;
 1005|       |
 1006|  59.8M|          tmp1 = 1.0 / tmat[3][3];
 1007|  59.8M|          tmp = tmp1 * tmat[4][3];
 1008|  59.8M|          tmat[4][4] = tmat[4][4] - tmp * tmat[3][4];
 1009|  59.8M|          tv[j][i][4] = tv[j][i][4] - tv[j][i][3] * tmp;
 1010|       |
 1011|       |          //---------------------------------------------------------------------
 1012|       |          // back substitution
 1013|       |          //---------------------------------------------------------------------
 1014|  59.8M|          tv[j][i][4] = tv[j][i][4] / tmat[4][4];
 1015|       |
 1016|  59.8M|          tv[j][i][3] = tv[j][i][3] - tmat[3][4] * tv[j][i][4];
 1017|  59.8M|          tv[j][i][3] = tv[j][i][3] / tmat[3][3];
 1018|       |
 1019|  59.8M|          tv[j][i][2] = tv[j][i][2] - tmat[2][3] * tv[j][i][3] -
 1020|  59.8M|                         tmat[2][4] * tv[j][i][4];
 1021|  59.8M|          tv[j][i][2] = tv[j][i][2] / tmat[2][2];
 1022|       |
 1023|  59.8M|          tv[j][i][1] = tv[j][i][1] - tmat[1][2] * tv[j][i][2] -
 1024|  59.8M|                         tmat[1][3] * tv[j][i][3] -
 1025|  59.8M|                         tmat[1][4] * tv[j][i][4];
 1026|  59.8M|          tv[j][i][1] = tv[j][i][1] / tmat[1][1];
 1027|       |
 1028|  59.8M|          tv[j][i][0] = tv[j][i][0] - tmat[0][1] * tv[j][i][1] -
 1029|  59.8M|                         tmat[0][2] * tv[j][i][2] -
 1030|  59.8M|                         tmat[0][3] * tv[j][i][3] -
 1031|  59.8M|                         tmat[0][4] * tv[j][i][4];
 1032|  59.8M|          tv[j][i][0] = tv[j][i][0] / tmat[0][0];
 1033|       |
 1034|  59.8M|          rsd[k3][j][i][0] = rsd[k3][j][i][0] - tv[j][i][0];
 1035|  59.8M|          rsd[k3][j][i][1] = rsd[k3][j][i][1] - tv[j][i][1];
 1036|  59.8M|          rsd[k3][j][i][2] = rsd[k3][j][i][2] - tv[j][i][2];
 1037|  59.8M|          rsd[k3][j][i][3] = rsd[k3][j][i][3] - tv[j][i][3];
 1038|  59.8M|          rsd[k3][j][i][4] = rsd[k3][j][i][4] - tv[j][i][4];
 1039|  59.8M|        }
 1040|   964k|      }
 1041|  15.5k|    }
 1042|    251|}
 1043|       |    //---------------------------------------------------------------------
 1044|       |    // update the variables
 1045|       |    //---------------------------------------------------------------------
 1046|    251|    if (timeron)
 1047|      0|      timer_start(t_add);
 1048|    251|#pragma dvm region
 1049|    251|{
 1050|    251|#pragma dvm parallel([k][j][i] on dvm_tpl[k][j][i]) private(k, j, i, m)
 1051|  15.8k|    for (k = 1; k < nz - 1; k++) {
 1052|   980k|      for (j = jst; j < jend; j++) {
 1053|  60.7M|        for (i = ist; i < iend; i++) {
 1054|   358M|          for (m = 0; m < 5; m++) {
 1055|   299M|            u[k][j][i][m] = u[k][j][i][m] + tmp * rsd[k][j][i][m];
 1056|   299M|          }
 1057|  59.8M|        }
 1058|   964k|      }
 1059|  15.5k|    }
 1060|    251|}
 1061|    251|    if (timeron)
 1062|      0|      timer_stop(t_add);
 1063|       |
 1064|       |    //---------------------------------------------------------------------
 1065|       |    // compute the max-norms of newton iteration corrections
 1066|       |    //---------------------------------------------------------------------
 1067|    251|    if ((istep % inorm) == 0) {
 1068|      1|      if (timeron)
 1069|      0|        timer_start(t_l2norm);
 1070|      1|      l2norm(ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0, ist, iend, jst, jend, rsd,
 1071|      1|             delunm);
 1072|      1|      if (timeron)
 1073|      0|        timer_stop(t_l2norm);
 1074|       |      /*
 1075|       |      if ( ipr == 1 ) {
 1076|       |        printf(" \n RMS-norm of SSOR-iteration correction "
 1077|       |               "for first pde  = %12.5E\n"
 1078|       |               " RMS-norm of SSOR-iteration correction "
 1079|       |               "for second pde = %12.5E\n"
 1080|       |               " RMS-norm of SSOR-iteration correction "
 1081|       |               "for third pde  = %12.5E\n"
 1082|       |               " RMS-norm of SSOR-iteration correction "
 1083|       |               "for fourth pde = %12.5E\n",
 1084|       |               " RMS-norm of SSOR-iteration correction "
 1085|       |               "for fifth pde  = %12.5E\n",
 1086|       |               delunm[0], delunm[1], delunm[2], delunm[3], delunm[4]);
 1087|       |      } else if ( ipr == 2 ) {
 1088|       |        printf("(%5d,%15.6f)\n", istep, delunm[4]);
 1089|       |      }
 1090|       |      */
 1091|      1|    }
 1092|       |
 1093|       |    //---------------------------------------------------------------------
 1094|       |    // compute the steady-state residuals
 1095|       |    //---------------------------------------------------------------------
 1096|    251|    rhs();
 1097|       |
 1098|       |    //---------------------------------------------------------------------
 1099|       |    // compute the max-norms of newton iteration residuals
 1100|       |    //---------------------------------------------------------------------
 1101|    251|    if (((istep % inorm) == 0) || (istep == itmax)) {
 1102|      1|      if (timeron)
 1103|      0|        timer_start(t_l2norm);
 1104|      1|      l2norm(ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0, ist, iend, jst, jend, rsd,
 1105|      1|             rsdnm);
 1106|      1|      if (timeron)
 1107|      0|        timer_stop(t_l2norm);
 1108|       |      /*
 1109|       |      if ( ipr == 1 ) {
 1110|       |        printf(" \n RMS-norm of steady-state residual for "
 1111|       |               "first pde  = %12.5E\n"
 1112|       |               " RMS-norm of steady-state residual for "
 1113|       |               "second pde = %12.5E\n"
 1114|       |               " RMS-norm of steady-state residual for "
 1115|       |               "third pde  = %12.5E\n"
 1116|       |               " RMS-norm of steady-state residual for "
 1117|       |               "fourth pde = %12.5E\n"
 1118|       |               " RMS-norm of steady-state residual for "
 1119|       |               "fifth pde  = %12.5E\n",
 1120|       |               rsdnm[0], rsdnm[1], rsdnm[2], rsdnm[3], rsdnm[4]);
 1121|       |      }
 1122|       |      */
 1123|      1|    }
 1124|       |
 1125|       |    //---------------------------------------------------------------------
 1126|       |    // check the newton-iteration residuals against the tolerance levels
 1127|       |    //---------------------------------------------------------------------
 1128|    251|    if ((rsdnm[0] < tolrsd[0]) && (rsdnm[1] < tolrsd[1]) &&
 1129|    251|        (rsdnm[2] < tolrsd[2]) && (rsdnm[3] < tolrsd[3]) &&
 1130|    251|        (rsdnm[4] < tolrsd[4])) {
 1131|       |      // if (ipr == 1 ) {
 1132|      0|      printf(" \n convergence was achieved after %4d pseudo-time steps\n",
 1133|      0|             istep);
 1134|       |      //}
 1135|      0|      break;
 1136|      0|    }
 1137|    251|  }
 1138|       |
 1139|      2|#pragma dvm get_actual(u)
 1140|       |
 1141|      2|#pragma dvm endinterval
 1142|      2|  timer_stop(1);
 1143|      2|  maxtime = timer_read(1);
 1144|       |
 1145|      2|}

/home/dvmuser3/andrey/npb-3.3-c/LU/verify.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <math.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |// verification routine                         
   40|       |//---------------------------------------------------------------------
   41|       |void verify(double xcr[5], double xce[5], double xci, 
   42|       |            char *Class, logical *verified)
   43|      1|{
   44|      1|  double xcrref[5], xceref[5], xciref;
   45|      1|  double xcrdif[5], xcedif[5], xcidif;
   46|      1|  double epsilon, dtref = 0.0;
   47|      1|  int m;
   48|       |
   49|       |  //---------------------------------------------------------------------
   50|       |  // tolerance level
   51|       |  //---------------------------------------------------------------------
   52|      1|  epsilon = 1.0e-08;
   53|       |
   54|      1|  *Class = 'U';
   55|      1|  *verified = true;
   56|       |
   57|      6|  for (m = 0; m < 5; m++) {
   58|      5|    xcrref[m] = 1.0;
   59|      5|    xceref[m] = 1.0;
   60|      5|  }
   61|      1|  xciref = 1.0;
   62|       |
   63|      1|  if ((nx0 == 12) && (ny0 == 12) && (nz0 == 12) && (itmax == 50)) {
   64|       |
   65|      0|    *Class = 'S';
   66|      0|    dtref = 5.0e-1;
   67|       |    //---------------------------------------------------------------------
   68|       |    // Reference values of RMS-norms of residual, for the (12X12X12) grid,
   69|       |    // after 50 time steps, with  DT = 5.0e-01
   70|       |    //---------------------------------------------------------------------
   71|      0|    xcrref[0] = 1.6196343210976702e-02;
   72|      0|    xcrref[1] = 2.1976745164821318e-03;
   73|      0|    xcrref[2] = 1.5179927653399185e-03;
   74|      0|    xcrref[3] = 1.5029584435994323e-03;
   75|      0|    xcrref[4] = 3.4264073155896461e-02;
   76|       |
   77|       |    //---------------------------------------------------------------------
   78|       |    // Reference values of RMS-norms of solution error, 
   79|       |    // for the (12X12X12) grid,
   80|       |    // after 50 time steps, with  DT = 5.0e-01
   81|       |    //---------------------------------------------------------------------
   82|      0|    xceref[0] = 6.4223319957960924e-04;
   83|      0|    xceref[1] = 8.4144342047347926e-05;
   84|      0|    xceref[2] = 5.8588269616485186e-05;
   85|      0|    xceref[3] = 5.8474222595157350e-05;
   86|      0|    xceref[4] = 1.3103347914111294e-03;
   87|       |
   88|       |    //---------------------------------------------------------------------
   89|       |    // Reference value of surface integral, for the (12X12X12) grid,
   90|       |    // after 50 time steps, with DT = 5.0e-01
   91|       |    //---------------------------------------------------------------------
   92|      0|    xciref = 7.8418928865937083e+00;
   93|       |
   94|      1|  } else if ((nx0 == 33) && (ny0 == 33) && (nz0 == 33) && (itmax == 300)) {
   95|       |
   96|      0|    *Class = 'W';   //SPEC95fp size
   97|      0|    dtref = 1.5e-3;
   98|       |    //---------------------------------------------------------------------
   99|       |    // Reference values of RMS-norms of residual, for the (33x33x33) grid,
  100|       |    // after 300 time steps, with  DT = 1.5e-3
  101|       |    //---------------------------------------------------------------------
  102|      0|    xcrref[0] = 0.1236511638192e+02;
  103|      0|    xcrref[1] = 0.1317228477799e+01;
  104|      0|    xcrref[2] = 0.2550120713095e+01;
  105|      0|    xcrref[3] = 0.2326187750252e+01;
  106|      0|    xcrref[4] = 0.2826799444189e+02;
  107|       |
  108|       |    //---------------------------------------------------------------------
  109|       |    // Reference values of RMS-norms of solution error, 
  110|       |    // for the (33X33X33) grid,
  111|       |    //---------------------------------------------------------------------
  112|      0|    xceref[0] = 0.4867877144216e+00;
  113|      0|    xceref[1] = 0.5064652880982e-01;
  114|      0|    xceref[2] = 0.9281818101960e-01;
  115|      0|    xceref[3] = 0.8570126542733e-01;
  116|      0|    xceref[4] = 0.1084277417792e+01;
  117|       |
  118|       |    //---------------------------------------------------------------------
  119|       |    // Reference value of surface integral, for the (33X33X33) grid,
  120|       |    // after 300 time steps, with  DT = 1.5e-3
  121|       |    //---------------------------------------------------------------------
  122|      0|    xciref    = 0.1161399311023e+02;
  123|       |
  124|      1|  } else if ((nx0 == 64) && (ny0 == 64) && (nz0 == 64) && (itmax == 250)) {
  125|       |
  126|      1|    *Class = 'A';
  127|      1|    dtref = 2.0e+0;
  128|       |    //---------------------------------------------------------------------
  129|       |    // Reference values of RMS-norms of residual, for the (64X64X64) grid,
  130|       |    // after 250 time steps, with  DT = 2.0e+00
  131|       |    //---------------------------------------------------------------------
  132|      1|    xcrref[0] = 7.7902107606689367e+02;
  133|      1|    xcrref[1] = 6.3402765259692870e+01;
  134|      1|    xcrref[2] = 1.9499249727292479e+02;
  135|      1|    xcrref[3] = 1.7845301160418537e+02;
  136|      1|    xcrref[4] = 1.8384760349464247e+03;
  137|       |
  138|       |    //---------------------------------------------------------------------
  139|       |    // Reference values of RMS-norms of solution error, 
  140|       |    // for the (64X64X64) grid,
  141|       |    // after 250 time steps, with  DT = 2.0e+00
  142|       |    //---------------------------------------------------------------------
  143|      1|    xceref[0] = 2.9964085685471943e+01;
  144|      1|    xceref[1] = 2.8194576365003349e+00;
  145|      1|    xceref[2] = 7.3473412698774742e+00;
  146|      1|    xceref[3] = 6.7139225687777051e+00;
  147|      1|    xceref[4] = 7.0715315688392578e+01;
  148|       |
  149|       |    //---------------------------------------------------------------------
  150|       |    // Reference value of surface integral, for the (64X64X64) grid,
  151|       |    // after 250 time steps, with DT = 2.0e+00
  152|       |    //---------------------------------------------------------------------
  153|      1|    xciref = 2.6030925604886277e+01;
  154|       |
  155|      1|  } else if ((nx0 == 102) && (ny0 == 102) && (nz0 == 102) && (itmax == 250)) {
  156|       |
  157|      0|    *Class = 'B';
  158|      0|    dtref = 2.0e+0;
  159|       |
  160|       |    //---------------------------------------------------------------------
  161|       |    // Reference values of RMS-norms of residual, for the (102X102X102) grid,
  162|       |    // after 250 time steps, with  DT = 2.0e+00
  163|       |    //---------------------------------------------------------------------
  164|      0|    xcrref[0] = 3.5532672969982736e+03;
  165|      0|    xcrref[1] = 2.6214750795310692e+02;
  166|      0|    xcrref[2] = 8.8333721850952190e+02;
  167|      0|    xcrref[3] = 7.7812774739425265e+02;
  168|      0|    xcrref[4] = 7.3087969592545314e+03;
  169|       |
  170|       |    //---------------------------------------------------------------------
  171|       |    // Reference values of RMS-norms of solution error, for the (102X102X102) 
  172|       |    // grid, after 250 time steps, with  DT = 2.0e+00
  173|       |    //---------------------------------------------------------------------
  174|      0|    xceref[0] = 1.1401176380212709e+02;
  175|      0|    xceref[1] = 8.1098963655421574e+00;
  176|      0|    xceref[2] = 2.8480597317698308e+01;
  177|      0|    xceref[3] = 2.5905394567832939e+01;
  178|      0|    xceref[4] = 2.6054907504857413e+02;
  179|       |
  180|       |    //---------------------------------------------------------------------
  181|       |    // Reference value of surface integral, for the (102X102X102) grid,
  182|       |    // after 250 time steps, with DT = 2.0e+00
  183|       |    //---------------------------------------------------------------------
  184|      0|    xciref = 4.7887162703308227e+01;
  185|       |
  186|      0|  } else if ((nx0 == 162) && (ny0 == 162) && (nz0 == 162) && (itmax == 250)) {
  187|       |
  188|      0|    *Class = 'C';
  189|      0|    dtref = 2.0e+0;
  190|       |
  191|       |    //---------------------------------------------------------------------
  192|       |    // Reference values of RMS-norms of residual, for the (162X162X162) grid,
  193|       |    // after 250 time steps, with  DT = 2.0e+00
  194|       |    //---------------------------------------------------------------------
  195|      0|    xcrref[0] = 1.03766980323537846e+04;
  196|      0|    xcrref[1] = 8.92212458801008552e+02;
  197|      0|    xcrref[2] = 2.56238814582660871e+03;
  198|      0|    xcrref[3] = 2.19194343857831427e+03;
  199|      0|    xcrref[4] = 1.78078057261061185e+04;
  200|       |
  201|       |    //---------------------------------------------------------------------
  202|       |    // Reference values of RMS-norms of solution error, for the (162X162X162) 
  203|       |    // grid, after 250 time steps, with  DT = 2.0e+00
  204|       |    //---------------------------------------------------------------------
  205|      0|    xceref[0] = 2.15986399716949279e+02;
  206|      0|    xceref[1] = 1.55789559239863600e+01;
  207|      0|    xceref[2] = 5.41318863077207766e+01;
  208|      0|    xceref[3] = 4.82262643154045421e+01;
  209|      0|    xceref[4] = 4.55902910043250358e+02;
  210|       |
  211|       |    //---------------------------------------------------------------------
  212|       |    // Reference value of surface integral, for the (162X162X162) grid,
  213|       |    // after 250 time steps, with DT = 2.0e+00
  214|       |    //---------------------------------------------------------------------
  215|      0|    xciref = 6.66404553572181300e+01;
  216|       |
  217|       |    //---------------------------------------------------------------------
  218|       |    // Reference value of surface integral, for the (162X162X162) grid,
  219|       |    // after 250 time steps, with DT = 2.0e+00
  220|       |    //---------------------------------------------------------------------
  221|      0|    xciref = 6.66404553572181300e+01;
  222|       |
  223|      0|  } else if ((nx0 == 408) && (ny0 == 408) && (nz0 == 408) && (itmax == 300)) {
  224|       |
  225|      0|    *Class = 'D';
  226|      0|    dtref = 1.0e+0;
  227|       |
  228|       |    //---------------------------------------------------------------------
  229|       |    // Reference values of RMS-norms of residual, for the (408X408X408) grid,
  230|       |    // after 300 time steps, with  DT = 1.0e+00
  231|       |    //---------------------------------------------------------------------
  232|      0|    xcrref[0] = 0.4868417937025e+05;
  233|      0|    xcrref[1] = 0.4696371050071e+04;
  234|      0|    xcrref[2] = 0.1218114549776e+05;
  235|      0|    xcrref[3] = 0.1033801493461e+05;
  236|      0|    xcrref[4] = 0.7142398413817e+05;
  237|       |
  238|       |    //---------------------------------------------------------------------
  239|       |    // Reference values of RMS-norms of solution error, for the (408X408X408) 
  240|       |    // grid, after 300 time steps, with  DT = 1.0e+00
  241|       |    //---------------------------------------------------------------------
  242|      0|    xceref[0] = 0.3752393004482e+03;
  243|      0|    xceref[1] = 0.3084128893659e+02;
  244|      0|    xceref[2] = 0.9434276905469e+02;
  245|      0|    xceref[3] = 0.8230686681928e+02;
  246|      0|    xceref[4] = 0.7002620636210e+03;
  247|       |
  248|       |    //---------------------------------------------------------------------
  249|       |    // Reference value of surface integral, for the (408X408X408) grid,
  250|       |    // after 300 time steps, with DT = 1.0e+00
  251|       |    //---------------------------------------------------------------------
  252|      0|    xciref =    0.8334101392503e+02;
  253|       |
  254|      0|  } else if ((nx0 == 1020) && (ny0 == 1020) && (nz0 == 1020) && 
  255|      0|             (itmax == 300)) {
  256|       |
  257|      0|    *Class = 'E';
  258|      0|    dtref = 0.5e+0;
  259|       |
  260|       |    //---------------------------------------------------------------------
  261|       |    // Reference values of RMS-norms of residual, 
  262|       |    // for the (1020X1020X1020) grid,
  263|       |    // after 300 time steps, with  DT = 0.5e+00
  264|       |    //---------------------------------------------------------------------
  265|      0|    xcrref[0] = 0.2099641687874e+06;
  266|      0|    xcrref[1] = 0.2130403143165e+05;
  267|      0|    xcrref[2] = 0.5319228789371e+05;
  268|      0|    xcrref[3] = 0.4509761639833e+05;
  269|      0|    xcrref[4] = 0.2932360006590e+06;
  270|       |
  271|       |    //---------------------------------------------------------------------
  272|       |    // Reference values of RMS-norms of solution error, 
  273|       |    // for the (1020X1020X1020) 
  274|       |    // grid, after 300 time steps, with  DT = 0.5e+00
  275|       |    //---------------------------------------------------------------------
  276|      0|    xceref[0] = 0.4800572578333e+03;
  277|      0|    xceref[1] = 0.4221993400184e+02;
  278|      0|    xceref[2] = 0.1210851906824e+03;
  279|      0|    xceref[3] = 0.1047888986770e+03;
  280|      0|    xceref[4] = 0.8363028257389e+03;
  281|       |
  282|       |    //---------------------------------------------------------------------
  283|       |    // Reference value of surface integral, for the (1020X1020X1020) grid,
  284|       |    // after 300 time steps, with DT = 0.5e+00
  285|       |    //---------------------------------------------------------------------
  286|      0|    xciref =    0.9512163272273e+02;
  287|       |
  288|      0|  } else {
  289|      0|    *verified = false;
  290|      0|  }
  291|       |
  292|       |  //---------------------------------------------------------------------
  293|       |  // verification test for residuals if gridsize is one of 
  294|       |  // the defined grid sizes above (*Class != 'U')
  295|       |  //---------------------------------------------------------------------
  296|       |
  297|       |  //---------------------------------------------------------------------
  298|       |  // Compute the difference of solution values and the known reference values.
  299|       |  //---------------------------------------------------------------------
  300|      6|  for (m = 0; m < 5; m++) {
  301|      5|    xcrdif[m] = fabs((xcr[m]-xcrref[m])/xcrref[m]);
  302|      5|    xcedif[m] = fabs((xce[m]-xceref[m])/xceref[m]);
  303|      5|  }
  304|      1|  xcidif = fabs((xci - xciref)/xciref);
  305|       |
  306|       |
  307|       |  //---------------------------------------------------------------------
  308|       |  // Output the comparison of computed results to known cases.
  309|       |  //---------------------------------------------------------------------
  310|      1|  if (*Class != 'U') {
  311|      1|    printf("\n Verification being performed for class %c\n", *Class);
  312|      1|    printf(" Accuracy setting for epsilon = %20.13E\n", epsilon);
  313|      1|    *verified = (fabs(dt-dtref) <= epsilon);
  314|      1|    if (!(*verified)) {
  315|      0|      *Class = 'U';
  316|      0|      printf(" DT does not match the reference value of %15.8E\n", dtref);
  317|      0|    }
  318|      1|  } else { 
  319|      0|    printf(" Unknown class\n");
  320|      0|  }
  321|       |
  322|      1|  if (*Class != 'U') {
  323|      1|    printf(" Comparison of RMS-norms of residual\n");
  324|      1|  } else {
  325|      0|    printf(" RMS-norms of residual\n");
  326|      0|  }
  327|       |
  328|      6|  for (m = 0; m < 5; m++) {
  329|      5|    if (*Class == 'U') {
  330|      0|      printf("          %2d  %20.13E\n", m+1, xcr[m]);
  331|      5|    } else if (xcrdif[m] <= epsilon) {
  332|      5|      printf("          %2d  %20.13E%20.13E%20.13E\n", 
  333|      5|          m+1 ,xcr[m], xcrref[m], xcrdif[m]);
  334|      5|    } else { 
  335|      0|      *verified = false;
  336|      0|      printf(" FAILURE: %2d  %20.13E%20.13E%20.13E\n",
  337|      0|          m+1, xcr[m], xcrref[m], xcrdif[m]);
  338|      0|    }
  339|      5|  }
  340|       |
  341|      1|  if (*Class != 'U') {
  342|      1|    printf(" Comparison of RMS-norms of solution error\n");
  343|      1|  } else {
  344|      0|    printf(" RMS-norms of solution error\n");
  345|      0|  }
  346|       |
  347|      6|  for (m = 0; m < 5; m++) {
  348|      5|    if (*Class == 'U') {
  349|      0|      printf("          %2d  %20.13E\n", m+1, xce[m]);
  350|      5|    } else if (xcedif[m] <= epsilon) {
  351|      5|      printf("          %2d  %20.13E%20.13E%20.13E\n", 
  352|      5|          m+1, xce[m], xceref[m], xcedif[m]);
  353|      5|    } else {
  354|      0|      *verified = false;
  355|      0|      printf(" FAILURE: %2d  %20.13E%20.13E%20.13E\n",
  356|      0|          m+1, xce[m], xceref[m], xcedif[m]);
  357|      0|    }
  358|      5|  }
  359|       |
  360|      1|  if (*Class != 'U') {
  361|      1|    printf(" Comparison of surface integral\n");
  362|      1|  } else {
  363|      0|    printf(" Surface integral\n");
  364|      0|  }
  365|       |
  366|      1|  if (*Class == 'U') {
  367|      0|    printf("              %20.13E\n", xci);
  368|      1|  } else if (xcidif <= epsilon) {
  369|      1|    printf("              %20.13E%20.13E%20.13E\n", xci, xciref, xcidif);
  370|      1|  } else {
  371|      0|    *verified = false;
  372|      0|    printf(" FAILURE:     %20.13E%20.13E%20.13E\n", xci, xciref, xcidif);
  373|      0|  }
  374|       |
  375|      1|  if (*Class == 'U') {
  376|      0|    printf(" No reference values provided\n");
  377|      0|    printf("No verification performed\n");
  378|      1|  } else if (*verified) {
  379|      1|    printf(" Verification Successful\n");
  380|      1|  } else {
  381|      0|    printf(" Verification failed\n");
  382|      0|  }
  383|      1|}
  384|       |

/home/dvmuser3/andrey/npb-3.3-c/common/c_timers.c:
    1|       |#include "wtime.h"
    2|       |#include <stdlib.h>
    3|       |
    4|       |/*  Prototype  */
    5|       |void wtime( double * );
    6|       |
    7|       |
    8|       |/*****************************************************************/
    9|       |/******         E  L  A  P  S  E  D  _  T  I  M  E          ******/
   10|       |/*****************************************************************/
   11|       |static double elapsed_time( void )
   12|      4|{
   13|      4|    double t;
   14|       |
   15|      4|    wtime( &t );
   16|      4|    return( t );
   17|      4|}
   18|       |
   19|       |
   20|       |static double start[64], elapsed[64];
   21|       |
   22|       |/*****************************************************************/
   23|       |/******            T  I  M  E  R  _  C  L  E  A  R          ******/
   24|       |/*****************************************************************/
   25|       |void timer_clear( int n )
   26|     44|{
   27|     44|    elapsed[n] = 0.0;
   28|     44|}
   29|       |
   30|       |
   31|       |/*****************************************************************/
   32|       |/******            T  I  M  E  R  _  S  T  A  R  T          ******/
   33|       |/*****************************************************************/
   34|       |void timer_start( int n )
   35|      2|{
   36|      2|    start[n] = elapsed_time();
   37|      2|}
   38|       |
   39|       |
   40|       |/*****************************************************************/
   41|       |/******            T  I  M  E  R  _  S  T  O  P             ******/
   42|       |/*****************************************************************/
   43|       |void timer_stop( int n )
   44|      2|{
   45|      2|    double t, now;
   46|       |
   47|      2|    now = elapsed_time();
   48|      2|    t = now - start[n];
   49|      2|    elapsed[n] += t;
   50|       |
   51|      2|}
   52|       |
   53|       |
   54|       |/*****************************************************************/
   55|       |/******            T  I  M  E  R  _  R  E  A  D             ******/
   56|       |/*****************************************************************/
   57|       |double timer_read( int n )
   58|      2|{
   59|      2|    return( elapsed[n] );
   60|      2|}
   61|       |

/home/dvmuser3/andrey/npb-3.3-c/common/print_results.c:
    1|       |#include <stdio.h>
    2|       |#include <math.h>
    3|       |#include "type.h"
    4|       |
    5|       |
    6|       |void print_results(char *name, char class, int n1, int n2, int n3, int niter,
    7|       |    double t, double mops, char *optype, logical verified, char *npbversion,
    8|       |    char *compiletime, char *cs1, char *cs2, char *cs3, char *cs4, char *cs5,
    9|       |    char *cs6, char *cs7) 
   10|      1|{
   11|      1|  char size[16];
   12|      1|  int j;
   13|       |
   14|      1|  printf( "\n\n %s Benchmark Completed.\n", name );
   15|      1|  printf( " Class           =             %12c\n", class );
   16|       |
   17|       |  // If this is not a grid-based problem (EP, FT, CG), then
   18|       |  // we only print n1, which contains some measure of the
   19|       |  // problem size. In that case, n2 and n3 are both zero.
   20|       |  // Otherwise, we print the grid size n1xn2xn3
   21|       |
   22|      1|  if ( ( n2 == 0 ) && ( n3 == 0 ) ) {
   23|      0|    if ( ( name[0] == 'E' ) && ( name[1] == 'P' ) ) {
   24|      0|      sprintf( size, "%15.0lf", pow(2.0, n1) );
   25|      0|      j = 14;
   26|      0|      if ( size[j] == '.' ) {
   27|      0|        size[j] = ' '; 
   28|      0|        j--;
   29|      0|      }
   30|      0|      size[j+1] = '\0';
   31|      0|      printf( " Size            =          %15s\n", size );
   32|      0|    } else {
   33|      0|      printf( " Size            =             %12d\n", n1 );
   34|      0|    }
   35|      1|  } else {
   36|      1|    printf( " Size            =           %4dx%4dx%4d\n", n1, n2, n3 );
   37|      1|  }
   38|       |
   39|      1|  printf( " Iterations      =             %12d\n", niter );
   40|      1|  printf( " Time in seconds =             %12.2lf\n", t );
   41|      1|  printf( " Mop/s total     =          %15.2lf\n", mops );
   42|      1|  printf( " Operation type  = %24s\n", optype );
   43|      1|  if ( verified ) 
   44|      1|    printf( " Verification    =             %12s\n", "SUCCESSFUL" );
   45|      0|  else
   46|      0|    printf( " Verification    =             %12s\n", "UNSUCCESSFUL" );
   47|      1|  printf( " Version         =             %12s\n", npbversion );
   48|      1|  printf( " Compile date    =             %12s\n", compiletime );
   49|       |  
   50|      1|  printf( "\n Compile options:\n"
   51|      1|          "    CC           = %s\n", cs1 );
   52|      1|  printf( "    CLINK        = %s\n", cs2 );
   53|      1|  printf( "    C_LIB        = %s\n", cs3 );
   54|      1|  printf( "    C_INC        = %s\n", cs4 );
   55|      1|  printf( "    CFLAGS       = %s\n", cs5 );
   56|      1|  printf( "    CLINKFLAGS   = %s\n", cs6 );
   57|      1|  printf( "    RAND         = %s\n", cs7 );
   58|       |
   59|      1|  printf( "\n--------------------------------------\n"
   60|      1|          " Please send all errors/feedbacks to:\n"
   61|      1|          " Center for Manycore Programming\n"
   62|      1|          " cmp@aces.snu.ac.kr\n"
   63|      1|          " http://aces.snu.ac.kr\n"
   64|      1|          "--------------------------------------\n\n");
   65|      1|}

/home/dvmuser3/andrey/npb-3.3-c/common/type.h:
    1|       |#ifndef __TYPE_H__
    2|       |#define __TYPE_H__
    3|       |
    4|       |typedef enum { false, true } logical;
    5|       |typedef struct { 
    6|       |  double real;
    7|       |  double imag;
    8|       |} dcomplex;
    9|       |
   10|       |
   11|       |#define min(x,y)    ((x) < (y) ? (x) : (y))
   12|      2|#define max(x,y)    ((x) > (y) ? (x) : (y))
   13|       |
   14|       |#endif //__TYPE_H__

/home/dvmuser3/andrey/npb-3.3-c/common/wtime.c:
    1|       |#include "wtime.h"
    2|       |#include <time.h>
    3|       |#ifndef DOS
    4|       |#include <sys/time.h>
    5|       |#endif
    6|       |
    7|       |void wtime(double *t)
    8|      4|{
    9|      4|  static int sec = -1;
   10|      4|  struct timeval tv;
   11|      4|  gettimeofday(&tv, (void *)0);
   12|      4|  if (sec < 0) sec = tv.tv_sec;
   13|      4|  *t = (tv.tv_sec - sec) + 1.0e-6*tv.tv_usec;
   14|      4|}
   15|       |
   16|       |    

/home/dvmuser3/andrey/npb-3.3-c/common/wtime.h:
    1|       |/* C/Fortran interface is different on different machines. 
    2|       | * You may need to tweak this.
    3|       | */
    4|       |
    5|       |
    6|       |#if defined(IBM)
    7|       |#define wtime wtime
    8|       |#elif defined(CRAY)
    9|       |#define wtime WTIME
   10|       |#else
   11|      4|#define wtime wtime_
   12|       |#endif

