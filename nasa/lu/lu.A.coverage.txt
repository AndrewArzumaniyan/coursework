/home/dvmuser3/andrey/npb-3.3-c/LU/applu.incl:
    1|       |//---------------------------------------------------------------------
    2|       |//---------------------------------------------------------------------
    3|       |//---  applu.incl   
    4|       |//---------------------------------------------------------------------
    5|       |//---------------------------------------------------------------------
    6|       |
    7|       |//---------------------------------------------------------------------
    8|       |// npbparams.h defines parameters that depend on the class and 
    9|       |// number of nodes
   10|       |//---------------------------------------------------------------------
   11|       |
   12|       |#include "npbparams.h"
   13|       |#include "type.h"
   14|       |
   15|       |//---------------------------------------------------------------------
   16|       |// parameters which can be overridden in runtime config file
   17|       |// isiz1,isiz2,isiz3 give the maximum size
   18|       |// ipr = 1 to print out verbose information
   19|       |// omega = 2.0 is correct for all classes
   20|       |// tolrsd is tolerance levels for steady state residuals
   21|       |//---------------------------------------------------------------------
   22|      1|#define IPR_DEFAULT     1
   23|      1|#define OMEGA_DEFAULT   1.2
   24|      1|#define TOLRSD1_DEF     1.0e-08
   25|      1|#define TOLRSD2_DEF     1.0e-08
   26|      1|#define TOLRSD3_DEF     1.0e-08
   27|      1|#define TOLRSD4_DEF     1.0e-08
   28|      1|#define TOLRSD5_DEF     1.0e-08
   29|       |
   30|  1.63G|#define C1              1.40e+00
   31|  3.60G|#define C2              0.40e+00
   32|   726M|#define C3              1.00e-01
   33|   726M|#define C4              1.00e+00
   34|   369M|#define C5              1.40e+00
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// grid
   38|       |//---------------------------------------------------------------------
   39|       |/* common/cgcon/ */
   40|       |extern double dxi, deta, dzeta;
   41|       |extern double tx1, tx2, tx3;
   42|       |extern double ty1, ty2, ty3;
   43|       |extern double tz1, tz2, tz3;
   44|       |extern int nx, ny, nz;
   45|       |extern int nx0, ny0, nz0;
   46|       |extern int ist, iend;
   47|       |extern int jst, jend;
   48|       |extern int ii1, ii2;
   49|       |extern int ji1, ji2;
   50|       |extern int ki1, ki2;
   51|       |
   52|       |//---------------------------------------------------------------------
   53|       |// dissipation
   54|       |//---------------------------------------------------------------------
   55|       |/* common/disp/ */
   56|       |extern double dx1, dx2, dx3, dx4, dx5;
   57|       |extern double dy1, dy2, dy3, dy4, dy5;
   58|       |extern double dz1, dz2, dz3, dz4, dz5;
   59|       |extern double dssp;
   60|       |
   61|       |//---------------------------------------------------------------------
   62|       |// field variables and residuals
   63|       |// to improve cache performance, second two dimensions padded by 1 
   64|       |// for even number sizes only.
   65|       |// Note: corresponding array (called "v") in routines blts, buts, 
   66|       |// and l2norm are similarly padded
   67|       |//---------------------------------------------------------------------
   68|       |/* common/cvar/ */
   69|       |extern double u    [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   70|       |extern double rsd  [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   71|       |extern double frct [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   72|       |extern double flux [ISIZ1][5];
   73|       |extern double qs   [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
   74|       |extern double rho_i[ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
   75|       |
   76|       |//---------------------------------------------------------------------
   77|       |// output control parameters
   78|       |//---------------------------------------------------------------------
   79|       |/* common/cprcon/ */
   80|       |extern int ipr, inorm;
   81|       |
   82|       |//---------------------------------------------------------------------
   83|       |// newton-raphson iteration control parameters
   84|       |//---------------------------------------------------------------------
   85|       |/* common/ctscon/ */
   86|       |extern double dt, omega, tolrsd[5], rsdnm[5], errnm[5], frc, ttotal;
   87|       |extern int itmax, invert;
   88|       |
   89|       |/* common/cjac/ */
   90|       |extern double a[ISIZ2][ISIZ1/2*2+1][5][5];
   91|       |extern double b[ISIZ2][ISIZ1/2*2+1][5][5];
   92|       |extern double c[ISIZ2][ISIZ1/2*2+1][5][5];
   93|       |extern double d[ISIZ2][ISIZ1/2*2+1][5][5];
   94|       |
   95|       |
   96|       |//---------------------------------------------------------------------
   97|       |// coefficients of the exact solution
   98|       |//---------------------------------------------------------------------
   99|       |/* common/cexact/ */
  100|       |extern double ce[5][13];
  101|       |
  102|       |
  103|       |//---------------------------------------------------------------------
  104|       |// timers
  105|       |//---------------------------------------------------------------------
  106|       |/* common/timer/ */
  107|       |extern double maxtime;
  108|       |extern logical timeron;
  109|      0|#define t_total   1
  110|      0|#define t_rhsx    2
  111|      0|#define t_rhsy    3
  112|      0|#define t_rhsz    4
  113|      0|#define t_rhs     5
  114|      0|#define t_jacld   6
  115|      0|#define t_blts    7
  116|      0|#define t_jacu    8
  117|      0|#define t_buts    9
  118|      0|#define t_add     10
  119|      0|#define t_l2norm  11
  120|     48|#define t_last    11
  121|       |
  122|       |
  123|       |void read_input();
  124|       |void domain();
  125|       |void setcoeff();
  126|       |void setbv();
  127|       |void exact(int i, int j, int k, double u000ijk[]);
  128|       |void setiv();
  129|       |void erhs();
  130|       |void ssor(int niter);
  131|       |void rhs();
  132|       |void l2norm (int ldx, int ldy, int ldz, int nx0, int ny0, int nz0,
  133|       |     int ist, int iend, int jst, int jend,
  134|       |     double v[][ldy/2*2+1][ldx/2*2+1][5], double sum[5]);
  135|       |void jacld(int k);
  136|       |void blts (int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
  137|       |    double omega,
  138|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5], 
  139|       |    double ldz[ldmy][ldmx/2*2+1][5][5],
  140|       |    double ldy[ldmy][ldmx/2*2+1][5][5],
  141|       |    double ldx[ldmy][ldmx/2*2+1][5][5],
  142|       |    double d[ldmy][ldmx/2*2+1][5][5],
  143|       |    int ist, int iend, int jst, int jend, int nx0, int ny0);
  144|       |void jacu(int k);
  145|       |void buts(int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
  146|       |    double omega,
  147|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5],
  148|       |    double tv[ldmy][ldmx/2*2+1][5],
  149|       |    double d[ldmy][ldmx/2*2+1][5][5],
  150|       |    double udx[ldmy][ldmx/2*2+1][5][5],
  151|       |    double udy[ldmy][ldmx/2*2+1][5][5],
  152|       |    double udz[ldmy][ldmx/2*2+1][5][5],
  153|       |    int ist, int iend, int jst, int jend, int nx0, int ny0);
  154|       |void error();
  155|       |void pintgr();
  156|       |void verify(double xcr[5], double xce[5], double xci, 
  157|       |            char *Class, logical *verified);
  158|       |
  159|       |
  160|       |//---------------------------------------------------------------------
  161|       |//   end of include file
  162|       |//---------------------------------------------------------------------

/home/dvmuser3/andrey/npb-3.3-c/LU/blts.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |//---------------------------------------------------------------------
   35|       |// 
   36|       |// compute the regular-sparse, block lower triangular solution:
   37|       |// 
   38|       |// v <-- ( L-inv ) * v
   39|       |// 
   40|       |//---------------------------------------------------------------------
   41|       |//---------------------------------------------------------------------
   42|       |// To improve cache performance, second two dimensions padded by 1 
   43|       |// for even number sizes only.  Only needed in v.
   44|       |//---------------------------------------------------------------------
   45|       |void blts (int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
   46|       |    double omega,
   47|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5], 
   48|       |    double ldz[ldmy][ldmx/2*2+1][5][5],
   49|       |    double ldy[ldmy][ldmx/2*2+1][5][5],
   50|       |    double ldx[ldmy][ldmx/2*2+1][5][5],
   51|       |    double d[ldmy][ldmx/2*2+1][5][5],
   52|       |    int ist, int iend, int jst, int jend, int nx0, int ny0)
   53|  15.5k|{
   54|       |  //---------------------------------------------------------------------
   55|       |  // local variables
   56|       |  //---------------------------------------------------------------------
   57|  15.5k|  int i, j, m;
   58|  15.5k|  double tmp, tmp1;
   59|  15.5k|  double tmat[5][5], tv[5];
   60|       |
   61|       |  // Since gcc 4.4.3 generates the following warning for v:
   62|       |  // warning: '({anonymous})' may be used uninitialized in this function
   63|       |  // we use casted pointers.
   64|  15.5k|  double (*vk)[ldmx/2*2+1][5] = v[k];
   65|  15.5k|  double (*vkm1)[ldmx/2*2+1][5] = v[k-1];
   66|       |
   67|   980k|  for (j = jst; j < jend; j++) {
   68|  60.7M|    for (i = ist; i < iend; i++) {
   69|   358M|      for (m = 0; m < 5; m++) {
   70|   299M|        vk[j][i][m] =  vk[j][i][m]
   71|   299M|          - omega * (  ldz[j][i][0][m] * vkm1[j][i][0]
   72|   299M|                     + ldz[j][i][1][m] * vkm1[j][i][1]
   73|   299M|                     + ldz[j][i][2][m] * vkm1[j][i][2]
   74|   299M|                     + ldz[j][i][3][m] * vkm1[j][i][3]
   75|   299M|                     + ldz[j][i][4][m] * vkm1[j][i][4] );
   76|   299M|      }
   77|  59.8M|    }
   78|   964k|  }
   79|       |
   80|   980k|  for (j = jst; j < jend; j++) {
   81|  60.7M|    for (i = ist; i < iend; i++) {
   82|   358M|      for (m = 0; m < 5; m++) {
   83|   299M|        tv[m] =  vk[j][i][m]
   84|   299M|          - omega * ( ldy[j][i][0][m] * vk[j-1][i][0]
   85|   299M|                    + ldx[j][i][0][m] * vk[j][i-1][0]
   86|   299M|                    + ldy[j][i][1][m] * vk[j-1][i][1]
   87|   299M|                    + ldx[j][i][1][m] * vk[j][i-1][1]
   88|   299M|                    + ldy[j][i][2][m] * vk[j-1][i][2]
   89|   299M|                    + ldx[j][i][2][m] * vk[j][i-1][2]
   90|   299M|                    + ldy[j][i][3][m] * vk[j-1][i][3]
   91|   299M|                    + ldx[j][i][3][m] * vk[j][i-1][3]
   92|   299M|                    + ldy[j][i][4][m] * vk[j-1][i][4]
   93|   299M|                    + ldx[j][i][4][m] * vk[j][i-1][4] );
   94|   299M|      }
   95|       |
   96|       |      //---------------------------------------------------------------------
   97|       |      // diagonal block inversion
   98|       |      // 
   99|       |      // forward elimination
  100|       |      //---------------------------------------------------------------------
  101|   358M|      for (m = 0; m < 5; m++) {
  102|   299M|        tmat[m][0] = d[j][i][0][m];
  103|   299M|        tmat[m][1] = d[j][i][1][m];
  104|   299M|        tmat[m][2] = d[j][i][2][m];
  105|   299M|        tmat[m][3] = d[j][i][3][m];
  106|   299M|        tmat[m][4] = d[j][i][4][m];
  107|   299M|      }
  108|       |
  109|  59.8M|      tmp1 = 1.0 / tmat[0][0];
  110|  59.8M|      tmp = tmp1 * tmat[1][0];
  111|  59.8M|      tmat[1][1] =  tmat[1][1] - tmp * tmat[0][1];
  112|  59.8M|      tmat[1][2] =  tmat[1][2] - tmp * tmat[0][2];
  113|  59.8M|      tmat[1][3] =  tmat[1][3] - tmp * tmat[0][3];
  114|  59.8M|      tmat[1][4] =  tmat[1][4] - tmp * tmat[0][4];
  115|  59.8M|      tv[1] = tv[1] - tv[0] * tmp;
  116|       |
  117|  59.8M|      tmp = tmp1 * tmat[2][0];
  118|  59.8M|      tmat[2][1] =  tmat[2][1] - tmp * tmat[0][1];
  119|  59.8M|      tmat[2][2] =  tmat[2][2] - tmp * tmat[0][2];
  120|  59.8M|      tmat[2][3] =  tmat[2][3] - tmp * tmat[0][3];
  121|  59.8M|      tmat[2][4] =  tmat[2][4] - tmp * tmat[0][4];
  122|  59.8M|      tv[2] = tv[2] - tv[0] * tmp;
  123|       |
  124|  59.8M|      tmp = tmp1 * tmat[3][0];
  125|  59.8M|      tmat[3][1] =  tmat[3][1] - tmp * tmat[0][1];
  126|  59.8M|      tmat[3][2] =  tmat[3][2] - tmp * tmat[0][2];
  127|  59.8M|      tmat[3][3] =  tmat[3][3] - tmp * tmat[0][3];
  128|  59.8M|      tmat[3][4] =  tmat[3][4] - tmp * tmat[0][4];
  129|  59.8M|      tv[3] = tv[3] - tv[0] * tmp;
  130|       |
  131|  59.8M|      tmp = tmp1 * tmat[4][0];
  132|  59.8M|      tmat[4][1] =  tmat[4][1] - tmp * tmat[0][1];
  133|  59.8M|      tmat[4][2] =  tmat[4][2] - tmp * tmat[0][2];
  134|  59.8M|      tmat[4][3] =  tmat[4][3] - tmp * tmat[0][3];
  135|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[0][4];
  136|  59.8M|      tv[4] = tv[4] - tv[0] * tmp;
  137|       |
  138|  59.8M|      tmp1 = 1.0 / tmat[1][1];
  139|  59.8M|      tmp = tmp1 * tmat[2][1];
  140|  59.8M|      tmat[2][2] =  tmat[2][2] - tmp * tmat[1][2];
  141|  59.8M|      tmat[2][3] =  tmat[2][3] - tmp * tmat[1][3];
  142|  59.8M|      tmat[2][4] =  tmat[2][4] - tmp * tmat[1][4];
  143|  59.8M|      tv[2] = tv[2] - tv[1] * tmp;
  144|       |
  145|  59.8M|      tmp = tmp1 * tmat[3][1];
  146|  59.8M|      tmat[3][2] =  tmat[3][2] - tmp * tmat[1][2];
  147|  59.8M|      tmat[3][3] =  tmat[3][3] - tmp * tmat[1][3];
  148|  59.8M|      tmat[3][4] =  tmat[3][4] - tmp * tmat[1][4];
  149|  59.8M|      tv[3] = tv[3] - tv[1] * tmp;
  150|       |
  151|  59.8M|      tmp = tmp1 * tmat[4][1];
  152|  59.8M|      tmat[4][2] =  tmat[4][2] - tmp * tmat[1][2];
  153|  59.8M|      tmat[4][3] =  tmat[4][3] - tmp * tmat[1][3];
  154|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[1][4];
  155|  59.8M|      tv[4] = tv[4] - tv[1] * tmp;
  156|       |
  157|  59.8M|      tmp1 = 1.0 / tmat[2][2];
  158|  59.8M|      tmp = tmp1 * tmat[3][2];
  159|  59.8M|      tmat[3][3] =  tmat[3][3] - tmp * tmat[2][3];
  160|  59.8M|      tmat[3][4] =  tmat[3][4] - tmp * tmat[2][4];
  161|  59.8M|      tv[3] = tv[3] - tv[2] * tmp;
  162|       |
  163|  59.8M|      tmp = tmp1 * tmat[4][2];
  164|  59.8M|      tmat[4][3] =  tmat[4][3] - tmp * tmat[2][3];
  165|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[2][4];
  166|  59.8M|      tv[4] = tv[4] - tv[2] * tmp;
  167|       |
  168|  59.8M|      tmp1 = 1.0 / tmat[3][3];
  169|  59.8M|      tmp = tmp1 * tmat[4][3];
  170|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[3][4];
  171|  59.8M|      tv[4] = tv[4] - tv[3] * tmp;
  172|       |
  173|       |      //---------------------------------------------------------------------
  174|       |      // back substitution
  175|       |      //---------------------------------------------------------------------
  176|  59.8M|      vk[j][i][4] = tv[4] / tmat[4][4];
  177|       |
  178|  59.8M|      tv[3] = tv[3] 
  179|  59.8M|        - tmat[3][4] * vk[j][i][4];
  180|  59.8M|      vk[j][i][3] = tv[3] / tmat[3][3];
  181|       |
  182|  59.8M|      tv[2] = tv[2]
  183|  59.8M|        - tmat[2][3] * vk[j][i][3]
  184|  59.8M|        - tmat[2][4] * vk[j][i][4];
  185|  59.8M|      vk[j][i][2] = tv[2] / tmat[2][2];
  186|       |
  187|  59.8M|      tv[1] = tv[1]
  188|  59.8M|        - tmat[1][2] * vk[j][i][2]
  189|  59.8M|        - tmat[1][3] * vk[j][i][3]
  190|  59.8M|        - tmat[1][4] * vk[j][i][4];
  191|  59.8M|      vk[j][i][1] = tv[1] / tmat[1][1];
  192|       |
  193|  59.8M|      tv[0] = tv[0]
  194|  59.8M|        - tmat[0][1] * vk[j][i][1]
  195|  59.8M|        - tmat[0][2] * vk[j][i][2]
  196|  59.8M|        - tmat[0][3] * vk[j][i][3]
  197|  59.8M|        - tmat[0][4] * vk[j][i][4];
  198|  59.8M|      vk[j][i][0] = tv[0] / tmat[0][0];
  199|  59.8M|    }
  200|   964k|  }
  201|  15.5k|}
  202|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/buts.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |//---------------------------------------------------------------------
   35|       |// 
   36|       |// compute the regular-sparse, block upper triangular solution:
   37|       |// 
   38|       |// v <-- ( U-inv ) * v
   39|       |// 
   40|       |//---------------------------------------------------------------------
   41|       |//---------------------------------------------------------------------
   42|       |// To improve cache performance, second two dimensions padded by 1 
   43|       |// for even number sizes only.  Only needed in v.
   44|       |//---------------------------------------------------------------------
   45|       |void buts(int ldmx, int ldmy, int ldmz, int nx, int ny, int nz, int k,
   46|       |    double omega,
   47|       |    double v[][ldmy/2*2+1][ldmx/2*2+1][5],
   48|       |    double tv[ldmy][ldmx/2*2+1][5],
   49|       |    double d[ldmy][ldmx/2*2+1][5][5],
   50|       |    double udx[ldmy][ldmx/2*2+1][5][5],
   51|       |    double udy[ldmy][ldmx/2*2+1][5][5],
   52|       |    double udz[ldmy][ldmx/2*2+1][5][5],
   53|       |    int ist, int iend, int jst, int jend, int nx0, int ny0)
   54|  15.5k|{
   55|       |  //---------------------------------------------------------------------
   56|       |  // local variables
   57|       |  //---------------------------------------------------------------------
   58|  15.5k|  int i, j, m;
   59|  15.5k|  double tmp, tmp1;
   60|  15.5k|  double tmat[5][5];
   61|       |
   62|   980k|  for (j = jend - 1; j >= jst; j--) {
   63|  60.7M|    for (i = iend - 1; i >= ist; i--) {
   64|   358M|      for (m = 0; m < 5; m++) {
   65|   299M|        tv[j][i][m] = 
   66|   299M|          omega * (  udz[j][i][0][m] * v[k+1][j][i][0]
   67|   299M|                   + udz[j][i][1][m] * v[k+1][j][i][1]
   68|   299M|                   + udz[j][i][2][m] * v[k+1][j][i][2]
   69|   299M|                   + udz[j][i][3][m] * v[k+1][j][i][3]
   70|   299M|                   + udz[j][i][4][m] * v[k+1][j][i][4] );
   71|   299M|      }
   72|  59.8M|    }
   73|   964k|  }
   74|       |
   75|   980k|  for (j = jend - 1; j >= jst; j--) {
   76|  60.7M|    for (i = iend - 1; i >= ist; i--) {
   77|   358M|      for (m = 0; m < 5; m++) {
   78|   299M|        tv[j][i][m] = tv[j][i][m]
   79|   299M|          + omega * ( udy[j][i][0][m] * v[k][j+1][i][0]
   80|   299M|                    + udx[j][i][0][m] * v[k][j][i+1][0]
   81|   299M|                    + udy[j][i][1][m] * v[k][j+1][i][1]
   82|   299M|                    + udx[j][i][1][m] * v[k][j][i+1][1]
   83|   299M|                    + udy[j][i][2][m] * v[k][j+1][i][2]
   84|   299M|                    + udx[j][i][2][m] * v[k][j][i+1][2]
   85|   299M|                    + udy[j][i][3][m] * v[k][j+1][i][3]
   86|   299M|                    + udx[j][i][3][m] * v[k][j][i+1][3]
   87|   299M|                    + udy[j][i][4][m] * v[k][j+1][i][4]
   88|   299M|                    + udx[j][i][4][m] * v[k][j][i+1][4] );
   89|   299M|      }
   90|       |
   91|       |      //---------------------------------------------------------------------
   92|       |      // diagonal block inversion
   93|       |      //---------------------------------------------------------------------
   94|   358M|      for (m = 0; m < 5; m++) {
   95|   299M|        tmat[m][0] = d[j][i][0][m];
   96|   299M|        tmat[m][1] = d[j][i][1][m];
   97|   299M|        tmat[m][2] = d[j][i][2][m];
   98|   299M|        tmat[m][3] = d[j][i][3][m];
   99|   299M|        tmat[m][4] = d[j][i][4][m];
  100|   299M|      }
  101|       |
  102|  59.8M|      tmp1 = 1.0 / tmat[0][0];
  103|  59.8M|      tmp = tmp1 * tmat[1][0];
  104|  59.8M|      tmat[1][1] =  tmat[1][1] - tmp * tmat[0][1];
  105|  59.8M|      tmat[1][2] =  tmat[1][2] - tmp * tmat[0][2];
  106|  59.8M|      tmat[1][3] =  tmat[1][3] - tmp * tmat[0][3];
  107|  59.8M|      tmat[1][4] =  tmat[1][4] - tmp * tmat[0][4];
  108|  59.8M|      tv[j][i][1] = tv[j][i][1] - tv[j][i][0] * tmp;
  109|       |
  110|  59.8M|      tmp = tmp1 * tmat[2][0];
  111|  59.8M|      tmat[2][1] =  tmat[2][1] - tmp * tmat[0][1];
  112|  59.8M|      tmat[2][2] =  tmat[2][2] - tmp * tmat[0][2];
  113|  59.8M|      tmat[2][3] =  tmat[2][3] - tmp * tmat[0][3];
  114|  59.8M|      tmat[2][4] =  tmat[2][4] - tmp * tmat[0][4];
  115|  59.8M|      tv[j][i][2] = tv[j][i][2] - tv[j][i][0] * tmp;
  116|       |
  117|  59.8M|      tmp = tmp1 * tmat[3][0];
  118|  59.8M|      tmat[3][1] =  tmat[3][1] - tmp * tmat[0][1];
  119|  59.8M|      tmat[3][2] =  tmat[3][2] - tmp * tmat[0][2];
  120|  59.8M|      tmat[3][3] =  tmat[3][3] - tmp * tmat[0][3];
  121|  59.8M|      tmat[3][4] =  tmat[3][4] - tmp * tmat[0][4];
  122|  59.8M|      tv[j][i][3] = tv[j][i][3] - tv[j][i][0] * tmp;
  123|       |
  124|  59.8M|      tmp = tmp1 * tmat[4][0];
  125|  59.8M|      tmat[4][1] =  tmat[4][1] - tmp * tmat[0][1];
  126|  59.8M|      tmat[4][2] =  tmat[4][2] - tmp * tmat[0][2];
  127|  59.8M|      tmat[4][3] =  tmat[4][3] - tmp * tmat[0][3];
  128|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[0][4];
  129|  59.8M|      tv[j][i][4] = tv[j][i][4] - tv[j][i][0] * tmp;
  130|       |
  131|  59.8M|      tmp1 = 1.0 / tmat[1][1];
  132|  59.8M|      tmp = tmp1 * tmat[2][1];
  133|  59.8M|      tmat[2][2] =  tmat[2][2] - tmp * tmat[1][2];
  134|  59.8M|      tmat[2][3] =  tmat[2][3] - tmp * tmat[1][3];
  135|  59.8M|      tmat[2][4] =  tmat[2][4] - tmp * tmat[1][4];
  136|  59.8M|      tv[j][i][2] = tv[j][i][2] - tv[j][i][1] * tmp;
  137|       |
  138|  59.8M|      tmp = tmp1 * tmat[3][1];
  139|  59.8M|      tmat[3][2] =  tmat[3][2] - tmp * tmat[1][2];
  140|  59.8M|      tmat[3][3] =  tmat[3][3] - tmp * tmat[1][3];
  141|  59.8M|      tmat[3][4] =  tmat[3][4] - tmp * tmat[1][4];
  142|  59.8M|      tv[j][i][3] = tv[j][i][3] - tv[j][i][1] * tmp;
  143|       |
  144|  59.8M|      tmp = tmp1 * tmat[4][1];
  145|  59.8M|      tmat[4][2] =  tmat[4][2] - tmp * tmat[1][2];
  146|  59.8M|      tmat[4][3] =  tmat[4][3] - tmp * tmat[1][3];
  147|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[1][4];
  148|  59.8M|      tv[j][i][4] = tv[j][i][4] - tv[j][i][1] * tmp;
  149|       |
  150|  59.8M|      tmp1 = 1.0 / tmat[2][2];
  151|  59.8M|      tmp = tmp1 * tmat[3][2];
  152|  59.8M|      tmat[3][3] =  tmat[3][3] - tmp * tmat[2][3];
  153|  59.8M|      tmat[3][4] =  tmat[3][4] - tmp * tmat[2][4];
  154|  59.8M|      tv[j][i][3] = tv[j][i][3] - tv[j][i][2] * tmp;
  155|       |
  156|  59.8M|      tmp = tmp1 * tmat[4][2];
  157|  59.8M|      tmat[4][3] =  tmat[4][3] - tmp * tmat[2][3];
  158|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[2][4];
  159|  59.8M|      tv[j][i][4] = tv[j][i][4] - tv[j][i][2] * tmp;
  160|       |
  161|  59.8M|      tmp1 = 1.0 / tmat[3][3];
  162|  59.8M|      tmp = tmp1 * tmat[4][3];
  163|  59.8M|      tmat[4][4] =  tmat[4][4] - tmp * tmat[3][4];
  164|  59.8M|      tv[j][i][4] = tv[j][i][4] - tv[j][i][3] * tmp;
  165|       |
  166|       |      //---------------------------------------------------------------------
  167|       |      // back substitution
  168|       |      //---------------------------------------------------------------------
  169|  59.8M|      tv[j][i][4] = tv[j][i][4] / tmat[4][4];
  170|       |
  171|  59.8M|      tv[j][i][3] = tv[j][i][3] - tmat[3][4] * tv[j][i][4];
  172|  59.8M|      tv[j][i][3] = tv[j][i][3] / tmat[3][3];
  173|       |
  174|  59.8M|      tv[j][i][2] = tv[j][i][2]
  175|  59.8M|        - tmat[2][3] * tv[j][i][3]
  176|  59.8M|        - tmat[2][4] * tv[j][i][4];
  177|  59.8M|      tv[j][i][2] = tv[j][i][2] / tmat[2][2];
  178|       |
  179|  59.8M|      tv[j][i][1] = tv[j][i][1]
  180|  59.8M|        - tmat[1][2] * tv[j][i][2]
  181|  59.8M|        - tmat[1][3] * tv[j][i][3]
  182|  59.8M|        - tmat[1][4] * tv[j][i][4];
  183|  59.8M|      tv[j][i][1] = tv[j][i][1] / tmat[1][1];
  184|       |
  185|  59.8M|      tv[j][i][0] = tv[j][i][0]
  186|  59.8M|        - tmat[0][1] * tv[j][i][1]
  187|  59.8M|        - tmat[0][2] * tv[j][i][2]
  188|  59.8M|        - tmat[0][3] * tv[j][i][3]
  189|  59.8M|        - tmat[0][4] * tv[j][i][4];
  190|  59.8M|      tv[j][i][0] = tv[j][i][0] / tmat[0][0];
  191|       |
  192|  59.8M|      v[k][j][i][0] = v[k][j][i][0] - tv[j][i][0];
  193|  59.8M|      v[k][j][i][1] = v[k][j][i][1] - tv[j][i][1];
  194|  59.8M|      v[k][j][i][2] = v[k][j][i][2] - tv[j][i][2];
  195|  59.8M|      v[k][j][i][3] = v[k][j][i][3] - tv[j][i][3];
  196|  59.8M|      v[k][j][i][4] = v[k][j][i][4] - tv[j][i][4];
  197|  59.8M|    }
  198|   964k|  }
  199|  15.5k|}
  200|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/domain.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <stdlib.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |void domain()
   39|      1|{
   40|       |  //---------------------------------------------------------------------
   41|       |  // local variables
   42|       |  //---------------------------------------------------------------------
   43|      1|  nx = nx0;
   44|      1|  ny = ny0;
   45|      1|  nz = nz0;
   46|       |
   47|       |  //---------------------------------------------------------------------
   48|       |  // check the sub-domain size
   49|       |  //---------------------------------------------------------------------
   50|      1|  if ( ( nx < 4 ) || ( ny < 4 ) || ( nz < 4 ) ) {
   51|      0|    printf("     SUBDOMAIN SIZE IS TOO SMALL - \n"
   52|      0|           "     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\n"
   53|      0|           "     SO THAT NX, NY AND NZ ARE GREATER THAN OR EQUAL\n"
   54|      0|           "     TO 4 THEY ARE CURRENTLY%3d%3d%3d\n", nx, ny, nz);
   55|      0|    exit(EXIT_FAILURE);
   56|      0|  }
   57|       |
   58|      1|  if ( ( nx > ISIZ1 ) || ( ny > ISIZ2 ) || ( nz > ISIZ3 ) ) {
   59|      0|    printf("     SUBDOMAIN SIZE IS TOO LARGE - \n"
   60|      0|           "     ADJUST PROBLEM SIZE OR NUMBER OF PROCESSORS\n"
   61|      0|           "     SO THAT NX, NY AND NZ ARE LESS THAN OR EQUAL TO \n"
   62|      0|           "     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY.  THEY ARE\n"
   63|      0|           "     CURRENTLYi%4d%4d%4d\n", nx, ny, nz);
   64|      0|    exit(EXIT_FAILURE);
   65|      0|  }
   66|       |
   67|       |  //---------------------------------------------------------------------
   68|       |  // set up the start and end in i and j extents for all processors
   69|       |  //---------------------------------------------------------------------
   70|      1|  ist = 1;
   71|      1|  iend = nx - 1;
   72|       |
   73|      1|  jst = 1;
   74|      1|  jend = ny - 1;
   75|       |
   76|      1|  ii1 = 1;
   77|      1|  ii2 = nx0 - 1;
   78|      1|  ji1 = 1;
   79|      1|  ji2 = ny0 - 2;
   80|      1|  ki1 = 2;
   81|      1|  ki2 = nz0 - 1;
   82|      1|}

/home/dvmuser3/andrey/npb-3.3-c/LU/erhs.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |//
   38|       |// compute the right hand side based on exact solution
   39|       |//
   40|       |//---------------------------------------------------------------------
   41|       |void erhs()
   42|      1|{
   43|       |  //---------------------------------------------------------------------
   44|       |  // local variables
   45|       |  //---------------------------------------------------------------------
   46|      1|  int i, j, k, m;
   47|      1|  double xi, eta, zeta;
   48|      1|  double q;
   49|      1|  double u21, u31, u41;
   50|      1|  double tmp;
   51|      1|  double u21i, u31i, u41i, u51i;
   52|      1|  double u21j, u31j, u41j, u51j;
   53|      1|  double u21k, u31k, u41k, u51k;
   54|      1|  double u21im1, u31im1, u41im1, u51im1;
   55|      1|  double u21jm1, u31jm1, u41jm1, u51jm1;
   56|      1|  double u21km1, u31km1, u41km1, u51km1;
   57|       |
   58|     65|  for (k = 0; k < nz; k++) {
   59|  4.16k|    for (j = 0; j < ny; j++) {
   60|   266k|      for (i = 0; i < nx; i++) {
   61|  1.57M|        for (m = 0; m < 5; m++) {
   62|  1.31M|          frct[k][j][i][m] = 0.0;
   63|  1.31M|        }
   64|   262k|      }
   65|  4.09k|    }
   66|     64|  }
   67|       |
   68|     65|  for (k = 0; k < nz; k++) {
   69|     64|    zeta = ( (double)k ) / ( nz - 1 );
   70|  4.16k|    for (j = 0; j < ny; j++) {
   71|  4.09k|      eta = ( (double)j ) / ( ny0 - 1 );
   72|   266k|      for (i = 0; i < nx; i++) {
   73|   262k|        xi = ( (double)i ) / ( nx0 - 1 );
   74|  1.57M|        for (m = 0; m < 5; m++) {
   75|  1.31M|          rsd[k][j][i][m] =  ce[m][0]
   76|  1.31M|            + (ce[m][1]
   77|  1.31M|            + (ce[m][4]
   78|  1.31M|            + (ce[m][7]
   79|  1.31M|            +  ce[m][10] * xi) * xi) * xi) * xi
   80|  1.31M|            + (ce[m][2]
   81|  1.31M|            + (ce[m][5]
   82|  1.31M|            + (ce[m][8]
   83|  1.31M|            +  ce[m][11] * eta) * eta) * eta) * eta
   84|  1.31M|            + (ce[m][3]
   85|  1.31M|            + (ce[m][6]
   86|  1.31M|            + (ce[m][9]
   87|  1.31M|            +  ce[m][12] * zeta) * zeta) * zeta) * zeta;
   88|  1.31M|        }
   89|   262k|      }
   90|  4.09k|    }
   91|     64|  }
   92|       |
   93|       |  //---------------------------------------------------------------------
   94|       |  // xi-direction flux differences
   95|       |  //---------------------------------------------------------------------
   96|     63|  for (k = 1; k < nz - 1; k++) {
   97|  3.90k|    for (j = jst; j < jend; j++) {
   98|   249k|      for (i = 0; i < nx; i++) {
   99|   246k|        flux[i][0] = rsd[k][j][i][1];
  100|   246k|        u21 = rsd[k][j][i][1] / rsd[k][j][i][0];
  101|   246k|        q = 0.50 * (  rsd[k][j][i][1] * rsd[k][j][i][1]
  102|   246k|                    + rsd[k][j][i][2] * rsd[k][j][i][2]
  103|   246k|                    + rsd[k][j][i][3] * rsd[k][j][i][3] )
  104|   246k|                 / rsd[k][j][i][0];
  105|   246k|        flux[i][1] = rsd[k][j][i][1] * u21 + C2 * ( rsd[k][j][i][4] - q );
  106|   246k|        flux[i][2] = rsd[k][j][i][2] * u21;
  107|   246k|        flux[i][3] = rsd[k][j][i][3] * u21;
  108|   246k|        flux[i][4] = ( C1 * rsd[k][j][i][4] - C2 * q ) * u21;
  109|   246k|      }
  110|       |
  111|   242k|      for (i = ist; i < iend; i++) {
  112|  1.42M|        for (m = 0; m < 5; m++) {
  113|  1.19M|          frct[k][j][i][m] =  frct[k][j][i][m]
  114|  1.19M|                    - tx2 * ( flux[i+1][m] - flux[i-1][m] );
  115|  1.19M|        }
  116|   238k|      }
  117|   246k|      for (i = ist; i < nx; i++) {
  118|   242k|        tmp = 1.0 / rsd[k][j][i][0];
  119|       |
  120|   242k|        u21i = tmp * rsd[k][j][i][1];
  121|   242k|        u31i = tmp * rsd[k][j][i][2];
  122|   242k|        u41i = tmp * rsd[k][j][i][3];
  123|   242k|        u51i = tmp * rsd[k][j][i][4];
  124|       |
  125|   242k|        tmp = 1.0 / rsd[k][j][i-1][0];
  126|       |
  127|   242k|        u21im1 = tmp * rsd[k][j][i-1][1];
  128|   242k|        u31im1 = tmp * rsd[k][j][i-1][2];
  129|   242k|        u41im1 = tmp * rsd[k][j][i-1][3];
  130|   242k|        u51im1 = tmp * rsd[k][j][i-1][4];
  131|       |
  132|   242k|        flux[i][1] = (4.0/3.0) * tx3 * ( u21i - u21im1 );
  133|   242k|        flux[i][2] = tx3 * ( u31i - u31im1 );
  134|   242k|        flux[i][3] = tx3 * ( u41i - u41im1 );
  135|   242k|        flux[i][4] = 0.50 * ( 1.0 - C1*C5 )
  136|   242k|          * tx3 * ( ( u21i*u21i     + u31i*u31i     + u41i*u41i )
  137|   242k|                  - ( u21im1*u21im1 + u31im1*u31im1 + u41im1*u41im1 ) )
  138|   242k|          + (1.0/6.0)
  139|   242k|          * tx3 * ( u21i*u21i - u21im1*u21im1 )
  140|   242k|          + C1 * C5 * tx3 * ( u51i - u51im1 );
  141|   242k|      }
  142|       |
  143|   242k|      for (i = ist; i < iend; i++) {
  144|   238k|        frct[k][j][i][0] = frct[k][j][i][0]
  145|   238k|          + dx1 * tx1 * (        rsd[k][j][i-1][0]
  146|   238k|                         - 2.0 * rsd[k][j][i][0]
  147|   238k|                         +       rsd[k][j][i+1][0] );
  148|   238k|        frct[k][j][i][1] = frct[k][j][i][1]
  149|   238k|          + tx3 * C3 * C4 * ( flux[i+1][1] - flux[i][1] )
  150|   238k|          + dx2 * tx1 * (        rsd[k][j][i-1][1]
  151|   238k|                         - 2.0 * rsd[k][j][i][1]
  152|   238k|                         +       rsd[k][j][i+1][1] );
  153|   238k|        frct[k][j][i][2] = frct[k][j][i][2]
  154|   238k|          + tx3 * C3 * C4 * ( flux[i+1][2] - flux[i][2] )
  155|   238k|          + dx3 * tx1 * (        rsd[k][j][i-1][2]
  156|   238k|                         - 2.0 * rsd[k][j][i][2]
  157|   238k|                         +       rsd[k][j][i+1][2] );
  158|   238k|        frct[k][j][i][3] = frct[k][j][i][3]
  159|   238k|          + tx3 * C3 * C4 * ( flux[i+1][3] - flux[i][3] )
  160|   238k|          + dx4 * tx1 * (        rsd[k][j][i-1][3]
  161|   238k|                         - 2.0 * rsd[k][j][i][3]
  162|   238k|                         +       rsd[k][j][i+1][3] );
  163|   238k|        frct[k][j][i][4] = frct[k][j][i][4]
  164|   238k|          + tx3 * C3 * C4 * ( flux[i+1][4] - flux[i][4] )
  165|   238k|          + dx5 * tx1 * (        rsd[k][j][i-1][4]
  166|   238k|                         - 2.0 * rsd[k][j][i][4]
  167|   238k|                         +       rsd[k][j][i+1][4] );
  168|   238k|      }
  169|       |
  170|       |      //---------------------------------------------------------------------
  171|       |      // Fourth-order dissipation
  172|       |      //---------------------------------------------------------------------
  173|  23.0k|      for (m = 0; m < 5; m++) {
  174|  19.2k|        frct[k][j][1][m] = frct[k][j][1][m]
  175|  19.2k|          - dssp * ( + 5.0 * rsd[k][j][1][m]
  176|  19.2k|                     - 4.0 * rsd[k][j][2][m]
  177|  19.2k|                     +       rsd[k][j][3][m] );
  178|  19.2k|        frct[k][j][2][m] = frct[k][j][2][m]
  179|  19.2k|          - dssp * ( - 4.0 * rsd[k][j][1][m]
  180|  19.2k|                     + 6.0 * rsd[k][j][2][m]
  181|  19.2k|                     - 4.0 * rsd[k][j][3][m]
  182|  19.2k|                     +       rsd[k][j][4][m] );
  183|  19.2k|      }
  184|       |
  185|   226k|      for (i = 3; i < nx - 3; i++) {
  186|  1.33M|        for (m = 0; m < 5; m++) {
  187|  1.11M|          frct[k][j][i][m] = frct[k][j][i][m]
  188|  1.11M|            - dssp * (        rsd[k][j][i-2][m]
  189|  1.11M|                      - 4.0 * rsd[k][j][i-1][m]
  190|  1.11M|                      + 6.0 * rsd[k][j][i][m]
  191|  1.11M|                      - 4.0 * rsd[k][j][i+1][m]
  192|  1.11M|                      +       rsd[k][j][i+2][m] );
  193|  1.11M|        }
  194|   222k|      }
  195|       |
  196|  23.0k|      for (m = 0; m < 5; m++) {
  197|  19.2k|        frct[k][j][nx-3][m] = frct[k][j][nx-3][m]
  198|  19.2k|          - dssp * (        rsd[k][j][nx-5][m]
  199|  19.2k|                    - 4.0 * rsd[k][j][nx-4][m]
  200|  19.2k|                    + 6.0 * rsd[k][j][nx-3][m]
  201|  19.2k|                    - 4.0 * rsd[k][j][nx-2][m] );
  202|  19.2k|        frct[k][j][nx-2][m] = frct[k][j][nx-2][m]
  203|  19.2k|          - dssp * (        rsd[k][j][nx-4][m]
  204|  19.2k|                    - 4.0 * rsd[k][j][nx-3][m]
  205|  19.2k|                    + 5.0 * rsd[k][j][nx-2][m] );
  206|  19.2k|      }
  207|  3.84k|    }
  208|     62|  }
  209|       |
  210|       |  //---------------------------------------------------------------------
  211|       |  // eta-direction flux differences
  212|       |  //---------------------------------------------------------------------
  213|     63|  for (k = 1; k < nz - 1; k++) {
  214|  3.90k|    for (i = ist; i < iend; i++) {
  215|   249k|      for (j = 0; j < ny; j++) {
  216|   246k|        flux[j][0] = rsd[k][j][i][2];
  217|   246k|        u31 = rsd[k][j][i][2] / rsd[k][j][i][0];
  218|   246k|        q = 0.50 * (  rsd[k][j][i][1] * rsd[k][j][i][1]
  219|   246k|                    + rsd[k][j][i][2] * rsd[k][j][i][2]
  220|   246k|                    + rsd[k][j][i][3] * rsd[k][j][i][3] )
  221|   246k|                 / rsd[k][j][i][0];
  222|   246k|        flux[j][1] = rsd[k][j][i][1] * u31;
  223|   246k|        flux[j][2] = rsd[k][j][i][2] * u31 + C2 * ( rsd[k][j][i][4] - q );
  224|   246k|        flux[j][3] = rsd[k][j][i][3] * u31;
  225|   246k|        flux[j][4] = ( C1 * rsd[k][j][i][4] - C2 * q ) * u31;
  226|   246k|      }
  227|       |
  228|   242k|      for (j = jst; j < jend; j++) {
  229|  1.42M|        for (m = 0; m < 5; m++) {
  230|  1.19M|          frct[k][j][i][m] =  frct[k][j][i][m]
  231|  1.19M|            - ty2 * ( flux[j+1][m] - flux[j-1][m] );
  232|  1.19M|        }
  233|   238k|      }
  234|       |
  235|   246k|      for (j = jst; j < ny; j++) {
  236|   242k|        tmp = 1.0 / rsd[k][j][i][0];
  237|       |
  238|   242k|        u21j = tmp * rsd[k][j][i][1];
  239|   242k|        u31j = tmp * rsd[k][j][i][2];
  240|   242k|        u41j = tmp * rsd[k][j][i][3];
  241|   242k|        u51j = tmp * rsd[k][j][i][4];
  242|       |
  243|   242k|        tmp = 1.0 / rsd[k][j-1][i][0];
  244|       |
  245|   242k|        u21jm1 = tmp * rsd[k][j-1][i][1];
  246|   242k|        u31jm1 = tmp * rsd[k][j-1][i][2];
  247|   242k|        u41jm1 = tmp * rsd[k][j-1][i][3];
  248|   242k|        u51jm1 = tmp * rsd[k][j-1][i][4];
  249|       |
  250|   242k|        flux[j][1] = ty3 * ( u21j - u21jm1 );
  251|   242k|        flux[j][2] = (4.0/3.0) * ty3 * ( u31j - u31jm1 );
  252|   242k|        flux[j][3] = ty3 * ( u41j - u41jm1 );
  253|   242k|        flux[j][4] = 0.50 * ( 1.0 - C1*C5 )
  254|   242k|          * ty3 * ( ( u21j*u21j     + u31j*u31j     + u41j*u41j )
  255|   242k|                  - ( u21jm1*u21jm1 + u31jm1*u31jm1 + u41jm1*u41jm1 ) )
  256|   242k|          + (1.0/6.0)
  257|   242k|          * ty3 * ( u31j*u31j - u31jm1*u31jm1 )
  258|   242k|          + C1 * C5 * ty3 * ( u51j - u51jm1 );
  259|   242k|      }
  260|       |
  261|   242k|      for (j = jst; j < jend; j++) {
  262|   238k|        frct[k][j][i][0] = frct[k][j][i][0]
  263|   238k|          + dy1 * ty1 * (        rsd[k][j-1][i][0]
  264|   238k|                         - 2.0 * rsd[k][j][i][0]
  265|   238k|                         +       rsd[k][j+1][i][0] );
  266|   238k|        frct[k][j][i][1] = frct[k][j][i][1]
  267|   238k|          + ty3 * C3 * C4 * ( flux[j+1][1] - flux[j][1] )
  268|   238k|          + dy2 * ty1 * (        rsd[k][j-1][i][1]
  269|   238k|                         - 2.0 * rsd[k][j][i][1]
  270|   238k|                         +       rsd[k][j+1][i][1] );
  271|   238k|        frct[k][j][i][2] = frct[k][j][i][2]
  272|   238k|          + ty3 * C3 * C4 * ( flux[j+1][2] - flux[j][2] )
  273|   238k|          + dy3 * ty1 * (        rsd[k][j-1][i][2]
  274|   238k|                         - 2.0 * rsd[k][j][i][2]
  275|   238k|                         +       rsd[k][j+1][i][2] );
  276|   238k|        frct[k][j][i][3] = frct[k][j][i][3]
  277|   238k|          + ty3 * C3 * C4 * ( flux[j+1][3] - flux[j][3] )
  278|   238k|          + dy4 * ty1 * (        rsd[k][j-1][i][3]
  279|   238k|                         - 2.0 * rsd[k][j][i][3]
  280|   238k|                         +       rsd[k][j+1][i][3] );
  281|   238k|        frct[k][j][i][4] = frct[k][j][i][4]
  282|   238k|          + ty3 * C3 * C4 * ( flux[j+1][4] - flux[j][4] )
  283|   238k|          + dy5 * ty1 * (        rsd[k][j-1][i][4]
  284|   238k|                         - 2.0 * rsd[k][j][i][4]
  285|   238k|                         +       rsd[k][j+1][i][4] );
  286|   238k|      }
  287|       |
  288|       |      //---------------------------------------------------------------------
  289|       |      // fourth-order dissipation
  290|       |      //---------------------------------------------------------------------
  291|  23.0k|      for (m = 0; m < 5; m++) {
  292|  19.2k|        frct[k][1][i][m] = frct[k][1][i][m]
  293|  19.2k|          - dssp * ( + 5.0 * rsd[k][1][i][m]
  294|  19.2k|                     - 4.0 * rsd[k][2][i][m]
  295|  19.2k|                     +       rsd[k][3][i][m] );
  296|  19.2k|        frct[k][2][i][m] = frct[k][2][i][m]
  297|  19.2k|          - dssp * ( - 4.0 * rsd[k][1][i][m]
  298|  19.2k|                     + 6.0 * rsd[k][2][i][m]
  299|  19.2k|                     - 4.0 * rsd[k][3][i][m]
  300|  19.2k|                     +       rsd[k][4][i][m] );
  301|  19.2k|      }
  302|       |
  303|   226k|      for (j = 3; j < ny - 3; j++) {
  304|  1.33M|        for (m = 0; m < 5; m++) {
  305|  1.11M|          frct[k][j][i][m] = frct[k][j][i][m]
  306|  1.11M|            - dssp * (        rsd[k][j-2][i][m]
  307|  1.11M|                      - 4.0 * rsd[k][j-1][i][m]
  308|  1.11M|                      + 6.0 * rsd[k][j][i][m]
  309|  1.11M|                      - 4.0 * rsd[k][j+1][i][m]
  310|  1.11M|                      +       rsd[k][j+2][i][m] );
  311|  1.11M|        }
  312|   222k|      }
  313|       |
  314|  23.0k|      for (m = 0; m < 5; m++) {
  315|  19.2k|        frct[k][ny-3][i][m] = frct[k][ny-3][i][m]
  316|  19.2k|          - dssp * (        rsd[k][ny-5][i][m]
  317|  19.2k|                    - 4.0 * rsd[k][ny-4][i][m]
  318|  19.2k|                    + 6.0 * rsd[k][ny-3][i][m]
  319|  19.2k|                    - 4.0 * rsd[k][ny-2][i][m] );
  320|  19.2k|        frct[k][ny-2][i][m] = frct[k][ny-2][i][m]
  321|  19.2k|          - dssp * (        rsd[k][ny-4][i][m]
  322|  19.2k|                    - 4.0 * rsd[k][ny-3][i][m]
  323|  19.2k|                    + 5.0 * rsd[k][ny-2][i][m] );
  324|  19.2k|      }
  325|  3.84k|    }
  326|     62|  }
  327|       |
  328|       |  //---------------------------------------------------------------------
  329|       |  // zeta-direction flux differences
  330|       |  //---------------------------------------------------------------------
  331|     63|  for (j = jst; j < jend; j++) {
  332|  3.90k|    for (i = ist; i < iend; i++) {
  333|   249k|      for (k = 0; k < nz; k++) {
  334|   246k|        flux[k][0] = rsd[k][j][i][3];
  335|   246k|        u41 = rsd[k][j][i][3] / rsd[k][j][i][0];
  336|   246k|        q = 0.50 * (  rsd[k][j][i][1] * rsd[k][j][i][1]
  337|   246k|                    + rsd[k][j][i][2] * rsd[k][j][i][2]
  338|   246k|                    + rsd[k][j][i][3] * rsd[k][j][i][3] )
  339|   246k|                 / rsd[k][j][i][0];
  340|   246k|        flux[k][1] = rsd[k][j][i][1] * u41;
  341|   246k|        flux[k][2] = rsd[k][j][i][2] * u41; 
  342|   246k|        flux[k][3] = rsd[k][j][i][3] * u41 + C2 * ( rsd[k][j][i][4] - q );
  343|   246k|        flux[k][4] = ( C1 * rsd[k][j][i][4] - C2 * q ) * u41;
  344|   246k|      }
  345|       |
  346|   242k|      for (k = 1; k < nz - 1; k++) {
  347|  1.42M|        for (m = 0; m < 5; m++) {
  348|  1.19M|          frct[k][j][i][m] =  frct[k][j][i][m]
  349|  1.19M|            - tz2 * ( flux[k+1][m] - flux[k-1][m] );
  350|  1.19M|        }
  351|   238k|      }
  352|       |
  353|   246k|      for (k = 1; k < nz; k++) {
  354|   242k|        tmp = 1.0 / rsd[k][j][i][0];
  355|       |
  356|   242k|        u21k = tmp * rsd[k][j][i][1];
  357|   242k|        u31k = tmp * rsd[k][j][i][2];
  358|   242k|        u41k = tmp * rsd[k][j][i][3];
  359|   242k|        u51k = tmp * rsd[k][j][i][4];
  360|       |
  361|   242k|        tmp = 1.0 / rsd[k-1][j][i][0];
  362|       |
  363|   242k|        u21km1 = tmp * rsd[k-1][j][i][1];
  364|   242k|        u31km1 = tmp * rsd[k-1][j][i][2];
  365|   242k|        u41km1 = tmp * rsd[k-1][j][i][3];
  366|   242k|        u51km1 = tmp * rsd[k-1][j][i][4];
  367|       |
  368|   242k|        flux[k][1] = tz3 * ( u21k - u21km1 );
  369|   242k|        flux[k][2] = tz3 * ( u31k - u31km1 );
  370|   242k|        flux[k][3] = (4.0/3.0) * tz3 * ( u41k - u41km1 );
  371|   242k|        flux[k][4] = 0.50 * ( 1.0 - C1*C5 )
  372|   242k|          * tz3 * ( ( u21k*u21k     + u31k*u31k     + u41k*u41k )
  373|   242k|                  - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) )
  374|   242k|          + (1.0/6.0)
  375|   242k|          * tz3 * ( u41k*u41k - u41km1*u41km1 )
  376|   242k|          + C1 * C5 * tz3 * ( u51k - u51km1 );
  377|   242k|      }
  378|       |
  379|   242k|      for (k = 1; k < nz - 1; k++) {
  380|   238k|        frct[k][j][i][0] = frct[k][j][i][0]
  381|   238k|          + dz1 * tz1 * (        rsd[k+1][j][i][0]
  382|   238k|                         - 2.0 * rsd[k][j][i][0]
  383|   238k|                         +       rsd[k-1][j][i][0] );
  384|   238k|        frct[k][j][i][1] = frct[k][j][i][1]
  385|   238k|          + tz3 * C3 * C4 * ( flux[k+1][1] - flux[k][1] )
  386|   238k|          + dz2 * tz1 * (        rsd[k+1][j][i][1]
  387|   238k|                         - 2.0 * rsd[k][j][i][1]
  388|   238k|                         +       rsd[k-1][j][i][1] );
  389|   238k|        frct[k][j][i][2] = frct[k][j][i][2]
  390|   238k|          + tz3 * C3 * C4 * ( flux[k+1][2] - flux[k][2] )
  391|   238k|          + dz3 * tz1 * (        rsd[k+1][j][i][2]
  392|   238k|                         - 2.0 * rsd[k][j][i][2]
  393|   238k|                         +       rsd[k-1][j][i][2] );
  394|   238k|        frct[k][j][i][3] = frct[k][j][i][3]
  395|   238k|          + tz3 * C3 * C4 * ( flux[k+1][3] - flux[k][3] )
  396|   238k|          + dz4 * tz1 * (        rsd[k+1][j][i][3]
  397|   238k|                         - 2.0 * rsd[k][j][i][3]
  398|   238k|                         +       rsd[k-1][j][i][3] );
  399|   238k|        frct[k][j][i][4] = frct[k][j][i][4]
  400|   238k|          + tz3 * C3 * C4 * ( flux[k+1][4] - flux[k][4] )
  401|   238k|          + dz5 * tz1 * (        rsd[k+1][j][i][4]
  402|   238k|                         - 2.0 * rsd[k][j][i][4]
  403|   238k|                         +       rsd[k-1][j][i][4] );
  404|   238k|      }
  405|       |
  406|       |      //---------------------------------------------------------------------
  407|       |      // fourth-order dissipation
  408|       |      //---------------------------------------------------------------------
  409|  23.0k|      for (m = 0; m < 5; m++) {
  410|  19.2k|        frct[1][j][i][m] = frct[1][j][i][m]
  411|  19.2k|          - dssp * ( + 5.0 * rsd[1][j][i][m]
  412|  19.2k|                     - 4.0 * rsd[2][j][i][m]
  413|  19.2k|                     +       rsd[3][j][i][m] );
  414|  19.2k|        frct[2][j][i][m] = frct[2][j][i][m]
  415|  19.2k|          - dssp * ( - 4.0 * rsd[1][j][i][m]
  416|  19.2k|                     + 6.0 * rsd[2][j][i][m]
  417|  19.2k|                     - 4.0 * rsd[3][j][i][m]
  418|  19.2k|                     +       rsd[4][j][i][m] );
  419|  19.2k|      }
  420|       |
  421|   226k|      for (k = 3; k < nz - 3; k++) {
  422|  1.33M|        for (m = 0; m < 5; m++) {
  423|  1.11M|          frct[k][j][i][m] = frct[k][j][i][m]
  424|  1.11M|            - dssp * (        rsd[k-2][j][i][m]
  425|  1.11M|                      - 4.0 * rsd[k-1][j][i][m]
  426|  1.11M|                      + 6.0 * rsd[k][j][i][m]
  427|  1.11M|                      - 4.0 * rsd[k+1][j][i][m]
  428|  1.11M|                      +       rsd[k+2][j][i][m] );
  429|  1.11M|        }
  430|   222k|      }
  431|       |
  432|  23.0k|      for (m = 0; m < 5; m++) {
  433|  19.2k|        frct[nz-3][j][i][m] = frct[nz-3][j][i][m]
  434|  19.2k|          - dssp * (        rsd[nz-5][j][i][m]
  435|  19.2k|                    - 4.0 * rsd[nz-4][j][i][m]
  436|  19.2k|                    + 6.0 * rsd[nz-3][j][i][m]
  437|  19.2k|                    - 4.0 * rsd[nz-2][j][i][m] );
  438|  19.2k|        frct[nz-2][j][i][m] = frct[nz-2][j][i][m]
  439|  19.2k|          - dssp * (        rsd[nz-4][j][i][m]
  440|  19.2k|                    - 4.0 * rsd[nz-3][j][i][m]
  441|  19.2k|                    + 5.0 * rsd[nz-2][j][i][m] );
  442|  19.2k|      }
  443|  3.84k|    }
  444|     62|  }
  445|      1|}
  446|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/error.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <math.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |// 
   40|       |// compute the solution error
   41|       |// 
   42|       |//---------------------------------------------------------------------
   43|       |void error()
   44|      1|{
   45|       |  //---------------------------------------------------------------------
   46|       |  // local variables
   47|       |  //---------------------------------------------------------------------
   48|      1|  int i, j, k, m;
   49|      1|  double tmp;
   50|      1|  double u000ijk[5];
   51|       |
   52|      6|  for (m = 0; m < 5; m++) {
   53|      5|    errnm[m] = 0.0;
   54|      5|  }
   55|       |
   56|     63|  for (k = 1; k < nz-1; k++) {
   57|  3.90k|    for (j = jst; j < jend; j++) {
   58|   242k|      for (i = ist; i < iend; i++) {
   59|   238k|        exact( i, j, k, u000ijk );
   60|  1.42M|        for (m = 0; m < 5; m++) {
   61|  1.19M|          tmp = ( u000ijk[m] - u[k][j][i][m] );
   62|  1.19M|          errnm[m] = errnm[m] + tmp * tmp;
   63|  1.19M|        }
   64|   238k|      }
   65|  3.84k|    }
   66|     62|  }
   67|       |
   68|      6|  for (m = 0; m < 5; m++) {
   69|      5|    errnm[m] = sqrt ( errnm[m] / ( (nx0-2)*(ny0-2)*(nz0-2) ) );
   70|      5|  }
   71|       |
   72|       |  /*
   73|       |  printf(" \n RMS-norm of error in soln. to first pde  = %12.5E\n"
   74|       |         " RMS-norm of error in soln. to second pde = %12.5E\n"
   75|       |         " RMS-norm of error in soln. to third pde  = %12.5E\n"
   76|       |         " RMS-norm of error in soln. to fourth pde = %12.5E\n"
   77|       |         " RMS-norm of error in soln. to fifth pde  = %12.5E\n",
   78|       |         errnm[0], errnm[1], errnm[2], errnm[3], errnm[4]);
   79|       |  */
   80|      1|}
   81|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/exact.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |//
   38|       |//   compute the exact solution at (i,j,k)
   39|       |//
   40|       |//---------------------------------------------------------------------
   41|       |void exact(int i, int j, int k, double u000ijk[])
   42|  3.14M|{
   43|       |  //---------------------------------------------------------------------
   44|       |  // local variables
   45|       |  //---------------------------------------------------------------------
   46|  3.14M|  int m;
   47|  3.14M|  double xi, eta, zeta;
   48|       |
   49|  3.14M|  xi   = ( (double)i ) / ( nx0 - 1 );
   50|  3.14M|  eta  = ( (double)j ) / ( ny0 - 1 );
   51|  3.14M|  zeta = ( (double)k ) / ( nz - 1 );
   52|       |
   53|  18.8M|  for (m = 0; m < 5; m++) {
   54|  15.7M|    u000ijk[m] =  ce[m][0]
   55|  15.7M|      + (ce[m][1]
   56|  15.7M|      + (ce[m][4]
   57|  15.7M|      + (ce[m][7]
   58|  15.7M|      +  ce[m][10] * xi) * xi) * xi) * xi
   59|  15.7M|      + (ce[m][2]
   60|  15.7M|      + (ce[m][5]
   61|  15.7M|      + (ce[m][8]
   62|  15.7M|      +  ce[m][11] * eta) * eta) * eta) * eta
   63|  15.7M|      + (ce[m][3]
   64|  15.7M|      + (ce[m][6]
   65|  15.7M|      + (ce[m][9]
   66|  15.7M|      +  ce[m][12] * zeta) * zeta) * zeta) * zeta;
   67|  15.7M|  }
   68|  3.14M|}
   69|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/jacld.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// compute the lower triangular part of the jacobian matrix
   38|       |//---------------------------------------------------------------------
   39|       |void jacld(int k)
   40|  15.5k|{
   41|       |  //---------------------------------------------------------------------
   42|       |  // local variables
   43|       |  //---------------------------------------------------------------------
   44|  15.5k|  int i, j;
   45|  15.5k|  double r43;
   46|  15.5k|  double c1345;
   47|  15.5k|  double c34;
   48|  15.5k|  double tmp1, tmp2, tmp3;
   49|       |
   50|  15.5k|  r43 = ( 4.0 / 3.0 );
   51|  15.5k|  c1345 = C1 * C3 * C4 * C5;
   52|  15.5k|  c34 = C3 * C4;
   53|       |
   54|   980k|  for (j = jst; j < jend; j++) {
   55|  60.7M|    for (i = ist; i < iend; i++) {
   56|       |      //---------------------------------------------------------------------
   57|       |      // form the block daigonal
   58|       |      //---------------------------------------------------------------------
   59|  59.8M|      tmp1 = rho_i[k][j][i];
   60|  59.8M|      tmp2 = tmp1 * tmp1;
   61|  59.8M|      tmp3 = tmp1 * tmp2;
   62|       |
   63|  59.8M|      d[j][i][0][0] =  1.0 + dt * 2.0 * ( tx1 * dx1 + ty1 * dy1 + tz1 * dz1 );
   64|  59.8M|      d[j][i][1][0] =  0.0;
   65|  59.8M|      d[j][i][2][0] =  0.0;
   66|  59.8M|      d[j][i][3][0] =  0.0;
   67|  59.8M|      d[j][i][4][0] =  0.0;
   68|       |
   69|  59.8M|      d[j][i][0][1] = -dt * 2.0
   70|  59.8M|        * ( tx1 * r43 + ty1 + tz1 ) * c34 * tmp2 * u[k][j][i][1];
   71|  59.8M|      d[j][i][1][1] =  1.0
   72|  59.8M|        + dt * 2.0 * c34 * tmp1 * ( tx1 * r43 + ty1 + tz1 )
   73|  59.8M|        + dt * 2.0 * ( tx1 * dx2 + ty1 * dy2 + tz1 * dz2 );
   74|  59.8M|      d[j][i][2][1] = 0.0;
   75|  59.8M|      d[j][i][3][1] = 0.0;
   76|  59.8M|      d[j][i][4][1] = 0.0;
   77|       |
   78|  59.8M|      d[j][i][0][2] = -dt * 2.0 
   79|  59.8M|        * ( tx1 + ty1 * r43 + tz1 ) * c34 * tmp2 * u[k][j][i][2];
   80|  59.8M|      d[j][i][1][2] = 0.0;
   81|  59.8M|      d[j][i][2][2] = 1.0
   82|  59.8M|        + dt * 2.0 * c34 * tmp1 * ( tx1 + ty1 * r43 + tz1 )
   83|  59.8M|        + dt * 2.0 * ( tx1 * dx3 + ty1 * dy3 + tz1 * dz3 );
   84|  59.8M|      d[j][i][3][2] = 0.0;
   85|  59.8M|      d[j][i][4][2] = 0.0;
   86|       |
   87|  59.8M|      d[j][i][0][3] = -dt * 2.0
   88|  59.8M|        * ( tx1 + ty1 + tz1 * r43 ) * c34 * tmp2 * u[k][j][i][3];
   89|  59.8M|      d[j][i][1][3] = 0.0;
   90|  59.8M|      d[j][i][2][3] = 0.0;
   91|  59.8M|      d[j][i][3][3] = 1.0
   92|  59.8M|        + dt * 2.0 * c34 * tmp1 * ( tx1 + ty1 + tz1 * r43 )
   93|  59.8M|        + dt * 2.0 * ( tx1 * dx4 + ty1 * dy4 + tz1 * dz4 );
   94|  59.8M|      d[j][i][4][3] = 0.0;
   95|       |
   96|  59.8M|      d[j][i][0][4] = -dt * 2.0
   97|  59.8M|        * ( ( ( tx1 * ( r43*c34 - c1345 )
   98|  59.8M|                + ty1 * ( c34 - c1345 )
   99|  59.8M|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][1]*u[k][j][i][1] )
  100|  59.8M|              + ( tx1 * ( c34 - c1345 )
  101|  59.8M|                + ty1 * ( r43*c34 - c1345 )
  102|  59.8M|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][2]*u[k][j][i][2] )
  103|  59.8M|              + ( tx1 * ( c34 - c1345 )
  104|  59.8M|                + ty1 * ( c34 - c1345 )
  105|  59.8M|                + tz1 * ( r43*c34 - c1345 ) ) * (u[k][j][i][3]*u[k][j][i][3])
  106|  59.8M|            ) * tmp3
  107|  59.8M|            + ( tx1 + ty1 + tz1 ) * c1345 * tmp2 * u[k][j][i][4] );
  108|       |
  109|  59.8M|      d[j][i][1][4] = dt * 2.0 * tmp2 * u[k][j][i][1]
  110|  59.8M|        * ( tx1 * ( r43*c34 - c1345 )
  111|  59.8M|          + ty1 * (     c34 - c1345 )
  112|  59.8M|          + tz1 * (     c34 - c1345 ) );
  113|  59.8M|      d[j][i][2][4] = dt * 2.0 * tmp2 * u[k][j][i][2]
  114|  59.8M|        * ( tx1 * ( c34 - c1345 )
  115|  59.8M|          + ty1 * ( r43*c34 -c1345 )
  116|  59.8M|          + tz1 * ( c34 - c1345 ) );
  117|  59.8M|      d[j][i][3][4] = dt * 2.0 * tmp2 * u[k][j][i][3]
  118|  59.8M|        * ( tx1 * ( c34 - c1345 )
  119|  59.8M|          + ty1 * ( c34 - c1345 )
  120|  59.8M|          + tz1 * ( r43*c34 - c1345 ) );
  121|  59.8M|      d[j][i][4][4] = 1.0
  122|  59.8M|        + dt * 2.0 * ( tx1  + ty1 + tz1 ) * c1345 * tmp1
  123|  59.8M|        + dt * 2.0 * ( tx1 * dx5 +  ty1 * dy5 +  tz1 * dz5 );
  124|       |
  125|       |      //---------------------------------------------------------------------
  126|       |      // form the first block sub-diagonal
  127|       |      //---------------------------------------------------------------------
  128|  59.8M|      tmp1 = rho_i[k-1][j][i];
  129|  59.8M|      tmp2 = tmp1 * tmp1;
  130|  59.8M|      tmp3 = tmp1 * tmp2;
  131|       |
  132|  59.8M|      a[j][i][0][0] = - dt * tz1 * dz1;
  133|  59.8M|      a[j][i][1][0] =   0.0;
  134|  59.8M|      a[j][i][2][0] =   0.0;
  135|  59.8M|      a[j][i][3][0] = - dt * tz2;
  136|  59.8M|      a[j][i][4][0] =   0.0;
  137|       |
  138|  59.8M|      a[j][i][0][1] = - dt * tz2
  139|  59.8M|        * ( - ( u[k-1][j][i][1]*u[k-1][j][i][3] ) * tmp2 )
  140|  59.8M|        - dt * tz1 * ( - c34 * tmp2 * u[k-1][j][i][1] );
  141|  59.8M|      a[j][i][1][1] = - dt * tz2 * ( u[k-1][j][i][3] * tmp1 )
  142|  59.8M|        - dt * tz1 * c34 * tmp1
  143|  59.8M|        - dt * tz1 * dz2;
  144|  59.8M|      a[j][i][2][1] = 0.0;
  145|  59.8M|      a[j][i][3][1] = - dt * tz2 * ( u[k-1][j][i][1] * tmp1 );
  146|  59.8M|      a[j][i][4][1] = 0.0;
  147|       |
  148|  59.8M|      a[j][i][0][2] = - dt * tz2
  149|  59.8M|        * ( - ( u[k-1][j][i][2]*u[k-1][j][i][3] ) * tmp2 )
  150|  59.8M|        - dt * tz1 * ( - c34 * tmp2 * u[k-1][j][i][2] );
  151|  59.8M|      a[j][i][1][2] = 0.0;
  152|  59.8M|      a[j][i][2][2] = - dt * tz2 * ( u[k-1][j][i][3] * tmp1 )
  153|  59.8M|        - dt * tz1 * ( c34 * tmp1 )
  154|  59.8M|        - dt * tz1 * dz3;
  155|  59.8M|      a[j][i][3][2] = - dt * tz2 * ( u[k-1][j][i][2] * tmp1 );
  156|  59.8M|      a[j][i][4][2] = 0.0;
  157|       |
  158|  59.8M|      a[j][i][0][3] = - dt * tz2
  159|  59.8M|        * ( - ( u[k-1][j][i][3] * tmp1 ) * ( u[k-1][j][i][3] * tmp1 )
  160|  59.8M|            + C2 * qs[k-1][j][i] * tmp1 )
  161|  59.8M|        - dt * tz1 * ( - r43 * c34 * tmp2 * u[k-1][j][i][3] );
  162|  59.8M|      a[j][i][1][3] = - dt * tz2
  163|  59.8M|        * ( - C2 * ( u[k-1][j][i][1] * tmp1 ) );
  164|  59.8M|      a[j][i][2][3] = - dt * tz2
  165|  59.8M|        * ( - C2 * ( u[k-1][j][i][2] * tmp1 ) );
  166|  59.8M|      a[j][i][3][3] = - dt * tz2 * ( 2.0 - C2 )
  167|  59.8M|        * ( u[k-1][j][i][3] * tmp1 )
  168|  59.8M|        - dt * tz1 * ( r43 * c34 * tmp1 )
  169|  59.8M|        - dt * tz1 * dz4;
  170|  59.8M|      a[j][i][4][3] = - dt * tz2 * C2;
  171|       |
  172|  59.8M|      a[j][i][0][4] = - dt * tz2
  173|  59.8M|        * ( ( C2 * 2.0 * qs[k-1][j][i] - C1 * u[k-1][j][i][4] )
  174|  59.8M|            * u[k-1][j][i][3] * tmp2 )
  175|  59.8M|        - dt * tz1
  176|  59.8M|        * ( - ( c34 - c1345 ) * tmp3 * (u[k-1][j][i][1]*u[k-1][j][i][1])
  177|  59.8M|            - ( c34 - c1345 ) * tmp3 * (u[k-1][j][i][2]*u[k-1][j][i][2])
  178|  59.8M|            - ( r43*c34 - c1345 )* tmp3 * (u[k-1][j][i][3]*u[k-1][j][i][3])
  179|  59.8M|            - c1345 * tmp2 * u[k-1][j][i][4] );
  180|  59.8M|      a[j][i][1][4] = - dt * tz2
  181|  59.8M|        * ( - C2 * ( u[k-1][j][i][1]*u[k-1][j][i][3] ) * tmp2 )
  182|  59.8M|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k-1][j][i][1];
  183|  59.8M|      a[j][i][2][4] = - dt * tz2
  184|  59.8M|        * ( - C2 * ( u[k-1][j][i][2]*u[k-1][j][i][3] ) * tmp2 )
  185|  59.8M|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k-1][j][i][2];
  186|  59.8M|      a[j][i][3][4] = - dt * tz2
  187|  59.8M|        * ( C1 * ( u[k-1][j][i][4] * tmp1 )
  188|  59.8M|          - C2 * ( qs[k-1][j][i] * tmp1
  189|  59.8M|                 + u[k-1][j][i][3]*u[k-1][j][i][3] * tmp2 ) )
  190|  59.8M|        - dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[k-1][j][i][3];
  191|  59.8M|      a[j][i][4][4] = - dt * tz2
  192|  59.8M|        * ( C1 * ( u[k-1][j][i][3] * tmp1 ) )
  193|  59.8M|        - dt * tz1 * c1345 * tmp1
  194|  59.8M|        - dt * tz1 * dz5;
  195|       |
  196|       |      //---------------------------------------------------------------------
  197|       |      // form the second block sub-diagonal
  198|       |      //---------------------------------------------------------------------
  199|  59.8M|      tmp1 = rho_i[k][j-1][i];
  200|  59.8M|      tmp2 = tmp1 * tmp1;
  201|  59.8M|      tmp3 = tmp1 * tmp2;
  202|       |
  203|  59.8M|      b[j][i][0][0] = - dt * ty1 * dy1;
  204|  59.8M|      b[j][i][1][0] =   0.0;
  205|  59.8M|      b[j][i][2][0] = - dt * ty2;
  206|  59.8M|      b[j][i][3][0] =   0.0;
  207|  59.8M|      b[j][i][4][0] =   0.0;
  208|       |
  209|  59.8M|      b[j][i][0][1] = - dt * ty2
  210|  59.8M|        * ( - ( u[k][j-1][i][1]*u[k][j-1][i][2] ) * tmp2 )
  211|  59.8M|        - dt * ty1 * ( - c34 * tmp2 * u[k][j-1][i][1] );
  212|  59.8M|      b[j][i][1][1] = - dt * ty2 * ( u[k][j-1][i][2] * tmp1 )
  213|  59.8M|        - dt * ty1 * ( c34 * tmp1 )
  214|  59.8M|        - dt * ty1 * dy2;
  215|  59.8M|      b[j][i][2][1] = - dt * ty2 * ( u[k][j-1][i][1] * tmp1 );
  216|  59.8M|      b[j][i][3][1] = 0.0;
  217|  59.8M|      b[j][i][4][1] = 0.0;
  218|       |
  219|  59.8M|      b[j][i][0][2] = - dt * ty2
  220|  59.8M|        * ( - ( u[k][j-1][i][2] * tmp1 ) * ( u[k][j-1][i][2] * tmp1 )
  221|  59.8M|            + C2 * ( qs[k][j-1][i] * tmp1 ) )
  222|  59.8M|        - dt * ty1 * ( - r43 * c34 * tmp2 * u[k][j-1][i][2] );
  223|  59.8M|      b[j][i][1][2] = - dt * ty2
  224|  59.8M|        * ( - C2 * ( u[k][j-1][i][1] * tmp1 ) );
  225|  59.8M|      b[j][i][2][2] = - dt * ty2 * ( (2.0 - C2) * (u[k][j-1][i][2] * tmp1) )
  226|  59.8M|        - dt * ty1 * ( r43 * c34 * tmp1 )
  227|  59.8M|        - dt * ty1 * dy3;
  228|  59.8M|      b[j][i][3][2] = - dt * ty2 * ( - C2 * ( u[k][j-1][i][3] * tmp1 ) );
  229|  59.8M|      b[j][i][4][2] = - dt * ty2 * C2;
  230|       |
  231|  59.8M|      b[j][i][0][3] = - dt * ty2
  232|  59.8M|        * ( - ( u[k][j-1][i][2]*u[k][j-1][i][3] ) * tmp2 )
  233|  59.8M|        - dt * ty1 * ( - c34 * tmp2 * u[k][j-1][i][3] );
  234|  59.8M|      b[j][i][1][3] = 0.0;
  235|  59.8M|      b[j][i][2][3] = - dt * ty2 * ( u[k][j-1][i][3] * tmp1 );
  236|  59.8M|      b[j][i][3][3] = - dt * ty2 * ( u[k][j-1][i][2] * tmp1 )
  237|  59.8M|        - dt * ty1 * ( c34 * tmp1 )
  238|  59.8M|        - dt * ty1 * dy4;
  239|  59.8M|      b[j][i][4][3] = 0.0;
  240|       |
  241|  59.8M|      b[j][i][0][4] = - dt * ty2
  242|  59.8M|        * ( ( C2 * 2.0 * qs[k][j-1][i] - C1 * u[k][j-1][i][4] )
  243|  59.8M|            * ( u[k][j-1][i][2] * tmp2 ) )
  244|  59.8M|        - dt * ty1
  245|  59.8M|        * ( - (     c34 - c1345 )*tmp3*(u[k][j-1][i][1]*u[k][j-1][i][1])
  246|  59.8M|            - ( r43*c34 - c1345 )*tmp3*(u[k][j-1][i][2]*u[k][j-1][i][2])
  247|  59.8M|            - (     c34 - c1345 )*tmp3*(u[k][j-1][i][3]*u[k][j-1][i][3])
  248|  59.8M|            - c1345*tmp2*u[k][j-1][i][4] );
  249|  59.8M|      b[j][i][1][4] = - dt * ty2
  250|  59.8M|        * ( - C2 * ( u[k][j-1][i][1]*u[k][j-1][i][2] ) * tmp2 )
  251|  59.8M|        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[k][j-1][i][1];
  252|  59.8M|      b[j][i][2][4] = - dt * ty2
  253|  59.8M|        * ( C1 * ( u[k][j-1][i][4] * tmp1 )
  254|  59.8M|          - C2 * ( qs[k][j-1][i] * tmp1
  255|  59.8M|                 + u[k][j-1][i][2]*u[k][j-1][i][2] * tmp2 ) )
  256|  59.8M|        - dt * ty1 * ( r43*c34 - c1345 ) * tmp2 * u[k][j-1][i][2];
  257|  59.8M|      b[j][i][3][4] = - dt * ty2
  258|  59.8M|        * ( - C2 * ( u[k][j-1][i][2]*u[k][j-1][i][3] ) * tmp2 )
  259|  59.8M|        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[k][j-1][i][3];
  260|  59.8M|      b[j][i][4][4] = - dt * ty2
  261|  59.8M|        * ( C1 * ( u[k][j-1][i][2] * tmp1 ) )
  262|  59.8M|        - dt * ty1 * c1345 * tmp1
  263|  59.8M|        - dt * ty1 * dy5;
  264|       |
  265|       |      //---------------------------------------------------------------------
  266|       |      // form the third block sub-diagonal
  267|       |      //---------------------------------------------------------------------
  268|  59.8M|      tmp1 = rho_i[k][j][i-1];
  269|  59.8M|      tmp2 = tmp1 * tmp1;
  270|  59.8M|      tmp3 = tmp1 * tmp2;
  271|       |
  272|  59.8M|      c[j][i][0][0] = - dt * tx1 * dx1;
  273|  59.8M|      c[j][i][1][0] = - dt * tx2;
  274|  59.8M|      c[j][i][2][0] =   0.0;
  275|  59.8M|      c[j][i][3][0] =   0.0;
  276|  59.8M|      c[j][i][4][0] =   0.0;
  277|       |
  278|  59.8M|      c[j][i][0][1] = - dt * tx2
  279|  59.8M|        * ( - ( u[k][j][i-1][1] * tmp1 ) * ( u[k][j][i-1][1] * tmp1 )
  280|  59.8M|            + C2 * qs[k][j][i-1] * tmp1 )
  281|  59.8M|        - dt * tx1 * ( - r43 * c34 * tmp2 * u[k][j][i-1][1] );
  282|  59.8M|      c[j][i][1][1] = - dt * tx2
  283|  59.8M|        * ( ( 2.0 - C2 ) * ( u[k][j][i-1][1] * tmp1 ) )
  284|  59.8M|        - dt * tx1 * ( r43 * c34 * tmp1 )
  285|  59.8M|        - dt * tx1 * dx2;
  286|  59.8M|      c[j][i][2][1] = - dt * tx2
  287|  59.8M|        * ( - C2 * ( u[k][j][i-1][2] * tmp1 ) );
  288|  59.8M|      c[j][i][3][1] = - dt * tx2
  289|  59.8M|        * ( - C2 * ( u[k][j][i-1][3] * tmp1 ) );
  290|  59.8M|      c[j][i][4][1] = - dt * tx2 * C2;
  291|       |
  292|  59.8M|      c[j][i][0][2] = - dt * tx2
  293|  59.8M|        * ( - ( u[k][j][i-1][1] * u[k][j][i-1][2] ) * tmp2 )
  294|  59.8M|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i-1][2] );
  295|  59.8M|      c[j][i][1][2] = - dt * tx2 * ( u[k][j][i-1][2] * tmp1 );
  296|  59.8M|      c[j][i][2][2] = - dt * tx2 * ( u[k][j][i-1][1] * tmp1 )
  297|  59.8M|        - dt * tx1 * ( c34 * tmp1 )
  298|  59.8M|        - dt * tx1 * dx3;
  299|  59.8M|      c[j][i][3][2] = 0.0;
  300|  59.8M|      c[j][i][4][2] = 0.0;
  301|       |
  302|  59.8M|      c[j][i][0][3] = - dt * tx2
  303|  59.8M|        * ( - ( u[k][j][i-1][1]*u[k][j][i-1][3] ) * tmp2 )
  304|  59.8M|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i-1][3] );
  305|  59.8M|      c[j][i][1][3] = - dt * tx2 * ( u[k][j][i-1][3] * tmp1 );
  306|  59.8M|      c[j][i][2][3] = 0.0;
  307|  59.8M|      c[j][i][3][3] = - dt * tx2 * ( u[k][j][i-1][1] * tmp1 )
  308|  59.8M|        - dt * tx1 * ( c34 * tmp1 ) - dt * tx1 * dx4;
  309|  59.8M|      c[j][i][4][3] = 0.0;
  310|       |
  311|  59.8M|      c[j][i][0][4] = - dt * tx2
  312|  59.8M|        * ( ( C2 * 2.0 * qs[k][j][i-1] - C1 * u[k][j][i-1][4] )
  313|  59.8M|            * u[k][j][i-1][1] * tmp2 )
  314|  59.8M|        - dt * tx1
  315|  59.8M|        * ( - ( r43*c34 - c1345 ) * tmp3 * ( u[k][j][i-1][1]*u[k][j][i-1][1] )
  316|  59.8M|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i-1][2]*u[k][j][i-1][2] )
  317|  59.8M|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i-1][3]*u[k][j][i-1][3] )
  318|  59.8M|            - c1345 * tmp2 * u[k][j][i-1][4] );
  319|  59.8M|      c[j][i][1][4] = - dt * tx2
  320|  59.8M|        * ( C1 * ( u[k][j][i-1][4] * tmp1 )
  321|  59.8M|          - C2 * ( u[k][j][i-1][1]*u[k][j][i-1][1] * tmp2
  322|  59.8M|                 + qs[k][j][i-1] * tmp1 ) )
  323|  59.8M|        - dt * tx1 * ( r43*c34 - c1345 ) * tmp2 * u[k][j][i-1][1];
  324|  59.8M|      c[j][i][2][4] = - dt * tx2
  325|  59.8M|        * ( - C2 * ( u[k][j][i-1][2]*u[k][j][i-1][1] ) * tmp2 )
  326|  59.8M|        - dt * tx1 * (  c34 - c1345 ) * tmp2 * u[k][j][i-1][2];
  327|  59.8M|      c[j][i][3][4] = - dt * tx2
  328|  59.8M|        * ( - C2 * ( u[k][j][i-1][3]*u[k][j][i-1][1] ) * tmp2 )
  329|  59.8M|        - dt * tx1 * (  c34 - c1345 ) * tmp2 * u[k][j][i-1][3];
  330|  59.8M|      c[j][i][4][4] = - dt * tx2
  331|  59.8M|        * ( C1 * ( u[k][j][i-1][1] * tmp1 ) )
  332|  59.8M|        - dt * tx1 * c1345 * tmp1
  333|  59.8M|        - dt * tx1 * dx5;
  334|  59.8M|    }
  335|   964k|  }
  336|  15.5k|}
  337|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/jacu.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// compute the upper triangular part of the jacobian matrix
   38|       |//---------------------------------------------------------------------
   39|       |void jacu(int k)
   40|  15.5k|{
   41|       |  //---------------------------------------------------------------------
   42|       |  // local variables
   43|       |  //---------------------------------------------------------------------
   44|  15.5k|  int i, j;
   45|  15.5k|  double r43;
   46|  15.5k|  double c1345;
   47|  15.5k|  double c34;
   48|  15.5k|  double tmp1, tmp2, tmp3;
   49|       |
   50|  15.5k|  r43 = ( 4.0 / 3.0 );
   51|  15.5k|  c1345 = C1 * C3 * C4 * C5;
   52|  15.5k|  c34 = C3 * C4;
   53|       |
   54|   980k|  for (j = jst; j < jend; j++) {
   55|  60.7M|    for (i = ist; i < iend; i++) {
   56|       |      //---------------------------------------------------------------------
   57|       |      // form the block daigonal
   58|       |      //---------------------------------------------------------------------
   59|  59.8M|      tmp1 = rho_i[k][j][i];
   60|  59.8M|      tmp2 = tmp1 * tmp1;
   61|  59.8M|      tmp3 = tmp1 * tmp2;
   62|       |
   63|  59.8M|      d[j][i][0][0] = 1.0 + dt * 2.0 * ( tx1 * dx1 + ty1 * dy1 + tz1 * dz1 );
   64|  59.8M|      d[j][i][1][0] = 0.0;
   65|  59.8M|      d[j][i][2][0] = 0.0;
   66|  59.8M|      d[j][i][3][0] = 0.0;
   67|  59.8M|      d[j][i][4][0] = 0.0;
   68|       |
   69|  59.8M|      d[j][i][0][1] =  dt * 2.0
   70|  59.8M|        * ( - tx1 * r43 - ty1 - tz1 )
   71|  59.8M|        * ( c34 * tmp2 * u[k][j][i][1] );
   72|  59.8M|      d[j][i][1][1] =  1.0
   73|  59.8M|        + dt * 2.0 * c34 * tmp1 
   74|  59.8M|        * (  tx1 * r43 + ty1 + tz1 )
   75|  59.8M|        + dt * 2.0 * ( tx1 * dx2 + ty1 * dy2 + tz1 * dz2 );
   76|  59.8M|      d[j][i][2][1] = 0.0;
   77|  59.8M|      d[j][i][3][1] = 0.0;
   78|  59.8M|      d[j][i][4][1] = 0.0;
   79|       |
   80|  59.8M|      d[j][i][0][2] = dt * 2.0
   81|  59.8M|        * ( - tx1 - ty1 * r43 - tz1 )
   82|  59.8M|        * ( c34 * tmp2 * u[k][j][i][2] );
   83|  59.8M|      d[j][i][1][2] = 0.0;
   84|  59.8M|      d[j][i][2][2] = 1.0
   85|  59.8M|        + dt * 2.0 * c34 * tmp1
   86|  59.8M|        * (  tx1 + ty1 * r43 + tz1 )
   87|  59.8M|        + dt * 2.0 * ( tx1 * dx3 + ty1 * dy3 + tz1 * dz3 );
   88|  59.8M|      d[j][i][3][2] = 0.0;
   89|  59.8M|      d[j][i][4][2] = 0.0;
   90|       |
   91|  59.8M|      d[j][i][0][3] = dt * 2.0
   92|  59.8M|        * ( - tx1 - ty1 - tz1 * r43 )
   93|  59.8M|        * ( c34 * tmp2 * u[k][j][i][3] );
   94|  59.8M|      d[j][i][1][3] = 0.0;
   95|  59.8M|      d[j][i][2][3] = 0.0;
   96|  59.8M|      d[j][i][3][3] = 1.0
   97|  59.8M|        + dt * 2.0 * c34 * tmp1
   98|  59.8M|        * (  tx1 + ty1 + tz1 * r43 )
   99|  59.8M|        + dt * 2.0 * ( tx1 * dx4 + ty1 * dy4 + tz1 * dz4 );
  100|  59.8M|      d[j][i][4][3] = 0.0;
  101|       |
  102|  59.8M|      d[j][i][0][4] = -dt * 2.0
  103|  59.8M|        * ( ( ( tx1 * ( r43*c34 - c1345 )
  104|  59.8M|                + ty1 * ( c34 - c1345 )
  105|  59.8M|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][1]*u[k][j][i][1] )
  106|  59.8M|              + ( tx1 * ( c34 - c1345 )
  107|  59.8M|                + ty1 * ( r43*c34 - c1345 )
  108|  59.8M|                + tz1 * ( c34 - c1345 ) ) * ( u[k][j][i][2]*u[k][j][i][2] )
  109|  59.8M|              + ( tx1 * ( c34 - c1345 )
  110|  59.8M|                + ty1 * ( c34 - c1345 )
  111|  59.8M|                + tz1 * ( r43*c34 - c1345 ) ) * (u[k][j][i][3]*u[k][j][i][3])
  112|  59.8M|            ) * tmp3
  113|  59.8M|            + ( tx1 + ty1 + tz1 ) * c1345 * tmp2 * u[k][j][i][4] );
  114|       |
  115|  59.8M|      d[j][i][1][4] = dt * 2.0
  116|  59.8M|        * ( tx1 * ( r43*c34 - c1345 )
  117|  59.8M|          + ty1 * (     c34 - c1345 )
  118|  59.8M|          + tz1 * (     c34 - c1345 ) ) * tmp2 * u[k][j][i][1];
  119|  59.8M|      d[j][i][2][4] = dt * 2.0
  120|  59.8M|        * ( tx1 * ( c34 - c1345 )
  121|  59.8M|          + ty1 * ( r43*c34 -c1345 )
  122|  59.8M|          + tz1 * ( c34 - c1345 ) ) * tmp2 * u[k][j][i][2];
  123|  59.8M|      d[j][i][3][4] = dt * 2.0
  124|  59.8M|        * ( tx1 * ( c34 - c1345 )
  125|  59.8M|          + ty1 * ( c34 - c1345 )
  126|  59.8M|          + tz1 * ( r43*c34 - c1345 ) ) * tmp2 * u[k][j][i][3];
  127|  59.8M|      d[j][i][4][4] = 1.0
  128|  59.8M|        + dt * 2.0 * ( tx1 + ty1 + tz1 ) * c1345 * tmp1
  129|  59.8M|        + dt * 2.0 * ( tx1 * dx5 + ty1 * dy5 + tz1 * dz5 );
  130|       |
  131|       |      //---------------------------------------------------------------------
  132|       |      // form the first block sub-diagonal
  133|       |      //---------------------------------------------------------------------
  134|  59.8M|      tmp1 = rho_i[k][j][i+1];
  135|  59.8M|      tmp2 = tmp1 * tmp1;
  136|  59.8M|      tmp3 = tmp1 * tmp2;
  137|       |
  138|  59.8M|      a[j][i][0][0] = - dt * tx1 * dx1;
  139|  59.8M|      a[j][i][1][0] =   dt * tx2;
  140|  59.8M|      a[j][i][2][0] =   0.0;
  141|  59.8M|      a[j][i][3][0] =   0.0;
  142|  59.8M|      a[j][i][4][0] =   0.0;
  143|       |
  144|  59.8M|      a[j][i][0][1] =  dt * tx2
  145|  59.8M|        * ( - ( u[k][j][i+1][1] * tmp1 ) * ( u[k][j][i+1][1] * tmp1 )
  146|  59.8M|            + C2 * qs[k][j][i+1] * tmp1 )
  147|  59.8M|        - dt * tx1 * ( - r43 * c34 * tmp2 * u[k][j][i+1][1] );
  148|  59.8M|      a[j][i][1][1] =  dt * tx2
  149|  59.8M|        * ( ( 2.0 - C2 ) * ( u[k][j][i+1][1] * tmp1 ) )
  150|  59.8M|        - dt * tx1 * ( r43 * c34 * tmp1 )
  151|  59.8M|        - dt * tx1 * dx2;
  152|  59.8M|      a[j][i][2][1] =  dt * tx2
  153|  59.8M|        * ( - C2 * ( u[k][j][i+1][2] * tmp1 ) );
  154|  59.8M|      a[j][i][3][1] =  dt * tx2
  155|  59.8M|        * ( - C2 * ( u[k][j][i+1][3] * tmp1 ) );
  156|  59.8M|      a[j][i][4][1] =  dt * tx2 * C2 ;
  157|       |
  158|  59.8M|      a[j][i][0][2] =  dt * tx2
  159|  59.8M|        * ( - ( u[k][j][i+1][1] * u[k][j][i+1][2] ) * tmp2 )
  160|  59.8M|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i+1][2] );
  161|  59.8M|      a[j][i][1][2] =  dt * tx2 * ( u[k][j][i+1][2] * tmp1 );
  162|  59.8M|      a[j][i][2][2] =  dt * tx2 * ( u[k][j][i+1][1] * tmp1 )
  163|  59.8M|        - dt * tx1 * ( c34 * tmp1 )
  164|  59.8M|        - dt * tx1 * dx3;
  165|  59.8M|      a[j][i][3][2] = 0.0;
  166|  59.8M|      a[j][i][4][2] = 0.0;
  167|       |
  168|  59.8M|      a[j][i][0][3] = dt * tx2
  169|  59.8M|        * ( - ( u[k][j][i+1][1]*u[k][j][i+1][3] ) * tmp2 )
  170|  59.8M|        - dt * tx1 * ( - c34 * tmp2 * u[k][j][i+1][3] );
  171|  59.8M|      a[j][i][1][3] = dt * tx2 * ( u[k][j][i+1][3] * tmp1 );
  172|  59.8M|      a[j][i][2][3] = 0.0;
  173|  59.8M|      a[j][i][3][3] = dt * tx2 * ( u[k][j][i+1][1] * tmp1 )
  174|  59.8M|        - dt * tx1 * ( c34 * tmp1 )
  175|  59.8M|        - dt * tx1 * dx4;
  176|  59.8M|      a[j][i][4][3] = 0.0;
  177|       |
  178|  59.8M|      a[j][i][0][4] = dt * tx2
  179|  59.8M|        * ( ( C2 * 2.0 * qs[k][j][i+1]
  180|  59.8M|            - C1 * u[k][j][i+1][4] )
  181|  59.8M|        * ( u[k][j][i+1][1] * tmp2 ) )
  182|  59.8M|        - dt * tx1
  183|  59.8M|        * ( - ( r43*c34 - c1345 ) * tmp3 * ( u[k][j][i+1][1]*u[k][j][i+1][1] )
  184|  59.8M|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i+1][2]*u[k][j][i+1][2] )
  185|  59.8M|            - (     c34 - c1345 ) * tmp3 * ( u[k][j][i+1][3]*u[k][j][i+1][3] )
  186|  59.8M|            - c1345 * tmp2 * u[k][j][i+1][4] );
  187|  59.8M|      a[j][i][1][4] = dt * tx2
  188|  59.8M|        * ( C1 * ( u[k][j][i+1][4] * tmp1 )
  189|  59.8M|            - C2
  190|  59.8M|            * ( u[k][j][i+1][1]*u[k][j][i+1][1] * tmp2
  191|  59.8M|              + qs[k][j][i+1] * tmp1 ) )
  192|  59.8M|        - dt * tx1
  193|  59.8M|        * ( r43*c34 - c1345 ) * tmp2 * u[k][j][i+1][1];
  194|  59.8M|      a[j][i][2][4] = dt * tx2
  195|  59.8M|        * ( - C2 * ( u[k][j][i+1][2]*u[k][j][i+1][1] ) * tmp2 )
  196|  59.8M|        - dt * tx1
  197|  59.8M|        * (  c34 - c1345 ) * tmp2 * u[k][j][i+1][2];
  198|  59.8M|      a[j][i][3][4] = dt * tx2
  199|  59.8M|        * ( - C2 * ( u[k][j][i+1][3]*u[k][j][i+1][1] ) * tmp2 )
  200|  59.8M|        - dt * tx1
  201|  59.8M|        * (  c34 - c1345 ) * tmp2 * u[k][j][i+1][3];
  202|  59.8M|      a[j][i][4][4] = dt * tx2
  203|  59.8M|        * ( C1 * ( u[k][j][i+1][1] * tmp1 ) )
  204|  59.8M|        - dt * tx1 * c1345 * tmp1
  205|  59.8M|        - dt * tx1 * dx5;
  206|       |
  207|       |      //---------------------------------------------------------------------
  208|       |      // form the second block sub-diagonal
  209|       |      //---------------------------------------------------------------------
  210|  59.8M|      tmp1 = rho_i[k][j+1][i];
  211|  59.8M|      tmp2 = tmp1 * tmp1;
  212|  59.8M|      tmp3 = tmp1 * tmp2;
  213|       |
  214|  59.8M|      b[j][i][0][0] = - dt * ty1 * dy1;
  215|  59.8M|      b[j][i][1][0] =   0.0;
  216|  59.8M|      b[j][i][2][0] =  dt * ty2;
  217|  59.8M|      b[j][i][3][0] =   0.0;
  218|  59.8M|      b[j][i][4][0] =   0.0;
  219|       |
  220|  59.8M|      b[j][i][0][1] =  dt * ty2
  221|  59.8M|        * ( - ( u[k][j+1][i][1]*u[k][j+1][i][2] ) * tmp2 )
  222|  59.8M|        - dt * ty1 * ( - c34 * tmp2 * u[k][j+1][i][1] );
  223|  59.8M|      b[j][i][1][1] =  dt * ty2 * ( u[k][j+1][i][2] * tmp1 )
  224|  59.8M|        - dt * ty1 * ( c34 * tmp1 )
  225|  59.8M|        - dt * ty1 * dy2;
  226|  59.8M|      b[j][i][2][1] =  dt * ty2 * ( u[k][j+1][i][1] * tmp1 );
  227|  59.8M|      b[j][i][3][1] = 0.0;
  228|  59.8M|      b[j][i][4][1] = 0.0;
  229|       |
  230|  59.8M|      b[j][i][0][2] =  dt * ty2
  231|  59.8M|        * ( - ( u[k][j+1][i][2] * tmp1 ) * ( u[k][j+1][i][2] * tmp1 )
  232|  59.8M|            + C2 * ( qs[k][j+1][i] * tmp1 ) )
  233|  59.8M|        - dt * ty1 * ( - r43 * c34 * tmp2 * u[k][j+1][i][2] );
  234|  59.8M|      b[j][i][1][2] =  dt * ty2
  235|  59.8M|        * ( - C2 * ( u[k][j+1][i][1] * tmp1 ) );
  236|  59.8M|      b[j][i][2][2] =  dt * ty2 * ( ( 2.0 - C2 )
  237|  59.8M|          * ( u[k][j+1][i][2] * tmp1 ) )
  238|  59.8M|        - dt * ty1 * ( r43 * c34 * tmp1 )
  239|  59.8M|        - dt * ty1 * dy3;
  240|  59.8M|      b[j][i][3][2] =  dt * ty2
  241|  59.8M|        * ( - C2 * ( u[k][j+1][i][3] * tmp1 ) );
  242|  59.8M|      b[j][i][4][2] =  dt * ty2 * C2;
  243|       |
  244|  59.8M|      b[j][i][0][3] =  dt * ty2
  245|  59.8M|        * ( - ( u[k][j+1][i][2]*u[k][j+1][i][3] ) * tmp2 )
  246|  59.8M|        - dt * ty1 * ( - c34 * tmp2 * u[k][j+1][i][3] );
  247|  59.8M|      b[j][i][1][3] = 0.0;
  248|  59.8M|      b[j][i][2][3] =  dt * ty2 * ( u[k][j+1][i][3] * tmp1 );
  249|  59.8M|      b[j][i][3][3] =  dt * ty2 * ( u[k][j+1][i][2] * tmp1 )
  250|  59.8M|        - dt * ty1 * ( c34 * tmp1 )
  251|  59.8M|        - dt * ty1 * dy4;
  252|  59.8M|      b[j][i][4][3] = 0.0;
  253|       |
  254|  59.8M|      b[j][i][0][4] =  dt * ty2
  255|  59.8M|        * ( ( C2 * 2.0 * qs[k][j+1][i]
  256|  59.8M|            - C1 * u[k][j+1][i][4] )
  257|  59.8M|        * ( u[k][j+1][i][2] * tmp2 ) )
  258|  59.8M|        - dt * ty1
  259|  59.8M|        * ( - (     c34 - c1345 )*tmp3*(u[k][j+1][i][1]*u[k][j+1][i][1])
  260|  59.8M|            - ( r43*c34 - c1345 )*tmp3*(u[k][j+1][i][2]*u[k][j+1][i][2])
  261|  59.8M|            - (     c34 - c1345 )*tmp3*(u[k][j+1][i][3]*u[k][j+1][i][3])
  262|  59.8M|            - c1345*tmp2*u[k][j+1][i][4] );
  263|  59.8M|      b[j][i][1][4] =  dt * ty2
  264|  59.8M|        * ( - C2 * ( u[k][j+1][i][1]*u[k][j+1][i][2] ) * tmp2 )
  265|  59.8M|        - dt * ty1
  266|  59.8M|        * ( c34 - c1345 ) * tmp2 * u[k][j+1][i][1];
  267|  59.8M|      b[j][i][2][4] =  dt * ty2
  268|  59.8M|        * ( C1 * ( u[k][j+1][i][4] * tmp1 )
  269|  59.8M|            - C2 
  270|  59.8M|            * ( qs[k][j+1][i] * tmp1
  271|  59.8M|              + u[k][j+1][i][2]*u[k][j+1][i][2] * tmp2 ) )
  272|  59.8M|        - dt * ty1
  273|  59.8M|        * ( r43*c34 - c1345 ) * tmp2 * u[k][j+1][i][2];
  274|  59.8M|      b[j][i][3][4] =  dt * ty2
  275|  59.8M|        * ( - C2 * ( u[k][j+1][i][2]*u[k][j+1][i][3] ) * tmp2 )
  276|  59.8M|        - dt * ty1 * ( c34 - c1345 ) * tmp2 * u[k][j+1][i][3];
  277|  59.8M|      b[j][i][4][4] =  dt * ty2
  278|  59.8M|        * ( C1 * ( u[k][j+1][i][2] * tmp1 ) )
  279|  59.8M|        - dt * ty1 * c1345 * tmp1
  280|  59.8M|        - dt * ty1 * dy5;
  281|       |
  282|       |      //---------------------------------------------------------------------
  283|       |      // form the third block sub-diagonal
  284|       |      //---------------------------------------------------------------------
  285|  59.8M|      tmp1 = rho_i[k+1][j][i];
  286|  59.8M|      tmp2 = tmp1 * tmp1;
  287|  59.8M|      tmp3 = tmp1 * tmp2;
  288|       |
  289|  59.8M|      c[j][i][0][0] = - dt * tz1 * dz1;
  290|  59.8M|      c[j][i][1][0] =   0.0;
  291|  59.8M|      c[j][i][2][0] =   0.0;
  292|  59.8M|      c[j][i][3][0] = dt * tz2;
  293|  59.8M|      c[j][i][4][0] =   0.0;
  294|       |
  295|  59.8M|      c[j][i][0][1] = dt * tz2
  296|  59.8M|        * ( - ( u[k+1][j][i][1]*u[k+1][j][i][3] ) * tmp2 )
  297|  59.8M|        - dt * tz1 * ( - c34 * tmp2 * u[k+1][j][i][1] );
  298|  59.8M|      c[j][i][1][1] = dt * tz2 * ( u[k+1][j][i][3] * tmp1 )
  299|  59.8M|        - dt * tz1 * c34 * tmp1
  300|  59.8M|        - dt * tz1 * dz2;
  301|  59.8M|      c[j][i][2][1] = 0.0;
  302|  59.8M|      c[j][i][3][1] = dt * tz2 * ( u[k+1][j][i][1] * tmp1 );
  303|  59.8M|      c[j][i][4][1] = 0.0;
  304|       |
  305|  59.8M|      c[j][i][0][2] = dt * tz2
  306|  59.8M|        * ( - ( u[k+1][j][i][2]*u[k+1][j][i][3] ) * tmp2 )
  307|  59.8M|        - dt * tz1 * ( - c34 * tmp2 * u[k+1][j][i][2] );
  308|  59.8M|      c[j][i][1][2] = 0.0;
  309|  59.8M|      c[j][i][2][2] = dt * tz2 * ( u[k+1][j][i][3] * tmp1 )
  310|  59.8M|        - dt * tz1 * ( c34 * tmp1 )
  311|  59.8M|        - dt * tz1 * dz3;
  312|  59.8M|      c[j][i][3][2] = dt * tz2 * ( u[k+1][j][i][2] * tmp1 );
  313|  59.8M|      c[j][i][4][2] = 0.0;
  314|       |
  315|  59.8M|      c[j][i][0][3] = dt * tz2
  316|  59.8M|        * ( - ( u[k+1][j][i][3] * tmp1 ) * ( u[k+1][j][i][3] * tmp1 )
  317|  59.8M|            + C2 * ( qs[k+1][j][i] * tmp1 ) )
  318|  59.8M|        - dt * tz1 * ( - r43 * c34 * tmp2 * u[k+1][j][i][3] );
  319|  59.8M|      c[j][i][1][3] = dt * tz2
  320|  59.8M|        * ( - C2 * ( u[k+1][j][i][1] * tmp1 ) );
  321|  59.8M|      c[j][i][2][3] = dt * tz2
  322|  59.8M|        * ( - C2 * ( u[k+1][j][i][2] * tmp1 ) );
  323|  59.8M|      c[j][i][3][3] = dt * tz2 * ( 2.0 - C2 )
  324|  59.8M|        * ( u[k+1][j][i][3] * tmp1 )
  325|  59.8M|        - dt * tz1 * ( r43 * c34 * tmp1 )
  326|  59.8M|        - dt * tz1 * dz4;
  327|  59.8M|      c[j][i][4][3] = dt * tz2 * C2;
  328|       |
  329|  59.8M|      c[j][i][0][4] = dt * tz2
  330|  59.8M|        * ( ( C2 * 2.0 * qs[k+1][j][i]
  331|  59.8M|            - C1 * u[k+1][j][i][4] )
  332|  59.8M|                 * ( u[k+1][j][i][3] * tmp2 ) )
  333|  59.8M|        - dt * tz1
  334|  59.8M|        * ( - ( c34 - c1345 ) * tmp3 * (u[k+1][j][i][1]*u[k+1][j][i][1])
  335|  59.8M|            - ( c34 - c1345 ) * tmp3 * (u[k+1][j][i][2]*u[k+1][j][i][2])
  336|  59.8M|            - ( r43*c34 - c1345 )* tmp3 * (u[k+1][j][i][3]*u[k+1][j][i][3])
  337|  59.8M|            - c1345 * tmp2 * u[k+1][j][i][4] );
  338|  59.8M|      c[j][i][1][4] = dt * tz2
  339|  59.8M|        * ( - C2 * ( u[k+1][j][i][1]*u[k+1][j][i][3] ) * tmp2 )
  340|  59.8M|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k+1][j][i][1];
  341|  59.8M|      c[j][i][2][4] = dt * tz2
  342|  59.8M|        * ( - C2 * ( u[k+1][j][i][2]*u[k+1][j][i][3] ) * tmp2 )
  343|  59.8M|        - dt * tz1 * ( c34 - c1345 ) * tmp2 * u[k+1][j][i][2];
  344|  59.8M|      c[j][i][3][4] = dt * tz2
  345|  59.8M|        * ( C1 * ( u[k+1][j][i][4] * tmp1 )
  346|  59.8M|            - C2
  347|  59.8M|            * ( qs[k+1][j][i] * tmp1
  348|  59.8M|              + u[k+1][j][i][3]*u[k+1][j][i][3] * tmp2 ) )
  349|  59.8M|        - dt * tz1 * ( r43*c34 - c1345 ) * tmp2 * u[k+1][j][i][3];
  350|  59.8M|      c[j][i][4][4] = dt * tz2
  351|  59.8M|        * ( C1 * ( u[k+1][j][i][3] * tmp1 ) )
  352|  59.8M|        - dt * tz1 * c1345 * tmp1
  353|  59.8M|        - dt * tz1 * dz5;
  354|  59.8M|    }
  355|   964k|  }
  356|  15.5k|}
  357|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/l2norm.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <math.h>
   35|       |#include "applu.incl"
   36|       |
   37|       |//---------------------------------------------------------------------
   38|       |// to compute the l2-norm of vector v.
   39|       |//---------------------------------------------------------------------
   40|       |//---------------------------------------------------------------------
   41|       |// To improve cache performance, second two dimensions padded by 1 
   42|       |// for even number sizes only.  Only needed in v.
   43|       |//---------------------------------------------------------------------
   44|       |void l2norm (int ldx, int ldy, int ldz, int nx0, int ny0, int nz0,
   45|       |     int ist, int iend, int jst, int jend,
   46|       |     double v[][ldy/2*2+1][ldx/2*2+1][5], double sum[5])
   47|      4|{
   48|       |  //---------------------------------------------------------------------
   49|       |  // local variables
   50|       |  //---------------------------------------------------------------------
   51|      4|  int i, j, k, m;
   52|       |
   53|     24|  for (m = 0; m < 5; m++) {
   54|     20|    sum[m] = 0.0;
   55|     20|  }
   56|       |
   57|    252|  for (k = 1; k < nz0-1; k++) {
   58|  15.6k|    for (j = jst; j < jend; j++) {
   59|   968k|      for (i = ist; i < iend; i++) {
   60|  5.71M|        for (m = 0; m < 5; m++) {
   61|  4.76M|          sum[m] = sum[m] + v[k][j][i][m] * v[k][j][i][m];
   62|  4.76M|        }
   63|   953k|      }
   64|  15.3k|    }
   65|    248|  }
   66|       |
   67|     24|  for (m = 0; m < 5; m++) {
   68|     20|    sum[m] = sqrt ( sum[m] / ( (nx0-2)*(ny0-2)*(nz0-2) ) );
   69|     20|  }
   70|      4|}
   71|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/lu.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |//---------------------------------------------------------------------
   35|       |//   program applu
   36|       |//---------------------------------------------------------------------
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |//
   40|       |//   driver for the performance evaluation of the solver for
   41|       |//   five coupled parabolic/elliptic partial differential equations.
   42|       |//
   43|       |//---------------------------------------------------------------------
   44|       |
   45|       |#include <stdio.h>
   46|       |#include <stdlib.h>
   47|       |#include <math.h>
   48|       |
   49|       |#include "applu.incl"
   50|       |#include "timers.h"
   51|       |#include "print_results.h"
   52|       |
   53|       |
   54|       |//---------------------------------------------------------------------
   55|       |// grid
   56|       |//---------------------------------------------------------------------
   57|       |/* common/cgcon/ */
   58|       |double dxi, deta, dzeta;
   59|       |double tx1, tx2, tx3;
   60|       |double ty1, ty2, ty3;
   61|       |double tz1, tz2, tz3;
   62|       |int nx, ny, nz;
   63|       |int nx0, ny0, nz0;
   64|       |int ist, iend;
   65|       |int jst, jend;
   66|       |int ii1, ii2;
   67|       |int ji1, ji2;
   68|       |int ki1, ki2;
   69|       |
   70|       |//---------------------------------------------------------------------
   71|       |// dissipation
   72|       |//---------------------------------------------------------------------
   73|       |/* common/disp/ */
   74|       |double dx1, dx2, dx3, dx4, dx5;
   75|       |double dy1, dy2, dy3, dy4, dy5;
   76|       |double dz1, dz2, dz3, dz4, dz5;
   77|       |double dssp;
   78|       |
   79|       |//---------------------------------------------------------------------
   80|       |// field variables and residuals
   81|       |// to improve cache performance, second two dimensions padded by 1 
   82|       |// for even number sizes only.
   83|       |// Note: corresponding array (called "v") in routines blts, buts, 
   84|       |// and l2norm are similarly padded
   85|       |//---------------------------------------------------------------------
   86|       |/* common/cvar/ */
   87|       |double u    [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   88|       |double rsd  [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   89|       |double frct [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1][5];
   90|       |double flux [ISIZ1][5];
   91|       |double qs   [ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
   92|       |double rho_i[ISIZ3][ISIZ2/2*2+1][ISIZ1/2*2+1];
   93|       |
   94|       |//---------------------------------------------------------------------
   95|       |// output control parameters
   96|       |//---------------------------------------------------------------------
   97|       |/* common/cprcon/ */
   98|       |int ipr, inorm;
   99|       |
  100|       |//---------------------------------------------------------------------
  101|       |// newton-raphson iteration control parameters
  102|       |//---------------------------------------------------------------------
  103|       |/* common/ctscon/ */
  104|       |double dt, omega, tolrsd[5], rsdnm[5], errnm[5], frc, ttotal;
  105|       |int itmax, invert;
  106|       |
  107|       |/* common/cjac/ */
  108|       |double a[ISIZ2][ISIZ1/2*2+1][5][5];
  109|       |double b[ISIZ2][ISIZ1/2*2+1][5][5];
  110|       |double c[ISIZ2][ISIZ1/2*2+1][5][5];
  111|       |double d[ISIZ2][ISIZ1/2*2+1][5][5];
  112|       |
  113|       |
  114|       |//---------------------------------------------------------------------
  115|       |// coefficients of the exact solution
  116|       |//---------------------------------------------------------------------
  117|       |/* common/cexact/ */
  118|       |double ce[5][13];
  119|       |
  120|       |
  121|       |//---------------------------------------------------------------------
  122|       |// timers
  123|       |//---------------------------------------------------------------------
  124|       |/* common/timer/ */
  125|       |double maxtime;
  126|       |logical timeron;
  127|       |
  128|       |
  129|       |int main(int argc, char *argv[])
  130|      1|{
  131|      1|  char Class;
  132|      1|  logical verified;
  133|      1|  double mflops;
  134|       |
  135|      1|  double t, tmax, trecs[t_last+1];
  136|      1|  int i;
  137|      1|  char *t_names[t_last+1];
  138|       |
  139|       |  //---------------------------------------------------------------------
  140|       |  // Setup info for timers
  141|       |  //---------------------------------------------------------------------
  142|      1|  FILE *fp;
  143|      1|  if ((fp = fopen("timer.flag", "r")) != NULL) {
  144|      0|    timeron = true;
  145|      0|    t_names[t_total] = "total";
  146|      0|    t_names[t_rhsx] = "rhsx";
  147|      0|    t_names[t_rhsy] = "rhsy";
  148|      0|    t_names[t_rhsz] = "rhsz";
  149|      0|    t_names[t_rhs] = "rhs";
  150|      0|    t_names[t_jacld] = "jacld";
  151|      0|    t_names[t_blts] = "blts";
  152|      0|    t_names[t_jacu] = "jacu";
  153|      0|    t_names[t_buts] = "buts";
  154|      0|    t_names[t_add] = "add";
  155|      0|    t_names[t_l2norm] = "l2norm";
  156|      0|    fclose(fp);
  157|      1|  } else {
  158|      1|    timeron = false;
  159|      1|  }
  160|       |
  161|       |  //---------------------------------------------------------------------
  162|       |  // read input data
  163|       |  //---------------------------------------------------------------------
  164|      1|  read_input();
  165|       |
  166|       |  //---------------------------------------------------------------------
  167|       |  // set up domain sizes
  168|       |  //---------------------------------------------------------------------
  169|      1|  domain();
  170|       |
  171|       |  //---------------------------------------------------------------------
  172|       |  // set up coefficients
  173|       |  //---------------------------------------------------------------------
  174|      1|  setcoeff();
  175|       |
  176|       |  //---------------------------------------------------------------------
  177|       |  // set the boundary values for dependent variables
  178|       |  //---------------------------------------------------------------------
  179|      1|  setbv();
  180|       |
  181|       |  //---------------------------------------------------------------------
  182|       |  // set the initial values for dependent variables
  183|       |  //---------------------------------------------------------------------
  184|      1|  setiv();
  185|       |
  186|       |  //---------------------------------------------------------------------
  187|       |  // compute the forcing term based on prescribed exact solution
  188|       |  //---------------------------------------------------------------------
  189|      1|  erhs();
  190|       |
  191|       |  //---------------------------------------------------------------------
  192|       |  // perform one SSOR iteration to touch all pages
  193|       |  //---------------------------------------------------------------------
  194|      1|  ssor(1);
  195|       |
  196|       |  //---------------------------------------------------------------------
  197|       |  // reset the boundary and initial values
  198|       |  //---------------------------------------------------------------------
  199|      1|  setbv();
  200|      1|  setiv();
  201|       |
  202|       |  //---------------------------------------------------------------------
  203|       |  // perform the SSOR iterations
  204|       |  //---------------------------------------------------------------------
  205|      1|  ssor(itmax);
  206|       |
  207|       |  //---------------------------------------------------------------------
  208|       |  // compute the solution error
  209|       |  //---------------------------------------------------------------------
  210|      1|  error();
  211|       |
  212|       |  //---------------------------------------------------------------------
  213|       |  // compute the surface integral
  214|       |  //---------------------------------------------------------------------
  215|      1|  pintgr();
  216|       |
  217|       |  //---------------------------------------------------------------------
  218|       |  // verification test
  219|       |  //---------------------------------------------------------------------
  220|      1|  verify ( rsdnm, errnm, frc, &Class, &verified );
  221|      1|  mflops = (double)itmax * (1984.77 * (double)nx0
  222|      1|      * (double)ny0
  223|      1|      * (double)nz0
  224|      1|      - 10923.3 * pow(((double)(nx0+ny0+nz0)/3.0), 2.0) 
  225|      1|      + 27770.9 * (double)(nx0+ny0+nz0)/3.0
  226|      1|      - 144010.0)
  227|      1|    / (maxtime*1000000.0);
  228|       |
  229|      1|  print_results("LU", Class, nx0,
  230|      1|                ny0, nz0, itmax,
  231|      1|                maxtime, mflops, "          floating point", verified, 
  232|      1|                NPBVERSION, COMPILETIME, CS1, CS2, CS3, CS4, CS5, CS6, 
  233|      1|                "(none)");
  234|       |
  235|       |  //---------------------------------------------------------------------
  236|       |  // More timers
  237|       |  //---------------------------------------------------------------------
  238|      1|  if (timeron) {
  239|      0|    for (i = 1; i <= t_last; i++) {
  240|      0|      trecs[i] = timer_read(i);
  241|      0|    }
  242|      0|    tmax = maxtime;
  243|      0|    if (tmax == 0.0) tmax = 1.0;
  244|       |
  245|      0|    printf("  SECTION     Time (secs)\n");
  246|      0|    for (i = 1; i <= t_last; i++) {
  247|      0|      printf("  %-8s:%9.3f  (%6.2f%%)\n",
  248|      0|          t_names[i], trecs[i], trecs[i]*100./tmax);
  249|      0|      if (i == t_rhs) {
  250|      0|        t = trecs[t_rhsx] + trecs[t_rhsy] + trecs[t_rhsz];
  251|      0|        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "sub-rhs", t, t*100./tmax);
  252|      0|        t = trecs[i] - t;
  253|      0|        printf("     --> %8s:%9.3f  (%6.2f%%)\n", "rest-rhs", t, t*100./tmax);
  254|      0|      }
  255|      0|    }
  256|      0|  }
  257|       |
  258|      1|  return 0;
  259|      1|}
  260|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/npbparams.h:
    1|       |/* CLASS = A */
    2|       |/*
    3|       |   This file is generated automatically by the setparams utility.
    4|       |   It sets the number of processors and the class of the NPB
    5|       |   in this directory. Do not modify it by hand.   
    6|       |*/
    7|       |
    8|       |/* full problem size */
    9|  39.4k|#define ISIZ1  64
   10|  44.5k|#define ISIZ2  64
   11|  31.3k|#define ISIZ3  64
   12|       |
   13|       |/* number of iterations and how often to print the norm */
   14|      1|#define ITMAX_DEFAULT  250
   15|      1|#define INORM_DEFAULT  250
   16|      1|#define DT_DEFAULT     2.0
   17|       |
   18|       |#define CONVERTDOUBLE  false
   19|      1|#define COMPILETIME "05 Apr 2024"
   20|      1|#define NPBVERSION "3.3.1"
   21|      1|#define CS1 "clang"
   22|      1|#define CS2 "clang"
   23|      1|#define CS3 "-lm"
   24|      1|#define CS4 "-I ../common"
   25|      1|#define CS5 "-c -g -O3 -fprofile-instr-generate -fcovera..."
   26|      1|#define CS6 "-O3 -fprofile-instr-generate -fcoverage-map..."
   27|       |#define CS7 "randdp"

/home/dvmuser3/andrey/npb-3.3-c/LU/pintgr.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include "applu.incl"
   36|       |
   37|       |void pintgr()
   38|      1|{
   39|       |  //---------------------------------------------------------------------
   40|       |  // local variables
   41|       |  //---------------------------------------------------------------------
   42|      1|  int i, j, k;
   43|      1|  int ibeg, ifin, ifin1;
   44|      1|  int jbeg, jfin, jfin1;
   45|      1|  double phi1[ISIZ3+2][ISIZ2+2];
   46|      1|  double phi2[ISIZ3+2][ISIZ2+2];
   47|      1|  double frc1, frc2, frc3;
   48|       |
   49|       |  //---------------------------------------------------------------------
   50|       |  // set up the sub-domains for integeration in each processor
   51|       |  //---------------------------------------------------------------------
   52|      1|  ibeg = ii1;
   53|      1|  ifin = ii2;
   54|      1|  jbeg = ji1;
   55|      1|  jfin = ji2;
   56|      1|  ifin1 = ifin - 1;
   57|      1|  jfin1 = jfin - 1;
   58|       |
   59|       |  //---------------------------------------------------------------------
   60|       |  // initialize
   61|       |  //---------------------------------------------------------------------
   62|     67|  for (k = 0; k <= ISIZ3+1; k++) {
   63|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
   64|  4.35k|      phi1[k][i] = 0.0;
   65|  4.35k|      phi2[k][i] = 0.0;
   66|  4.35k|    }
   67|     66|  }
   68|       |
   69|     62|  for (j = jbeg; j < jfin; j++) {
   70|  3.84k|    for (i = ibeg; i < ifin; i++) {
   71|  3.78k|      k = ki1;
   72|       |
   73|  3.78k|      phi1[j][i] = C2*(  u[k][j][i][4]
   74|  3.78k|          - 0.50 * (  u[k][j][i][1] * u[k][j][i][1]
   75|  3.78k|                    + u[k][j][i][2] * u[k][j][i][2]
   76|  3.78k|                    + u[k][j][i][3] * u[k][j][i][3] )
   77|  3.78k|                   / u[k][j][i][0] );
   78|       |
   79|  3.78k|      k = ki2 - 1;
   80|       |
   81|  3.78k|      phi2[j][i] = C2*(  u[k][j][i][4]
   82|  3.78k|          - 0.50 * (  u[k][j][i][1] * u[k][j][i][1]
   83|  3.78k|                    + u[k][j][i][2] * u[k][j][i][2]
   84|  3.78k|                    + u[k][j][i][3] * u[k][j][i][3] )
   85|  3.78k|                   / u[k][j][i][0] );
   86|  3.78k|    }
   87|     61|  }
   88|       |
   89|      1|  frc1 = 0.0;
   90|     61|  for (j = jbeg; j < jfin1; j++) {
   91|  3.72k|    for (i = ibeg; i < ifin1; i++) {
   92|  3.66k|      frc1 = frc1 + (  phi1[j][i]
   93|  3.66k|                     + phi1[j][i+1]
   94|  3.66k|                     + phi1[j+1][i]
   95|  3.66k|                     + phi1[j+1][i+1]
   96|  3.66k|                     + phi2[j][i]
   97|  3.66k|                     + phi2[j][i+1]
   98|  3.66k|                     + phi2[j+1][i]
   99|  3.66k|                     + phi2[j+1][i+1] );
  100|  3.66k|    }
  101|     60|  }
  102|      1|  frc1 = dxi * deta * frc1;
  103|       |
  104|       |  //---------------------------------------------------------------------
  105|       |  // initialize
  106|       |  //---------------------------------------------------------------------
  107|     67|  for (k = 0; k <= ISIZ3+1; k++) {
  108|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
  109|  4.35k|      phi1[k][i] = 0.0;
  110|  4.35k|      phi2[k][i] = 0.0;
  111|  4.35k|    }
  112|     66|  }
  113|      1|  if (jbeg == ji1) {
  114|     62|    for (k = ki1; k < ki2; k++) {
  115|  3.84k|      for (i = ibeg; i < ifin; i++) {
  116|  3.78k|        phi1[k][i] = C2*(  u[k][jbeg][i][4]
  117|  3.78k|            - 0.50 * (  u[k][jbeg][i][1] * u[k][jbeg][i][1]
  118|  3.78k|                      + u[k][jbeg][i][2] * u[k][jbeg][i][2]
  119|  3.78k|                      + u[k][jbeg][i][3] * u[k][jbeg][i][3] )
  120|  3.78k|                     / u[k][jbeg][i][0] );
  121|  3.78k|      }
  122|     61|    }
  123|      1|  }
  124|       |
  125|      1|  if (jfin == ji2) {
  126|     62|    for (k = ki1; k < ki2; k++) {
  127|  3.84k|      for (i = ibeg; i < ifin; i++) {
  128|  3.78k|        phi2[k][i] = C2*(  u[k][jfin-1][i][4]
  129|  3.78k|            - 0.50 * (  u[k][jfin-1][i][1] * u[k][jfin-1][i][1]
  130|  3.78k|                      + u[k][jfin-1][i][2] * u[k][jfin-1][i][2]
  131|  3.78k|                      + u[k][jfin-1][i][3] * u[k][jfin-1][i][3] )
  132|  3.78k|                     / u[k][jfin-1][i][0] );
  133|  3.78k|      }
  134|     61|    }
  135|      1|  }
  136|       |
  137|      1|  frc2 = 0.0;
  138|     61|  for (k = ki1; k < ki2-1; k++) {
  139|  3.72k|    for (i = ibeg; i < ifin1; i++) {
  140|  3.66k|      frc2 = frc2 + (  phi1[k][i]
  141|  3.66k|                     + phi1[k][i+1]
  142|  3.66k|                     + phi1[k+1][i]
  143|  3.66k|                     + phi1[k+1][i+1]
  144|  3.66k|                     + phi2[k][i]
  145|  3.66k|                     + phi2[k][i+1]
  146|  3.66k|                     + phi2[k+1][i]
  147|  3.66k|                     + phi2[k+1][i+1] );
  148|  3.66k|    }
  149|     60|  }
  150|      1|  frc2 = dxi * dzeta * frc2;
  151|       |
  152|       |  //---------------------------------------------------------------------
  153|       |  // initialize
  154|       |  //---------------------------------------------------------------------
  155|     67|  for (k = 0; k <= ISIZ3+1; k++) {
  156|  4.42k|    for (i = 0; i <= ISIZ2+1; i++) {
  157|  4.35k|      phi1[k][i] = 0.0;
  158|  4.35k|      phi2[k][i] = 0.0;
  159|  4.35k|    }
  160|     66|  }
  161|      1|  if (ibeg == ii1) {
  162|     62|    for (k = ki1; k < ki2; k++) {
  163|  3.78k|      for (j = jbeg; j < jfin; j++) {
  164|  3.72k|        phi1[k][j] = C2*(  u[k][j][ibeg][4]
  165|  3.72k|            - 0.50 * (  u[k][j][ibeg][1] * u[k][j][ibeg][1]
  166|  3.72k|                      + u[k][j][ibeg][2] * u[k][j][ibeg][2]
  167|  3.72k|                      + u[k][j][ibeg][3] * u[k][j][ibeg][3] )
  168|  3.72k|                     / u[k][j][ibeg][0] );
  169|  3.72k|      }
  170|     61|    }
  171|      1|  }
  172|       |
  173|      1|  if (ifin == ii2) {
  174|     62|    for (k = ki1; k < ki2; k++) {
  175|  3.78k|      for (j = jbeg; j < jfin; j++) {
  176|  3.72k|        phi2[k][j] = C2*(  u[k][j][ifin-1][4]
  177|  3.72k|            - 0.50 * (  u[k][j][ifin-1][1] * u[k][j][ifin-1][1]
  178|  3.72k|                      + u[k][j][ifin-1][2] * u[k][j][ifin-1][2]
  179|  3.72k|                      + u[k][j][ifin-1][3] * u[k][j][ifin-1][3] )
  180|  3.72k|                     / u[k][j][ifin-1][0] );
  181|  3.72k|      }
  182|     61|    }
  183|      1|  }
  184|       |
  185|      1|  frc3 = 0.0;
  186|     61|  for (k = ki1; k < ki2-1; k++) {
  187|  3.66k|    for (j = jbeg; j < jfin1; j++) {
  188|  3.60k|      frc3 = frc3 + (  phi1[k][j]
  189|  3.60k|                     + phi1[k][j+1]
  190|  3.60k|                     + phi1[k+1][j]
  191|  3.60k|                     + phi1[k+1][j+1]
  192|  3.60k|                     + phi2[k][j]
  193|  3.60k|                     + phi2[k][j+1]
  194|  3.60k|                     + phi2[k+1][j]
  195|  3.60k|                     + phi2[k+1][j+1] );
  196|  3.60k|    }
  197|     60|  }
  198|      1|  frc3 = deta * dzeta * frc3;
  199|       |
  200|      1|  frc = 0.25 * ( frc1 + frc2 + frc3 );
  201|       |  //printf("\n\n     surface integral = %12.5E\n\n\n", frc);
  202|      1|}
  203|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/read_input.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <stdlib.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |void read_input()
   39|      1|{
   40|      1|  FILE *fp;
   41|      1|  int result;
   42|       |
   43|       |  //---------------------------------------------------------------------
   44|       |  // if input file does not exist, it uses defaults
   45|       |  //    ipr = 1 for detailed progress output
   46|       |  //    inorm = how often the norm is printed (once every inorm iterations)
   47|       |  //    itmax = number of pseudo time steps
   48|       |  //    dt = time step
   49|       |  //    omega 1 over-relaxation factor for SSOR
   50|       |  //    tolrsd = steady state residual tolerance levels
   51|       |  //    nx, ny, nz = number of grid points in x, y, z directions
   52|       |  //---------------------------------------------------------------------
   53|       |
   54|      1|  printf("\n\n NAS Parallel Benchmarks (NPB3.3-SER-C) - LU Benchmark\n\n");
   55|       |
   56|      1|  if ((fp = fopen("inputlu.data", "r")) != NULL) {
   57|      0|    printf("Reading from input file inputlu.data\n");
   58|       |
   59|      0|    while (fgetc(fp) != '\n');
   60|      0|    while (fgetc(fp) != '\n');
   61|      0|    result = fscanf(fp, "%d%d", &ipr, &inorm); 
   62|      0|    while (fgetc(fp) != '\n');
   63|       |
   64|      0|    while (fgetc(fp) != '\n');
   65|      0|    while (fgetc(fp) != '\n');
   66|      0|    result = fscanf(fp, "%d", &itmax);
   67|      0|    while (fgetc(fp) != '\n');
   68|       |
   69|      0|    while (fgetc(fp) != '\n');
   70|      0|    while (fgetc(fp) != '\n');
   71|      0|    result = fscanf(fp, "%lf", &dt);
   72|      0|    while (fgetc(fp) != '\n');
   73|       |
   74|      0|    while (fgetc(fp) != '\n');
   75|      0|    while (fgetc(fp) != '\n');
   76|      0|    result = fscanf(fp, "%lf", &omega);
   77|      0|    while (fgetc(fp) != '\n');
   78|       |
   79|      0|    while (fgetc(fp) != '\n');
   80|      0|    while (fgetc(fp) != '\n');
   81|      0|    result = fscanf(fp, "%lf%lf%lf%lf%lf",
   82|      0|        &tolrsd[0], &tolrsd[1], &tolrsd[2], &tolrsd[3], &tolrsd[4]);
   83|      0|    while (fgetc(fp) != '\n');
   84|      0|    while (fgetc(fp) != '\n');
   85|      0|    result = fscanf(fp, "%d%d%d", &nx0, &ny0, &nz0);
   86|      0|    fclose(fp);
   87|      1|  } else {
   88|      1|    ipr = IPR_DEFAULT;
   89|      1|    inorm = INORM_DEFAULT;
   90|      1|    itmax = ITMAX_DEFAULT;
   91|      1|    dt = DT_DEFAULT;
   92|      1|    omega = OMEGA_DEFAULT;
   93|      1|    tolrsd[0] = TOLRSD1_DEF;
   94|      1|    tolrsd[1] = TOLRSD2_DEF;
   95|      1|    tolrsd[2] = TOLRSD3_DEF;
   96|      1|    tolrsd[3] = TOLRSD4_DEF;
   97|      1|    tolrsd[4] = TOLRSD5_DEF;
   98|      1|    nx0 = ISIZ1;
   99|      1|    ny0 = ISIZ2;
  100|      1|    nz0 = ISIZ3;
  101|      1|  }
  102|       |
  103|       |  //---------------------------------------------------------------------
  104|       |  // check problem size
  105|       |  //---------------------------------------------------------------------
  106|      1|  if ( ( nx0 < 4 ) || ( ny0 < 4 ) || ( nz0 < 4 ) ) {
  107|      0|    printf("     PROBLEM SIZE IS TOO SMALL - \n"
  108|      0|           "     SET EACH OF NX, NY AND NZ AT LEAST EQUAL TO 5\n");
  109|      0|    exit(EXIT_FAILURE);
  110|      0|  }
  111|       |
  112|      1|  if ( ( nx0 > ISIZ1 ) || ( ny0 > ISIZ2 ) || ( nz0 > ISIZ3 ) ) {
  113|      0|    printf("     PROBLEM SIZE IS TOO LARGE - \n"
  114|      0|           "     NX, NY AND NZ SHOULD BE EQUAL TO \n"
  115|      0|           "     ISIZ1, ISIZ2 AND ISIZ3 RESPECTIVELY\n");
  116|      0|    exit(EXIT_FAILURE);
  117|      0|  }
  118|       |
  119|      1|  printf(" Size: %4dx%4dx%4d\n", nx0, ny0, nz0);
  120|      1|  printf(" Iterations: %4d\n", itmax);
  121|      1|  printf("\n");
  122|      1|}

/home/dvmuser3/andrey/npb-3.3-c/LU/rhs.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |#include "timers.h"
   36|       |
   37|       |//---------------------------------------------------------------------
   38|       |// compute the right hand sides
   39|       |//---------------------------------------------------------------------
   40|       |void rhs()
   41|    253|{
   42|       |  //---------------------------------------------------------------------
   43|       |  // local variables
   44|       |  //---------------------------------------------------------------------
   45|    253|  int i, j, k, m;
   46|    253|  double q;
   47|    253|  double tmp, utmp[ISIZ3][6], rtmp[ISIZ3][5];
   48|    253|  double u21, u31, u41;
   49|    253|  double u21i, u31i, u41i, u51i;
   50|    253|  double u21j, u31j, u41j, u51j;
   51|    253|  double u21k, u31k, u41k, u51k;
   52|    253|  double u21im1, u31im1, u41im1, u51im1;
   53|    253|  double u21jm1, u31jm1, u41jm1, u51jm1;
   54|    253|  double u21km1, u31km1, u41km1, u51km1;
   55|       |
   56|    253|  if (timeron) timer_start(t_rhs);
   57|  16.4k|  for (k = 0; k < nz; k++) {
   58|  1.05M|    for (j = 0; j < ny; j++) {
   59|  67.3M|      for (i = 0; i < nx; i++) {
   60|   397M|        for (m = 0; m < 5; m++) {
   61|   331M|          rsd[k][j][i][m] = - frct[k][j][i][m];
   62|   331M|        }
   63|  66.3M|        tmp = 1.0 / u[k][j][i][0];
   64|  66.3M|        rho_i[k][j][i] = tmp;
   65|  66.3M|        qs[k][j][i] = 0.50 * (  u[k][j][i][1] * u[k][j][i][1]
   66|  66.3M|                              + u[k][j][i][2] * u[k][j][i][2]
   67|  66.3M|                              + u[k][j][i][3] * u[k][j][i][3] )
   68|  66.3M|                           * tmp;
   69|  66.3M|      }
   70|  1.03M|    }
   71|  16.1k|  }
   72|       |
   73|    253|  if (timeron) timer_start(t_rhsx);
   74|       |  //---------------------------------------------------------------------
   75|       |  // xi-direction flux differences
   76|       |  //---------------------------------------------------------------------
   77|  15.9k|  for (k = 1; k < nz - 1; k++) {
   78|   988k|    for (j = jst; j < jend; j++) {
   79|  63.2M|      for (i = 0; i < nx; i++) {
   80|  62.2M|        flux[i][0] = u[k][j][i][1];
   81|  62.2M|        u21 = u[k][j][i][1] * rho_i[k][j][i];
   82|       |
   83|  62.2M|        q = qs[k][j][i];
   84|       |
   85|  62.2M|        flux[i][1] = u[k][j][i][1] * u21 + C2 * ( u[k][j][i][4] - q );
   86|  62.2M|        flux[i][2] = u[k][j][i][2] * u21;
   87|  62.2M|        flux[i][3] = u[k][j][i][3] * u21;
   88|  62.2M|        flux[i][4] = ( C1 * u[k][j][i][4] - C2 * q ) * u21;
   89|  62.2M|      }
   90|       |
   91|  61.2M|      for (i = ist; i < iend; i++) {
   92|   361M|        for (m = 0; m < 5; m++) {
   93|   301M|          rsd[k][j][i][m] =  rsd[k][j][i][m]
   94|   301M|            - tx2 * ( flux[i+1][m] - flux[i-1][m] );
   95|   301M|        }
   96|  60.2M|      }
   97|       |
   98|  62.2M|      for (i = ist; i < nx; i++) {
   99|  61.2M|        tmp = rho_i[k][j][i];
  100|       |
  101|  61.2M|        u21i = tmp * u[k][j][i][1];
  102|  61.2M|        u31i = tmp * u[k][j][i][2];
  103|  61.2M|        u41i = tmp * u[k][j][i][3];
  104|  61.2M|        u51i = tmp * u[k][j][i][4];
  105|       |
  106|  61.2M|        tmp = rho_i[k][j][i-1];
  107|       |
  108|  61.2M|        u21im1 = tmp * u[k][j][i-1][1];
  109|  61.2M|        u31im1 = tmp * u[k][j][i-1][2];
  110|  61.2M|        u41im1 = tmp * u[k][j][i-1][3];
  111|  61.2M|        u51im1 = tmp * u[k][j][i-1][4];
  112|       |
  113|  61.2M|        flux[i][1] = (4.0/3.0) * tx3 * (u21i-u21im1);
  114|  61.2M|        flux[i][2] = tx3 * ( u31i - u31im1 );
  115|  61.2M|        flux[i][3] = tx3 * ( u41i - u41im1 );
  116|  61.2M|        flux[i][4] = 0.50 * ( 1.0 - C1*C5 )
  117|  61.2M|          * tx3 * ( ( u21i*u21i     + u31i*u31i     + u41i*u41i )
  118|  61.2M|                  - ( u21im1*u21im1 + u31im1*u31im1 + u41im1*u41im1 ) )
  119|  61.2M|          + (1.0/6.0)
  120|  61.2M|          * tx3 * ( u21i*u21i - u21im1*u21im1 )
  121|  61.2M|          + C1 * C5 * tx3 * ( u51i - u51im1 );
  122|  61.2M|      }
  123|       |
  124|  61.2M|      for (i = ist; i < iend; i++) {
  125|  60.2M|        rsd[k][j][i][0] = rsd[k][j][i][0]
  126|  60.2M|          + dx1 * tx1 * (        u[k][j][i-1][0]
  127|  60.2M|                         - 2.0 * u[k][j][i][0]
  128|  60.2M|                         +       u[k][j][i+1][0] );
  129|  60.2M|        rsd[k][j][i][1] = rsd[k][j][i][1]
  130|  60.2M|          + tx3 * C3 * C4 * ( flux[i+1][1] - flux[i][1] )
  131|  60.2M|          + dx2 * tx1 * (        u[k][j][i-1][1]
  132|  60.2M|                         - 2.0 * u[k][j][i][1]
  133|  60.2M|                         +       u[k][j][i+1][1] );
  134|  60.2M|        rsd[k][j][i][2] = rsd[k][j][i][2]
  135|  60.2M|          + tx3 * C3 * C4 * ( flux[i+1][2] - flux[i][2] )
  136|  60.2M|          + dx3 * tx1 * (        u[k][j][i-1][2]
  137|  60.2M|                         - 2.0 * u[k][j][i][2]
  138|  60.2M|                         +       u[k][j][i+1][2] );
  139|  60.2M|        rsd[k][j][i][3] = rsd[k][j][i][3]
  140|  60.2M|          + tx3 * C3 * C4 * ( flux[i+1][3] - flux[i][3] )
  141|  60.2M|          + dx4 * tx1 * (        u[k][j][i-1][3]
  142|  60.2M|                         - 2.0 * u[k][j][i][3]
  143|  60.2M|                         +       u[k][j][i+1][3] );
  144|  60.2M|        rsd[k][j][i][4] = rsd[k][j][i][4]
  145|  60.2M|          + tx3 * C3 * C4 * ( flux[i+1][4] - flux[i][4] )
  146|  60.2M|          + dx5 * tx1 * (        u[k][j][i-1][4]
  147|  60.2M|                         - 2.0 * u[k][j][i][4]
  148|  60.2M|                         +       u[k][j][i+1][4] );
  149|  60.2M|      }
  150|       |
  151|       |      //---------------------------------------------------------------------
  152|       |      // Fourth-order dissipation
  153|       |      //---------------------------------------------------------------------
  154|  5.83M|      for (m = 0; m < 5; m++) {
  155|  4.86M|        rsd[k][j][1][m] = rsd[k][j][1][m]
  156|  4.86M|          - dssp * ( + 5.0 * u[k][j][1][m]
  157|  4.86M|                     - 4.0 * u[k][j][2][m]
  158|  4.86M|                     +       u[k][j][3][m] );
  159|  4.86M|        rsd[k][j][2][m] = rsd[k][j][2][m]
  160|  4.86M|          - dssp * ( - 4.0 * u[k][j][1][m]
  161|  4.86M|                     + 6.0 * u[k][j][2][m]
  162|  4.86M|                     - 4.0 * u[k][j][3][m]
  163|  4.86M|                     +       u[k][j][4][m] );
  164|  4.86M|      }
  165|       |
  166|  57.3M|      for (i = 3; i < nx - 3; i++) {
  167|   338M|        for (m = 0; m < 5; m++) {
  168|   282M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  169|   282M|            - dssp * (         u[k][j][i-2][m]
  170|   282M|                       - 4.0 * u[k][j][i-1][m]
  171|   282M|                       + 6.0 * u[k][j][i][m]
  172|   282M|                       - 4.0 * u[k][j][i+1][m]
  173|   282M|                       +       u[k][j][i+2][m] );
  174|   282M|        }
  175|  56.4M|      }
  176|       |
  177|       |
  178|  5.83M|      for (m = 0; m < 5; m++) {
  179|  4.86M|        rsd[k][j][nx-3][m] = rsd[k][j][nx-3][m]
  180|  4.86M|          - dssp * (         u[k][j][nx-5][m]
  181|  4.86M|                     - 4.0 * u[k][j][nx-4][m]
  182|  4.86M|                     + 6.0 * u[k][j][nx-3][m]
  183|  4.86M|                     - 4.0 * u[k][j][nx-2][m] );
  184|  4.86M|        rsd[k][j][nx-2][m] = rsd[k][j][nx-2][m]
  185|  4.86M|          - dssp * (         u[k][j][nx-4][m]
  186|  4.86M|                     - 4.0 * u[k][j][nx-3][m]
  187|  4.86M|                     + 5.0 * u[k][j][nx-2][m] );
  188|  4.86M|      }
  189|       |
  190|   972k|    }
  191|  15.6k|  }
  192|    253|  if (timeron) timer_stop(t_rhsx);
  193|       |
  194|    253|  if (timeron) timer_start(t_rhsy);
  195|       |  //---------------------------------------------------------------------
  196|       |  // eta-direction flux differences
  197|       |  //---------------------------------------------------------------------
  198|  15.9k|  for (k = 1; k < nz - 1; k++) {
  199|   988k|    for (i = ist; i < iend; i++) {
  200|  63.2M|      for (j = 0; j < ny; j++) {
  201|  62.2M|        flux[j][0] = u[k][j][i][2];
  202|  62.2M|        u31 = u[k][j][i][2] * rho_i[k][j][i];
  203|       |
  204|  62.2M|        q = qs[k][j][i];
  205|       |
  206|  62.2M|        flux[j][1] = u[k][j][i][1] * u31;
  207|  62.2M|        flux[j][2] = u[k][j][i][2] * u31 + C2 * (u[k][j][i][4]-q);
  208|  62.2M|        flux[j][3] = u[k][j][i][3] * u31;
  209|  62.2M|        flux[j][4] = ( C1 * u[k][j][i][4] - C2 * q ) * u31;
  210|  62.2M|      }
  211|       |
  212|  61.2M|      for (j = jst; j < jend; j++) {
  213|   361M|        for (m = 0; m < 5; m++) {
  214|   301M|          rsd[k][j][i][m] =  rsd[k][j][i][m]
  215|   301M|            - ty2 * ( flux[j+1][m] - flux[j-1][m] );
  216|   301M|        }
  217|  60.2M|      }
  218|       |
  219|  62.2M|      for (j = jst; j < ny; j++) {
  220|  61.2M|        tmp = rho_i[k][j][i];
  221|       |
  222|  61.2M|        u21j = tmp * u[k][j][i][1];
  223|  61.2M|        u31j = tmp * u[k][j][i][2];
  224|  61.2M|        u41j = tmp * u[k][j][i][3];
  225|  61.2M|        u51j = tmp * u[k][j][i][4];
  226|       |
  227|  61.2M|        tmp = rho_i[k][j-1][i];
  228|  61.2M|        u21jm1 = tmp * u[k][j-1][i][1];
  229|  61.2M|        u31jm1 = tmp * u[k][j-1][i][2];
  230|  61.2M|        u41jm1 = tmp * u[k][j-1][i][3];
  231|  61.2M|        u51jm1 = tmp * u[k][j-1][i][4];
  232|       |
  233|  61.2M|        flux[j][1] = ty3 * ( u21j - u21jm1 );
  234|  61.2M|        flux[j][2] = (4.0/3.0) * ty3 * (u31j-u31jm1);
  235|  61.2M|        flux[j][3] = ty3 * ( u41j - u41jm1 );
  236|  61.2M|        flux[j][4] = 0.50 * ( 1.0 - C1*C5 )
  237|  61.2M|          * ty3 * ( ( u21j*u21j     + u31j*u31j     + u41j*u41j )
  238|  61.2M|                  - ( u21jm1*u21jm1 + u31jm1*u31jm1 + u41jm1*u41jm1 ) )
  239|  61.2M|          + (1.0/6.0)
  240|  61.2M|          * ty3 * ( u31j*u31j - u31jm1*u31jm1 )
  241|  61.2M|          + C1 * C5 * ty3 * ( u51j - u51jm1 );
  242|  61.2M|      }
  243|       |
  244|  61.2M|      for (j = jst; j < jend; j++) {
  245|  60.2M|        rsd[k][j][i][0] = rsd[k][j][i][0]
  246|  60.2M|          + dy1 * ty1 * (         u[k][j-1][i][0]
  247|  60.2M|                          - 2.0 * u[k][j][i][0]
  248|  60.2M|                          +       u[k][j+1][i][0] );
  249|       |
  250|  60.2M|        rsd[k][j][i][1] = rsd[k][j][i][1]
  251|  60.2M|          + ty3 * C3 * C4 * ( flux[j+1][1] - flux[j][1] )
  252|  60.2M|          + dy2 * ty1 * (         u[k][j-1][i][1]
  253|  60.2M|                          - 2.0 * u[k][j][i][1]
  254|  60.2M|                          +       u[k][j+1][i][1] );
  255|       |
  256|  60.2M|        rsd[k][j][i][2] = rsd[k][j][i][2]
  257|  60.2M|          + ty3 * C3 * C4 * ( flux[j+1][2] - flux[j][2] )
  258|  60.2M|          + dy3 * ty1 * (         u[k][j-1][i][2]
  259|  60.2M|                          - 2.0 * u[k][j][i][2]
  260|  60.2M|                          +       u[k][j+1][i][2] );
  261|       |
  262|  60.2M|        rsd[k][j][i][3] = rsd[k][j][i][3]
  263|  60.2M|          + ty3 * C3 * C4 * ( flux[j+1][3] - flux[j][3] )
  264|  60.2M|          + dy4 * ty1 * (         u[k][j-1][i][3]
  265|  60.2M|                          - 2.0 * u[k][j][i][3]
  266|  60.2M|                          +       u[k][j+1][i][3] );
  267|       |
  268|  60.2M|        rsd[k][j][i][4] = rsd[k][j][i][4]
  269|  60.2M|          + ty3 * C3 * C4 * ( flux[j+1][4] - flux[j][4] )
  270|  60.2M|          + dy5 * ty1 * (         u[k][j-1][i][4]
  271|  60.2M|                          - 2.0 * u[k][j][i][4]
  272|  60.2M|                          +       u[k][j+1][i][4] );
  273|  60.2M|      }
  274|   972k|    }
  275|       |
  276|       |    //---------------------------------------------------------------------
  277|       |    // fourth-order dissipation
  278|       |    //---------------------------------------------------------------------
  279|   988k|    for (i = ist; i < iend; i++) {
  280|  5.83M|      for (m = 0; m < 5; m++) {
  281|  4.86M|        rsd[k][1][i][m] = rsd[k][1][i][m]
  282|  4.86M|          - dssp * ( + 5.0 * u[k][1][i][m]
  283|  4.86M|                     - 4.0 * u[k][2][i][m]
  284|  4.86M|                     +       u[k][3][i][m] );
  285|  4.86M|        rsd[k][2][i][m] = rsd[k][2][i][m]
  286|  4.86M|          - dssp * ( - 4.0 * u[k][1][i][m]
  287|  4.86M|                     + 6.0 * u[k][2][i][m]
  288|  4.86M|                     - 4.0 * u[k][3][i][m]
  289|  4.86M|                     +       u[k][4][i][m] );
  290|  4.86M|      }
  291|   972k|    }
  292|       |
  293|   925k|    for (j = 3; j < ny - 3; j++) {
  294|  57.3M|      for (i = ist; i < iend; i++) {
  295|   338M|        for (m = 0; m < 5; m++) {
  296|   282M|          rsd[k][j][i][m] = rsd[k][j][i][m]
  297|   282M|            - dssp * (         u[k][j-2][i][m]
  298|   282M|                       - 4.0 * u[k][j-1][i][m]
  299|   282M|                       + 6.0 * u[k][j][i][m]
  300|   282M|                       - 4.0 * u[k][j+1][i][m]
  301|   282M|                       +       u[k][j+2][i][m] );
  302|   282M|        }
  303|  56.4M|      }
  304|   909k|    }
  305|       |
  306|   988k|    for (i = ist; i < iend; i++) {
  307|  5.83M|      for (m = 0; m < 5; m++) {
  308|  4.86M|        rsd[k][ny-3][i][m] = rsd[k][ny-3][i][m]
  309|  4.86M|          - dssp * (         u[k][ny-5][i][m]
  310|  4.86M|                     - 4.0 * u[k][ny-4][i][m]
  311|  4.86M|                     + 6.0 * u[k][ny-3][i][m]
  312|  4.86M|                     - 4.0 * u[k][ny-2][i][m] );
  313|  4.86M|        rsd[k][ny-2][i][m] = rsd[k][ny-2][i][m]
  314|  4.86M|          - dssp * (         u[k][ny-4][i][m]
  315|  4.86M|                     - 4.0 * u[k][ny-3][i][m]
  316|  4.86M|                     + 5.0 * u[k][ny-2][i][m] );
  317|  4.86M|      }
  318|   972k|    }
  319|       |
  320|  15.6k|  }
  321|    253|  if (timeron) timer_stop(t_rhsy);
  322|       |
  323|    253|  if (timeron) timer_start(t_rhsz);
  324|       |  //---------------------------------------------------------------------
  325|       |  // zeta-direction flux differences
  326|       |  //---------------------------------------------------------------------
  327|  15.9k|  for (j = jst; j < jend; j++) {
  328|   988k|    for (i = ist; i < iend; i++) {
  329|  63.2M|      for (k = 0; k < nz; k++) {
  330|  62.2M|        utmp[k][0] = u[k][j][i][0];
  331|  62.2M|        utmp[k][1] = u[k][j][i][1];
  332|  62.2M|        utmp[k][2] = u[k][j][i][2];
  333|  62.2M|        utmp[k][3] = u[k][j][i][3];
  334|  62.2M|        utmp[k][4] = u[k][j][i][4];
  335|  62.2M|        utmp[k][5] = rho_i[k][j][i];
  336|  62.2M|      }
  337|  63.2M|      for (k = 0; k < nz; k++) {
  338|  62.2M|        flux[k][0] = utmp[k][3];
  339|  62.2M|        u41 = utmp[k][3] * utmp[k][5];
  340|       |
  341|  62.2M|        q = qs[k][j][i];
  342|       |
  343|  62.2M|        flux[k][1] = utmp[k][1] * u41;
  344|  62.2M|        flux[k][2] = utmp[k][2] * u41;
  345|  62.2M|        flux[k][3] = utmp[k][3] * u41 + C2 * (utmp[k][4]-q);
  346|  62.2M|        flux[k][4] = ( C1 * utmp[k][4] - C2 * q ) * u41;
  347|  62.2M|      }
  348|       |
  349|  61.2M|      for (k = 1; k < nz - 1; k++) {
  350|   361M|        for (m = 0; m < 5; m++) {
  351|   301M|          rtmp[k][m] =  rsd[k][j][i][m]
  352|   301M|            - tz2 * ( flux[k+1][m] - flux[k-1][m] );
  353|   301M|        }
  354|  60.2M|      }
  355|       |
  356|  62.2M|      for (k = 1; k < nz; k++) {
  357|  61.2M|        tmp = utmp[k][5];
  358|       |
  359|  61.2M|        u21k = tmp * utmp[k][1];
  360|  61.2M|        u31k = tmp * utmp[k][2];
  361|  61.2M|        u41k = tmp * utmp[k][3];
  362|  61.2M|        u51k = tmp * utmp[k][4];
  363|       |
  364|  61.2M|        tmp = utmp[k-1][5];
  365|       |
  366|  61.2M|        u21km1 = tmp * utmp[k-1][1];
  367|  61.2M|        u31km1 = tmp * utmp[k-1][2];
  368|  61.2M|        u41km1 = tmp * utmp[k-1][3];
  369|  61.2M|        u51km1 = tmp * utmp[k-1][4];
  370|       |
  371|  61.2M|        flux[k][1] = tz3 * ( u21k - u21km1 );
  372|  61.2M|        flux[k][2] = tz3 * ( u31k - u31km1 );
  373|  61.2M|        flux[k][3] = (4.0/3.0) * tz3 * (u41k-u41km1);
  374|  61.2M|        flux[k][4] = 0.50 * ( 1.0 - C1*C5 )
  375|  61.2M|          * tz3 * ( ( u21k*u21k     + u31k*u31k     + u41k*u41k )
  376|  61.2M|                  - ( u21km1*u21km1 + u31km1*u31km1 + u41km1*u41km1 ) )
  377|  61.2M|          + (1.0/6.0)
  378|  61.2M|          * tz3 * ( u41k*u41k - u41km1*u41km1 )
  379|  61.2M|          + C1 * C5 * tz3 * ( u51k - u51km1 );
  380|  61.2M|      }
  381|       |
  382|  61.2M|      for (k = 1; k < nz - 1; k++) {
  383|  60.2M|        rtmp[k][0] = rtmp[k][0]
  384|  60.2M|          + dz1 * tz1 * (         utmp[k-1][0]
  385|  60.2M|                          - 2.0 * utmp[k][0]
  386|  60.2M|                          +       utmp[k+1][0] );
  387|  60.2M|        rtmp[k][1] = rtmp[k][1]
  388|  60.2M|          + tz3 * C3 * C4 * ( flux[k+1][1] - flux[k][1] )
  389|  60.2M|          + dz2 * tz1 * (         utmp[k-1][1]
  390|  60.2M|                          - 2.0 * utmp[k][1]
  391|  60.2M|                          +       utmp[k+1][1] );
  392|  60.2M|        rtmp[k][2] = rtmp[k][2]
  393|  60.2M|          + tz3 * C3 * C4 * ( flux[k+1][2] - flux[k][2] )
  394|  60.2M|          + dz3 * tz1 * (         utmp[k-1][2]
  395|  60.2M|                          - 2.0 * utmp[k][2]
  396|  60.2M|                          +       utmp[k+1][2] );
  397|  60.2M|        rtmp[k][3] = rtmp[k][3]
  398|  60.2M|          + tz3 * C3 * C4 * ( flux[k+1][3] - flux[k][3] )
  399|  60.2M|          + dz4 * tz1 * (         utmp[k-1][3]
  400|  60.2M|                          - 2.0 * utmp[k][3]
  401|  60.2M|                          +       utmp[k+1][3] );
  402|  60.2M|        rtmp[k][4] = rtmp[k][4]
  403|  60.2M|          + tz3 * C3 * C4 * ( flux[k+1][4] - flux[k][4] )
  404|  60.2M|          + dz5 * tz1 * (         utmp[k-1][4]
  405|  60.2M|                          - 2.0 * utmp[k][4]
  406|  60.2M|                          +       utmp[k+1][4] );
  407|  60.2M|      }
  408|       |
  409|       |      //---------------------------------------------------------------------
  410|       |      // fourth-order dissipation
  411|       |      //---------------------------------------------------------------------
  412|  5.83M|      for (m = 0; m < 5; m++) {
  413|  4.86M|        rsd[1][j][i][m] = rtmp[1][m]
  414|  4.86M|          - dssp * ( + 5.0 * utmp[1][m]
  415|  4.86M|                     - 4.0 * utmp[2][m]
  416|  4.86M|                     +       utmp[3][m] );
  417|  4.86M|        rsd[2][j][i][m] = rtmp[2][m]
  418|  4.86M|          - dssp * ( - 4.0 * utmp[1][m]
  419|  4.86M|                     + 6.0 * utmp[2][m]
  420|  4.86M|                     - 4.0 * utmp[3][m]
  421|  4.86M|                     +       utmp[4][m] );
  422|  4.86M|      }
  423|       |
  424|  57.3M|      for (k = 3; k < nz - 3; k++) {
  425|   338M|        for (m = 0; m < 5; m++) {
  426|   282M|          rsd[k][j][i][m] = rtmp[k][m]
  427|   282M|            - dssp * (         utmp[k-2][m]
  428|   282M|                       - 4.0 * utmp[k-1][m]
  429|   282M|                       + 6.0 * utmp[k][m]
  430|   282M|                       - 4.0 * utmp[k+1][m]
  431|   282M|                       +       utmp[k+2][m] );
  432|   282M|        }
  433|  56.4M|      }
  434|       |
  435|  5.83M|      for (m = 0; m < 5; m++) {
  436|  4.86M|        rsd[nz-3][j][i][m] = rtmp[nz-3][m]
  437|  4.86M|          - dssp * (         utmp[nz-5][m]
  438|  4.86M|                     - 4.0 * utmp[nz-4][m]
  439|  4.86M|                     + 6.0 * utmp[nz-3][m]
  440|  4.86M|                     - 4.0 * utmp[nz-2][m] );
  441|  4.86M|        rsd[nz-2][j][i][m] = rtmp[nz-2][m]
  442|  4.86M|          - dssp * (         utmp[nz-4][m]
  443|  4.86M|                     - 4.0 * utmp[nz-3][m]
  444|  4.86M|                     + 5.0 * utmp[nz-2][m] );
  445|  4.86M|      }
  446|   972k|    }
  447|  15.6k|  }
  448|    253|  if (timeron) timer_stop(t_rhsz);
  449|    253|  if (timeron) timer_stop(t_rhs);
  450|    253|}
  451|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/setbv.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |// set the boundary values of dependent variables
   38|       |//---------------------------------------------------------------------
   39|       |void setbv()
   40|      2|{
   41|       |  //---------------------------------------------------------------------
   42|       |  // local variables
   43|       |  //---------------------------------------------------------------------
   44|      2|  int i, j, k, m;
   45|      2|  double temp1[5], temp2[5];
   46|       |
   47|       |  //---------------------------------------------------------------------
   48|       |  // set the dependent variable values along the top and bottom faces
   49|       |  //---------------------------------------------------------------------
   50|    130|  for (j = 0; j < ny; j++) {
   51|  8.32k|    for (i = 0; i < nx; i++) {
   52|  8.19k|      exact( i, j, 0, temp1 );
   53|  8.19k|      exact( i, j, nz-1, temp2 );
   54|  49.1k|      for (m = 0; m < 5; m++) {
   55|  40.9k|        u[0][j][i][m] = temp1[m];
   56|  40.9k|        u[nz-1][j][i][m] = temp2[m];
   57|  40.9k|      }
   58|  8.19k|    }
   59|    128|  }
   60|       |
   61|       |  //---------------------------------------------------------------------
   62|       |  // set the dependent variable values along north and south faces
   63|       |  //---------------------------------------------------------------------
   64|    130|  for (k = 0; k < nz; k++) {
   65|  8.32k|    for (i = 0; i < nx; i++) {
   66|  8.19k|      exact( i, 0, k, temp1 );
   67|  8.19k|      exact( i, ny-1, k, temp2 );
   68|  49.1k|      for (m = 0; m < 5; m++) {
   69|  40.9k|        u[k][0][i][m] = temp1[m];
   70|  40.9k|        u[k][ny-1][i][m] = temp2[m];
   71|  40.9k|      }
   72|  8.19k|    }
   73|    128|  }
   74|       |
   75|       |  //---------------------------------------------------------------------
   76|       |  // set the dependent variable values along east and west faces
   77|       |  //---------------------------------------------------------------------
   78|    130|  for (k = 0; k < nz; k++) {
   79|  8.32k|    for (j = 0; j < ny; j++) {
   80|  8.19k|      exact( 0, j, k, temp1 );
   81|  8.19k|      exact( nx-1, j, k, temp2 );
   82|  49.1k|      for (m = 0; m < 5; m++) {
   83|  40.9k|        u[k][j][0][m] = temp1[m];
   84|  40.9k|        u[k][j][nx-1][m] = temp2[m];
   85|  40.9k|      }
   86|  8.19k|    }
   87|    128|  }
   88|      2|}
   89|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/setcoeff.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |void setcoeff()
   37|      1|{
   38|       |  //---------------------------------------------------------------------
   39|       |  // local variables
   40|       |  //---------------------------------------------------------------------
   41|       |
   42|       |  //---------------------------------------------------------------------
   43|       |  // set up coefficients
   44|       |  //---------------------------------------------------------------------
   45|      1|  dxi = 1.0 / ( nx0 - 1 );
   46|      1|  deta = 1.0 / ( ny0 - 1 );
   47|      1|  dzeta = 1.0 / ( nz0 - 1 );
   48|       |
   49|      1|  tx1 = 1.0 / ( dxi * dxi );
   50|      1|  tx2 = 1.0 / ( 2.0 * dxi );
   51|      1|  tx3 = 1.0 / dxi;
   52|       |
   53|      1|  ty1 = 1.0 / ( deta * deta );
   54|      1|  ty2 = 1.0 / ( 2.0 * deta );
   55|      1|  ty3 = 1.0 / deta;
   56|       |
   57|      1|  tz1 = 1.0 / ( dzeta * dzeta );
   58|      1|  tz2 = 1.0 / ( 2.0 * dzeta );
   59|      1|  tz3 = 1.0 / dzeta;
   60|       |
   61|       |  //---------------------------------------------------------------------
   62|       |  // diffusion coefficients
   63|       |  //---------------------------------------------------------------------
   64|      1|  dx1 = 0.75;
   65|      1|  dx2 = dx1;
   66|      1|  dx3 = dx1;
   67|      1|  dx4 = dx1;
   68|      1|  dx5 = dx1;
   69|       |
   70|      1|  dy1 = 0.75;
   71|      1|  dy2 = dy1;
   72|      1|  dy3 = dy1;
   73|      1|  dy4 = dy1;
   74|      1|  dy5 = dy1;
   75|       |
   76|      1|  dz1 = 1.00;
   77|      1|  dz2 = dz1;
   78|      1|  dz3 = dz1;
   79|      1|  dz4 = dz1;
   80|      1|  dz5 = dz1;
   81|       |
   82|       |  //---------------------------------------------------------------------
   83|       |  // fourth difference dissipation
   84|       |  //---------------------------------------------------------------------
   85|      1|  dssp = ( max(max(dx1, dy1), dz1) ) / 4.0;
   86|       |
   87|       |  //---------------------------------------------------------------------
   88|       |  // coefficients of the exact solution to the first pde
   89|       |  //---------------------------------------------------------------------
   90|      1|  ce[0][0] = 2.0;
   91|      1|  ce[0][1] = 0.0;
   92|      1|  ce[0][2] = 0.0;
   93|      1|  ce[0][3] = 4.0;
   94|      1|  ce[0][4] = 5.0;
   95|      1|  ce[0][5] = 3.0;
   96|      1|  ce[0][6] = 5.0e-01;
   97|      1|  ce[0][7] = 2.0e-02;
   98|      1|  ce[0][8] = 1.0e-02;
   99|      1|  ce[0][9] = 3.0e-02;
  100|      1|  ce[0][10] = 5.0e-01;
  101|      1|  ce[0][11] = 4.0e-01;
  102|      1|  ce[0][12] = 3.0e-01;
  103|       |
  104|       |  //---------------------------------------------------------------------
  105|       |  // coefficients of the exact solution to the second pde
  106|       |  //---------------------------------------------------------------------
  107|      1|  ce[1][0] = 1.0;
  108|      1|  ce[1][1] = 0.0;
  109|      1|  ce[1][2] = 0.0;
  110|      1|  ce[1][3] = 0.0;
  111|      1|  ce[1][4] = 1.0;
  112|      1|  ce[1][5] = 2.0;
  113|      1|  ce[1][6] = 3.0;
  114|      1|  ce[1][7] = 1.0e-02;
  115|      1|  ce[1][8] = 3.0e-02;
  116|      1|  ce[1][9] = 2.0e-02;
  117|      1|  ce[1][10] = 4.0e-01;
  118|      1|  ce[1][11] = 3.0e-01;
  119|      1|  ce[1][12] = 5.0e-01;
  120|       |
  121|       |  //---------------------------------------------------------------------
  122|       |  // coefficients of the exact solution to the third pde
  123|       |  //---------------------------------------------------------------------
  124|      1|  ce[2][0] = 2.0;
  125|      1|  ce[2][1] = 2.0;
  126|      1|  ce[2][2] = 0.0;
  127|      1|  ce[2][3] = 0.0;
  128|      1|  ce[2][4] = 0.0;
  129|      1|  ce[2][5] = 2.0;
  130|      1|  ce[2][6] = 3.0;
  131|      1|  ce[2][7] = 4.0e-02;
  132|      1|  ce[2][8] = 3.0e-02;
  133|      1|  ce[2][9] = 5.0e-02;
  134|      1|  ce[2][10] = 3.0e-01;
  135|      1|  ce[2][11] = 5.0e-01;
  136|      1|  ce[2][12] = 4.0e-01;
  137|       |
  138|       |  //---------------------------------------------------------------------
  139|       |  // coefficients of the exact solution to the fourth pde
  140|       |  //---------------------------------------------------------------------
  141|      1|  ce[3][0] = 2.0;
  142|      1|  ce[3][1] = 2.0;
  143|      1|  ce[3][2] = 0.0;
  144|      1|  ce[3][3] = 0.0;
  145|      1|  ce[3][4] = 0.0;
  146|      1|  ce[3][5] = 2.0;
  147|      1|  ce[3][6] = 3.0;
  148|      1|  ce[3][7] = 3.0e-02;
  149|      1|  ce[3][8] = 5.0e-02;
  150|      1|  ce[3][9] = 4.0e-02;
  151|      1|  ce[3][10] = 2.0e-01;
  152|      1|  ce[3][11] = 1.0e-01;
  153|      1|  ce[3][12] = 3.0e-01;
  154|       |
  155|       |  //---------------------------------------------------------------------
  156|       |  // coefficients of the exact solution to the fifth pde
  157|       |  //---------------------------------------------------------------------
  158|      1|  ce[4][0] = 5.0;
  159|      1|  ce[4][1] = 4.0;
  160|      1|  ce[4][2] = 3.0;
  161|      1|  ce[4][3] = 2.0;
  162|      1|  ce[4][4] = 1.0e-01;
  163|      1|  ce[4][5] = 4.0e-01;
  164|      1|  ce[4][6] = 3.0e-01;
  165|      1|  ce[4][7] = 5.0e-02;
  166|      1|  ce[4][8] = 4.0e-02;
  167|      1|  ce[4][9] = 3.0e-02;
  168|      1|  ce[4][10] = 1.0e-01;
  169|      1|  ce[4][11] = 3.0e-01;
  170|      1|  ce[4][12] = 2.0e-01;
  171|      1|}

/home/dvmuser3/andrey/npb-3.3-c/LU/setiv.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include "applu.incl"
   35|       |
   36|       |//---------------------------------------------------------------------
   37|       |//
   38|       |// set the initial values of independent variables based on tri-linear
   39|       |// interpolation of boundary values in the computational space.
   40|       |//
   41|       |//---------------------------------------------------------------------
   42|       |void setiv()
   43|      2|{
   44|       |  //---------------------------------------------------------------------
   45|       |  // local variables
   46|       |  //---------------------------------------------------------------------
   47|      2|  int i, j, k, m;
   48|      2|  double xi, eta, zeta;
   49|      2|  double pxi, peta, pzeta;
   50|      2|  double ue_1jk[5], ue_nx0jk[5], ue_i1k[5];
   51|      2|  double ue_iny0k[5], ue_ij1[5], ue_ijnz[5];
   52|       |
   53|    126|  for (k = 1; k < nz - 1; k++) {
   54|    124|    zeta = ( (double)k ) / (nz-1);
   55|  7.81k|    for (j = 1; j < ny - 1; j++) {
   56|  7.68k|      eta = ( (double)j ) / (ny0-1);
   57|   484k|      for (i = 1; i < nx - 1; i++) {
   58|   476k|        xi = ( (double)i ) / (nx0-1);
   59|   476k|        exact(0, j, k, ue_1jk);
   60|   476k|        exact(nx0-1, j, k, ue_nx0jk);
   61|   476k|        exact(i, 0, k, ue_i1k);
   62|   476k|        exact(i, ny0-1, k, ue_iny0k);
   63|   476k|        exact(i, j, 0, ue_ij1);
   64|   476k|        exact(i, j, nz-1, ue_ijnz);
   65|       |
   66|  2.85M|        for (m = 0; m < 5; m++) {
   67|  2.38M|          pxi =   ( 1.0 - xi ) * ue_1jk[m]
   68|  2.38M|                        + xi   * ue_nx0jk[m];
   69|  2.38M|          peta =  ( 1.0 - eta ) * ue_i1k[m]
   70|  2.38M|                        + eta   * ue_iny0k[m];
   71|  2.38M|          pzeta = ( 1.0 - zeta ) * ue_ij1[m]
   72|  2.38M|                        + zeta   * ue_ijnz[m];
   73|       |
   74|  2.38M|          u[k][j][i][m] = pxi + peta + pzeta
   75|  2.38M|            - pxi * peta - peta * pzeta - pzeta * pxi
   76|  2.38M|            + pxi * peta * pzeta;
   77|  2.38M|        }
   78|   476k|      }
   79|  7.68k|    }
   80|    124|  }
   81|      2|}
   82|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/ssor.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include "applu.incl"
   36|       |#include "timers.h"
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |// to perform pseudo-time stepping SSOR iterations
   40|       |// for five nonlinear pde's.
   41|       |//---------------------------------------------------------------------
   42|       |void ssor(int niter)
   43|      2|{
   44|       |  //---------------------------------------------------------------------
   45|       |  // local variables
   46|       |  //---------------------------------------------------------------------
   47|      2|  int i, j, k, m, n;
   48|      2|  int istep;
   49|      2|  double tmp, tv[ISIZ2][ISIZ1][5];
   50|      2|  double delunm[5];
   51|       |
   52|       |  //---------------------------------------------------------------------
   53|       |  // begin pseudo-time stepping iterations
   54|       |  //---------------------------------------------------------------------
   55|      2|  tmp = 1.0 / ( omega * ( 2.0 - omega ) );
   56|       |
   57|       |  //---------------------------------------------------------------------
   58|       |  // initialize a,b,c,d to zero (guarantees that page tables have been
   59|       |  // formed, if applicable on given architecture, before timestepping).
   60|       |  //---------------------------------------------------------------------
   61|    130|  for (j = 0; j < ISIZ2; j++) {
   62|  8.32k|    for (i = 0; i < ISIZ1; i++) {
   63|  49.1k|      for (n = 0; n < 5; n++) {
   64|   245k|        for (m = 0; m < 5; m++) {
   65|   204k|          a[j][i][n][m] = 0.0;
   66|   204k|          b[j][i][n][m] = 0.0;
   67|   204k|          c[j][i][n][m] = 0.0;
   68|   204k|          d[j][i][n][m] = 0.0;
   69|   204k|        }
   70|  40.9k|      }
   71|  8.19k|    }
   72|    128|  }
   73|     24|  for (i = 1; i <= t_last; i++) {
   74|     22|    timer_clear(i);
   75|     22|  }
   76|       |
   77|       |  //---------------------------------------------------------------------
   78|       |  // compute the steady-state residuals
   79|       |  //---------------------------------------------------------------------
   80|      2|  rhs();
   81|       |
   82|       |  //---------------------------------------------------------------------
   83|       |  // compute the L2 norms of newton iteration residuals
   84|       |  //---------------------------------------------------------------------
   85|      2|  l2norm( ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0,
   86|      2|          ist, iend, jst, jend, rsd, rsdnm );
   87|       |
   88|       |  /*
   89|       |  if ( ipr == 1 ) {
   90|       |    printf("           Initial residual norms\n");
   91|       |    printf("\n");
   92|       |    printf(" \n RMS-norm of steady-state residual for "
   93|       |           "first pde  = %12.5E\n"
   94|       |           " RMS-norm of steady-state residual for "
   95|       |           "second pde = %12.5E\n"
   96|       |           " RMS-norm of steady-state residual for "
   97|       |           "third pde  = %12.5E\n"
   98|       |           " RMS-norm of steady-state residual for "
   99|       |           "fourth pde = %12.5E\n"
  100|       |           " RMS-norm of steady-state residual for "
  101|       |           "fifth pde  = %12.5E\n", 
  102|       |           rsdnm[0], rsdnm[1], rsdnm[2], rsdnm[3], rsdnm[4]);
  103|       |    printf("\nIteration RMS-residual of 5th PDE\n");
  104|       |  }
  105|       |  */
  106|       | 
  107|     24|  for (i = 1; i <= t_last; i++) {
  108|     22|    timer_clear(i);
  109|     22|  }
  110|      2|  timer_start(1);
  111|       |
  112|       |  //---------------------------------------------------------------------
  113|       |  // the timestep loop
  114|       |  //---------------------------------------------------------------------
  115|    253|  for (istep = 1; istep <= niter; istep++) {
  116|       |    //if ( ( (istep % inorm) == 0 ) && ipr == 1 ) {
  117|       |    //  printf(" \n     pseudo-time SSOR iteration no.=%4d\n\n", istep);
  118|       |    //}
  119|    251|    if ((istep % 20) == 0 || istep == itmax || istep == 1) {
  120|     15|      if (niter > 1) printf(" Time step %4d\n", istep);
  121|     15|    }
  122|       |
  123|       |    //---------------------------------------------------------------------
  124|       |    // perform SSOR iteration
  125|       |    //---------------------------------------------------------------------
  126|    251|    if (timeron) timer_start(t_rhs);
  127|  15.8k|    for (k = 1; k < nz - 1; k++) {
  128|   980k|      for (j = jst; j < jend; j++) {
  129|  60.7M|        for (i = ist; i < iend; i++) {
  130|   358M|          for (m = 0; m < 5; m++) {
  131|   299M|            rsd[k][j][i][m] = dt * rsd[k][j][i][m];
  132|   299M|          }
  133|  59.8M|        }
  134|   964k|      }
  135|  15.5k|    }
  136|    251|    if (timeron) timer_stop(t_rhs);
  137|       |
  138|  15.8k|    for (k = 1; k < nz -1; k++) {
  139|       |      //---------------------------------------------------------------------
  140|       |      // form the lower triangular part of the jacobian matrix
  141|       |      //---------------------------------------------------------------------
  142|  15.5k|      if (timeron) timer_start(t_jacld);
  143|  15.5k|      jacld(k);
  144|  15.5k|      if (timeron) timer_stop(t_jacld);
  145|       |
  146|       |      //---------------------------------------------------------------------
  147|       |      // perform the lower triangular solution
  148|       |      //---------------------------------------------------------------------
  149|  15.5k|      if (timeron) timer_start(t_blts);
  150|  15.5k|      blts( ISIZ1, ISIZ2, ISIZ3,
  151|  15.5k|            nx, ny, nz, k,
  152|  15.5k|            omega,
  153|  15.5k|            rsd, 
  154|  15.5k|            a, b, c, d,
  155|  15.5k|            ist, iend, jst, jend, 
  156|  15.5k|            nx0, ny0 );
  157|  15.5k|      if (timeron) timer_stop(t_blts);
  158|  15.5k|    }
  159|       | 
  160|  15.8k|    for (k = nz - 2; k > 0; k--) {
  161|       |      //---------------------------------------------------------------------
  162|       |      // form the strictly upper triangular part of the jacobian matrix
  163|       |      //---------------------------------------------------------------------
  164|  15.5k|      if (timeron) timer_start(t_jacu);
  165|  15.5k|      jacu(k);
  166|  15.5k|      if (timeron) timer_stop(t_jacu);
  167|       |
  168|       |      //---------------------------------------------------------------------
  169|       |      // perform the upper triangular solution
  170|       |      //---------------------------------------------------------------------
  171|  15.5k|      if (timeron) timer_start(t_buts);
  172|  15.5k|      buts( ISIZ1, ISIZ2, ISIZ3,
  173|  15.5k|            nx, ny, nz, k,
  174|  15.5k|            omega,
  175|  15.5k|            rsd, tv,
  176|  15.5k|            d, a, b, c,
  177|  15.5k|            ist, iend, jst, jend,
  178|  15.5k|            nx0, ny0 );
  179|  15.5k|      if (timeron) timer_stop(t_buts);
  180|  15.5k|    }
  181|       |
  182|       |    //---------------------------------------------------------------------
  183|       |    // update the variables
  184|       |    //---------------------------------------------------------------------
  185|    251|    if (timeron) timer_start(t_add);
  186|  15.8k|    for (k = 1; k < nz-1; k++) {
  187|   980k|      for (j = jst; j < jend; j++) {
  188|  60.7M|        for (i = ist; i < iend; i++) {
  189|   358M|          for (m = 0; m < 5; m++) {
  190|   299M|            u[k][j][i][m] = u[k][j][i][m] + tmp * rsd[k][j][i][m];
  191|   299M|          }
  192|  59.8M|        }
  193|   964k|      }
  194|  15.5k|    }
  195|    251|    if (timeron) timer_stop(t_add);
  196|       |
  197|       |    //---------------------------------------------------------------------
  198|       |    // compute the max-norms of newton iteration corrections
  199|       |    //---------------------------------------------------------------------
  200|    251|    if ( (istep % inorm) == 0 ) {
  201|      1|      if (timeron) timer_start(t_l2norm);
  202|      1|      l2norm( ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0,
  203|      1|              ist, iend, jst, jend,
  204|      1|              rsd, delunm );
  205|      1|      if (timeron) timer_stop(t_l2norm);
  206|       |      /*
  207|       |      if ( ipr == 1 ) {
  208|       |        printf(" \n RMS-norm of SSOR-iteration correction "
  209|       |               "for first pde  = %12.5E\n"
  210|       |               " RMS-norm of SSOR-iteration correction "
  211|       |               "for second pde = %12.5E\n"
  212|       |               " RMS-norm of SSOR-iteration correction "
  213|       |               "for third pde  = %12.5E\n"
  214|       |               " RMS-norm of SSOR-iteration correction "
  215|       |               "for fourth pde = %12.5E\n",
  216|       |               " RMS-norm of SSOR-iteration correction "
  217|       |               "for fifth pde  = %12.5E\n", 
  218|       |               delunm[0], delunm[1], delunm[2], delunm[3], delunm[4]); 
  219|       |      } else if ( ipr == 2 ) {
  220|       |        printf("(%5d,%15.6f)\n", istep, delunm[4]);
  221|       |      }
  222|       |      */
  223|      1|    }
  224|       | 
  225|       |    //---------------------------------------------------------------------
  226|       |    // compute the steady-state residuals
  227|       |    //---------------------------------------------------------------------
  228|    251|    rhs();
  229|       | 
  230|       |    //---------------------------------------------------------------------
  231|       |    // compute the max-norms of newton iteration residuals
  232|       |    //---------------------------------------------------------------------
  233|    251|    if ( ((istep % inorm ) == 0 ) || ( istep == itmax ) ) {
  234|      1|      if (timeron) timer_start(t_l2norm);
  235|      1|      l2norm( ISIZ1, ISIZ2, ISIZ3, nx0, ny0, nz0,
  236|      1|              ist, iend, jst, jend, rsd, rsdnm );
  237|      1|      if (timeron) timer_stop(t_l2norm);
  238|       |      /*
  239|       |      if ( ipr == 1 ) {
  240|       |        printf(" \n RMS-norm of steady-state residual for "
  241|       |               "first pde  = %12.5E\n"
  242|       |               " RMS-norm of steady-state residual for "
  243|       |               "second pde = %12.5E\n"
  244|       |               " RMS-norm of steady-state residual for "
  245|       |               "third pde  = %12.5E\n"
  246|       |               " RMS-norm of steady-state residual for "
  247|       |               "fourth pde = %12.5E\n"
  248|       |               " RMS-norm of steady-state residual for "
  249|       |               "fifth pde  = %12.5E\n", 
  250|       |               rsdnm[0], rsdnm[1], rsdnm[2], rsdnm[3], rsdnm[4]);
  251|       |      }
  252|       |      */
  253|      1|    }
  254|       |
  255|       |    //---------------------------------------------------------------------
  256|       |    // check the newton-iteration residuals against the tolerance levels
  257|       |    //---------------------------------------------------------------------
  258|    251|    if ( ( rsdnm[0] < tolrsd[0] ) && ( rsdnm[1] < tolrsd[1] ) &&
  259|    251|         ( rsdnm[2] < tolrsd[2] ) && ( rsdnm[3] < tolrsd[3] ) &&
  260|    251|         ( rsdnm[4] < tolrsd[4] ) ) {
  261|       |      //if (ipr == 1 ) {
  262|      0|      printf(" \n convergence was achieved after %4d pseudo-time steps\n",
  263|      0|          istep);
  264|       |      //}
  265|      0|      break;
  266|      0|    }
  267|    251|  }
  268|       |
  269|      2|  timer_stop(1);
  270|      2|  maxtime = timer_read(1);
  271|      2|}
  272|       |

/home/dvmuser3/andrey/npb-3.3-c/LU/verify.c:
    1|       |//-------------------------------------------------------------------------//
    2|       |//                                                                         //
    3|       |//  This benchmark is a serial C version of the NPB LU code. This C        //
    4|       |//  version is developed by the Center for Manycore Programming at Seoul   //
    5|       |//  National University and derived from the serial Fortran versions in    //
    6|       |//  "NPB3.3-SER" developed by NAS.                                         //
    7|       |//                                                                         //
    8|       |//  Permission to use, copy, distribute and modify this software for any   //
    9|       |//  purpose with or without fee is hereby granted. This software is        //
   10|       |//  provided "as is" without express or implied warranty.                  //
   11|       |//                                                                         //
   12|       |//  Information on NPB 3.3, including the technical report, the original   //
   13|       |//  specifications, source code, results and information on how to submit  //
   14|       |//  new results, is available at:                                          //
   15|       |//                                                                         //
   16|       |//           http://www.nas.nasa.gov/Software/NPB/                         //
   17|       |//                                                                         //
   18|       |//  Send comments or suggestions for this C version to cmp@aces.snu.ac.kr  //
   19|       |//                                                                         //
   20|       |//          Center for Manycore Programming                                //
   21|       |//          School of Computer Science and Engineering                     //
   22|       |//          Seoul National University                                      //
   23|       |//          Seoul 151-744, Korea                                           //
   24|       |//                                                                         //
   25|       |//          E-mail:  cmp@aces.snu.ac.kr                                    //
   26|       |//                                                                         //
   27|       |//-------------------------------------------------------------------------//
   28|       |
   29|       |//-------------------------------------------------------------------------//
   30|       |// Authors: Sangmin Seo, Jungwon Kim, Jun Lee, Jeongho Nah, Gangwon Jo,    //
   31|       |//          and Jaejin Lee                                                 //
   32|       |//-------------------------------------------------------------------------//
   33|       |
   34|       |#include <stdio.h>
   35|       |#include <math.h>
   36|       |#include "applu.incl"
   37|       |
   38|       |//---------------------------------------------------------------------
   39|       |// verification routine                         
   40|       |//---------------------------------------------------------------------
   41|       |void verify(double xcr[5], double xce[5], double xci, 
   42|       |            char *Class, logical *verified)
   43|      1|{
   44|      1|  double xcrref[5], xceref[5], xciref;
   45|      1|  double xcrdif[5], xcedif[5], xcidif;
   46|      1|  double epsilon, dtref = 0.0;
   47|      1|  int m;
   48|       |
   49|       |  //---------------------------------------------------------------------
   50|       |  // tolerance level
   51|       |  //---------------------------------------------------------------------
   52|      1|  epsilon = 1.0e-08;
   53|       |
   54|      1|  *Class = 'U';
   55|      1|  *verified = true;
   56|       |
   57|      6|  for (m = 0; m < 5; m++) {
   58|      5|    xcrref[m] = 1.0;
   59|      5|    xceref[m] = 1.0;
   60|      5|  }
   61|      1|  xciref = 1.0;
   62|       |
   63|      1|  if ((nx0 == 12) && (ny0 == 12) && (nz0 == 12) && (itmax == 50)) {
   64|       |
   65|      0|    *Class = 'S';
   66|      0|    dtref = 5.0e-1;
   67|       |    //---------------------------------------------------------------------
   68|       |    // Reference values of RMS-norms of residual, for the (12X12X12) grid,
   69|       |    // after 50 time steps, with  DT = 5.0e-01
   70|       |    //---------------------------------------------------------------------
   71|      0|    xcrref[0] = 1.6196343210976702e-02;
   72|      0|    xcrref[1] = 2.1976745164821318e-03;
   73|      0|    xcrref[2] = 1.5179927653399185e-03;
   74|      0|    xcrref[3] = 1.5029584435994323e-03;
   75|      0|    xcrref[4] = 3.4264073155896461e-02;
   76|       |
   77|       |    //---------------------------------------------------------------------
   78|       |    // Reference values of RMS-norms of solution error, 
   79|       |    // for the (12X12X12) grid,
   80|       |    // after 50 time steps, with  DT = 5.0e-01
   81|       |    //---------------------------------------------------------------------
   82|      0|    xceref[0] = 6.4223319957960924e-04;
   83|      0|    xceref[1] = 8.4144342047347926e-05;
   84|      0|    xceref[2] = 5.8588269616485186e-05;
   85|      0|    xceref[3] = 5.8474222595157350e-05;
   86|      0|    xceref[4] = 1.3103347914111294e-03;
   87|       |
   88|       |    //---------------------------------------------------------------------
   89|       |    // Reference value of surface integral, for the (12X12X12) grid,
   90|       |    // after 50 time steps, with DT = 5.0e-01
   91|       |    //---------------------------------------------------------------------
   92|      0|    xciref = 7.8418928865937083e+00;
   93|       |
   94|      1|  } else if ((nx0 == 33) && (ny0 == 33) && (nz0 == 33) && (itmax == 300)) {
   95|       |
   96|      0|    *Class = 'W';   //SPEC95fp size
   97|      0|    dtref = 1.5e-3;
   98|       |    //---------------------------------------------------------------------
   99|       |    // Reference values of RMS-norms of residual, for the (33x33x33) grid,
  100|       |    // after 300 time steps, with  DT = 1.5e-3
  101|       |    //---------------------------------------------------------------------
  102|      0|    xcrref[0] = 0.1236511638192e+02;
  103|      0|    xcrref[1] = 0.1317228477799e+01;
  104|      0|    xcrref[2] = 0.2550120713095e+01;
  105|      0|    xcrref[3] = 0.2326187750252e+01;
  106|      0|    xcrref[4] = 0.2826799444189e+02;
  107|       |
  108|       |    //---------------------------------------------------------------------
  109|       |    // Reference values of RMS-norms of solution error, 
  110|       |    // for the (33X33X33) grid,
  111|       |    //---------------------------------------------------------------------
  112|      0|    xceref[0] = 0.4867877144216e+00;
  113|      0|    xceref[1] = 0.5064652880982e-01;
  114|      0|    xceref[2] = 0.9281818101960e-01;
  115|      0|    xceref[3] = 0.8570126542733e-01;
  116|      0|    xceref[4] = 0.1084277417792e+01;
  117|       |
  118|       |    //---------------------------------------------------------------------
  119|       |    // Reference value of surface integral, for the (33X33X33) grid,
  120|       |    // after 300 time steps, with  DT = 1.5e-3
  121|       |    //---------------------------------------------------------------------
  122|      0|    xciref    = 0.1161399311023e+02;
  123|       |
  124|      1|  } else if ((nx0 == 64) && (ny0 == 64) && (nz0 == 64) && (itmax == 250)) {
  125|       |
  126|      1|    *Class = 'A';
  127|      1|    dtref = 2.0e+0;
  128|       |    //---------------------------------------------------------------------
  129|       |    // Reference values of RMS-norms of residual, for the (64X64X64) grid,
  130|       |    // after 250 time steps, with  DT = 2.0e+00
  131|       |    //---------------------------------------------------------------------
  132|      1|    xcrref[0] = 7.7902107606689367e+02;
  133|      1|    xcrref[1] = 6.3402765259692870e+01;
  134|      1|    xcrref[2] = 1.9499249727292479e+02;
  135|      1|    xcrref[3] = 1.7845301160418537e+02;
  136|      1|    xcrref[4] = 1.8384760349464247e+03;
  137|       |
  138|       |    //---------------------------------------------------------------------
  139|       |    // Reference values of RMS-norms of solution error, 
  140|       |    // for the (64X64X64) grid,
  141|       |    // after 250 time steps, with  DT = 2.0e+00
  142|       |    //---------------------------------------------------------------------
  143|      1|    xceref[0] = 2.9964085685471943e+01;
  144|      1|    xceref[1] = 2.8194576365003349e+00;
  145|      1|    xceref[2] = 7.3473412698774742e+00;
  146|      1|    xceref[3] = 6.7139225687777051e+00;
  147|      1|    xceref[4] = 7.0715315688392578e+01;
  148|       |
  149|       |    //---------------------------------------------------------------------
  150|       |    // Reference value of surface integral, for the (64X64X64) grid,
  151|       |    // after 250 time steps, with DT = 2.0e+00
  152|       |    //---------------------------------------------------------------------
  153|      1|    xciref = 2.6030925604886277e+01;
  154|       |
  155|      1|  } else if ((nx0 == 102) && (ny0 == 102) && (nz0 == 102) && (itmax == 250)) {
  156|       |
  157|      0|    *Class = 'B';
  158|      0|    dtref = 2.0e+0;
  159|       |
  160|       |    //---------------------------------------------------------------------
  161|       |    // Reference values of RMS-norms of residual, for the (102X102X102) grid,
  162|       |    // after 250 time steps, with  DT = 2.0e+00
  163|       |    //---------------------------------------------------------------------
  164|      0|    xcrref[0] = 3.5532672969982736e+03;
  165|      0|    xcrref[1] = 2.6214750795310692e+02;
  166|      0|    xcrref[2] = 8.8333721850952190e+02;
  167|      0|    xcrref[3] = 7.7812774739425265e+02;
  168|      0|    xcrref[4] = 7.3087969592545314e+03;
  169|       |
  170|       |    //---------------------------------------------------------------------
  171|       |    // Reference values of RMS-norms of solution error, for the (102X102X102) 
  172|       |    // grid, after 250 time steps, with  DT = 2.0e+00
  173|       |    //---------------------------------------------------------------------
  174|      0|    xceref[0] = 1.1401176380212709e+02;
  175|      0|    xceref[1] = 8.1098963655421574e+00;
  176|      0|    xceref[2] = 2.8480597317698308e+01;
  177|      0|    xceref[3] = 2.5905394567832939e+01;
  178|      0|    xceref[4] = 2.6054907504857413e+02;
  179|       |
  180|       |    //---------------------------------------------------------------------
  181|       |    // Reference value of surface integral, for the (102X102X102) grid,
  182|       |    // after 250 time steps, with DT = 2.0e+00
  183|       |    //---------------------------------------------------------------------
  184|      0|    xciref = 4.7887162703308227e+01;
  185|       |
  186|      0|  } else if ((nx0 == 162) && (ny0 == 162) && (nz0 == 162) && (itmax == 250)) {
  187|       |
  188|      0|    *Class = 'C';
  189|      0|    dtref = 2.0e+0;
  190|       |
  191|       |    //---------------------------------------------------------------------
  192|       |    // Reference values of RMS-norms of residual, for the (162X162X162) grid,
  193|       |    // after 250 time steps, with  DT = 2.0e+00
  194|       |    //---------------------------------------------------------------------
  195|      0|    xcrref[0] = 1.03766980323537846e+04;
  196|      0|    xcrref[1] = 8.92212458801008552e+02;
  197|      0|    xcrref[2] = 2.56238814582660871e+03;
  198|      0|    xcrref[3] = 2.19194343857831427e+03;
  199|      0|    xcrref[4] = 1.78078057261061185e+04;
  200|       |
  201|       |    //---------------------------------------------------------------------
  202|       |    // Reference values of RMS-norms of solution error, for the (162X162X162) 
  203|       |    // grid, after 250 time steps, with  DT = 2.0e+00
  204|       |    //---------------------------------------------------------------------
  205|      0|    xceref[0] = 2.15986399716949279e+02;
  206|      0|    xceref[1] = 1.55789559239863600e+01;
  207|      0|    xceref[2] = 5.41318863077207766e+01;
  208|      0|    xceref[3] = 4.82262643154045421e+01;
  209|      0|    xceref[4] = 4.55902910043250358e+02;
  210|       |
  211|       |    //---------------------------------------------------------------------
  212|       |    // Reference value of surface integral, for the (162X162X162) grid,
  213|       |    // after 250 time steps, with DT = 2.0e+00
  214|       |    //---------------------------------------------------------------------
  215|      0|    xciref = 6.66404553572181300e+01;
  216|       |
  217|       |    //---------------------------------------------------------------------
  218|       |    // Reference value of surface integral, for the (162X162X162) grid,
  219|       |    // after 250 time steps, with DT = 2.0e+00
  220|       |    //---------------------------------------------------------------------
  221|      0|    xciref = 6.66404553572181300e+01;
  222|       |
  223|      0|  } else if ((nx0 == 408) && (ny0 == 408) && (nz0 == 408) && (itmax == 300)) {
  224|       |
  225|      0|    *Class = 'D';
  226|      0|    dtref = 1.0e+0;
  227|       |
  228|       |    //---------------------------------------------------------------------
  229|       |    // Reference values of RMS-norms of residual, for the (408X408X408) grid,
  230|       |    // after 300 time steps, with  DT = 1.0e+00
  231|       |    //---------------------------------------------------------------------
  232|      0|    xcrref[0] = 0.4868417937025e+05;
  233|      0|    xcrref[1] = 0.4696371050071e+04;
  234|      0|    xcrref[2] = 0.1218114549776e+05;
  235|      0|    xcrref[3] = 0.1033801493461e+05;
  236|      0|    xcrref[4] = 0.7142398413817e+05;
  237|       |
  238|       |    //---------------------------------------------------------------------
  239|       |    // Reference values of RMS-norms of solution error, for the (408X408X408) 
  240|       |    // grid, after 300 time steps, with  DT = 1.0e+00
  241|       |    //---------------------------------------------------------------------
  242|      0|    xceref[0] = 0.3752393004482e+03;
  243|      0|    xceref[1] = 0.3084128893659e+02;
  244|      0|    xceref[2] = 0.9434276905469e+02;
  245|      0|    xceref[3] = 0.8230686681928e+02;
  246|      0|    xceref[4] = 0.7002620636210e+03;
  247|       |
  248|       |    //---------------------------------------------------------------------
  249|       |    // Reference value of surface integral, for the (408X408X408) grid,
  250|       |    // after 300 time steps, with DT = 1.0e+00
  251|       |    //---------------------------------------------------------------------
  252|      0|    xciref =    0.8334101392503e+02;
  253|       |
  254|      0|  } else if ((nx0 == 1020) && (ny0 == 1020) && (nz0 == 1020) && 
  255|      0|             (itmax == 300)) {
  256|       |
  257|      0|    *Class = 'E';
  258|      0|    dtref = 0.5e+0;
  259|       |
  260|       |    //---------------------------------------------------------------------
  261|       |    // Reference values of RMS-norms of residual, 
  262|       |    // for the (1020X1020X1020) grid,
  263|       |    // after 300 time steps, with  DT = 0.5e+00
  264|       |    //---------------------------------------------------------------------
  265|      0|    xcrref[0] = 0.2099641687874e+06;
  266|      0|    xcrref[1] = 0.2130403143165e+05;
  267|      0|    xcrref[2] = 0.5319228789371e+05;
  268|      0|    xcrref[3] = 0.4509761639833e+05;
  269|      0|    xcrref[4] = 0.2932360006590e+06;
  270|       |
  271|       |    //---------------------------------------------------------------------
  272|       |    // Reference values of RMS-norms of solution error, 
  273|       |    // for the (1020X1020X1020) 
  274|       |    // grid, after 300 time steps, with  DT = 0.5e+00
  275|       |    //---------------------------------------------------------------------
  276|      0|    xceref[0] = 0.4800572578333e+03;
  277|      0|    xceref[1] = 0.4221993400184e+02;
  278|      0|    xceref[2] = 0.1210851906824e+03;
  279|      0|    xceref[3] = 0.1047888986770e+03;
  280|      0|    xceref[4] = 0.8363028257389e+03;
  281|       |
  282|       |    //---------------------------------------------------------------------
  283|       |    // Reference value of surface integral, for the (1020X1020X1020) grid,
  284|       |    // after 300 time steps, with DT = 0.5e+00
  285|       |    //---------------------------------------------------------------------
  286|      0|    xciref =    0.9512163272273e+02;
  287|       |
  288|      0|  } else {
  289|      0|    *verified = false;
  290|      0|  }
  291|       |
  292|       |  //---------------------------------------------------------------------
  293|       |  // verification test for residuals if gridsize is one of 
  294|       |  // the defined grid sizes above (*Class != 'U')
  295|       |  //---------------------------------------------------------------------
  296|       |
  297|       |  //---------------------------------------------------------------------
  298|       |  // Compute the difference of solution values and the known reference values.
  299|       |  //---------------------------------------------------------------------
  300|      6|  for (m = 0; m < 5; m++) {
  301|      5|    xcrdif[m] = fabs((xcr[m]-xcrref[m])/xcrref[m]);
  302|      5|    xcedif[m] = fabs((xce[m]-xceref[m])/xceref[m]);
  303|      5|  }
  304|      1|  xcidif = fabs((xci - xciref)/xciref);
  305|       |
  306|       |
  307|       |  //---------------------------------------------------------------------
  308|       |  // Output the comparison of computed results to known cases.
  309|       |  //---------------------------------------------------------------------
  310|      1|  if (*Class != 'U') {
  311|      1|    printf("\n Verification being performed for class %c\n", *Class);
  312|      1|    printf(" Accuracy setting for epsilon = %20.13E\n", epsilon);
  313|      1|    *verified = (fabs(dt-dtref) <= epsilon);
  314|      1|    if (!(*verified)) {
  315|      0|      *Class = 'U';
  316|      0|      printf(" DT does not match the reference value of %15.8E\n", dtref);
  317|      0|    }
  318|      1|  } else { 
  319|      0|    printf(" Unknown class\n");
  320|      0|  }
  321|       |
  322|      1|  if (*Class != 'U') {
  323|      1|    printf(" Comparison of RMS-norms of residual\n");
  324|      1|  } else {
  325|      0|    printf(" RMS-norms of residual\n");
  326|      0|  }
  327|       |
  328|      6|  for (m = 0; m < 5; m++) {
  329|      5|    if (*Class == 'U') {
  330|      0|      printf("          %2d  %20.13E\n", m+1, xcr[m]);
  331|      5|    } else if (xcrdif[m] <= epsilon) {
  332|      5|      printf("          %2d  %20.13E%20.13E%20.13E\n", 
  333|      5|          m+1 ,xcr[m], xcrref[m], xcrdif[m]);
  334|      5|    } else { 
  335|      0|      *verified = false;
  336|      0|      printf(" FAILURE: %2d  %20.13E%20.13E%20.13E\n",
  337|      0|          m+1, xcr[m], xcrref[m], xcrdif[m]);
  338|      0|    }
  339|      5|  }
  340|       |
  341|      1|  if (*Class != 'U') {
  342|      1|    printf(" Comparison of RMS-norms of solution error\n");
  343|      1|  } else {
  344|      0|    printf(" RMS-norms of solution error\n");
  345|      0|  }
  346|       |
  347|      6|  for (m = 0; m < 5; m++) {
  348|      5|    if (*Class == 'U') {
  349|      0|      printf("          %2d  %20.13E\n", m+1, xce[m]);
  350|      5|    } else if (xcedif[m] <= epsilon) {
  351|      5|      printf("          %2d  %20.13E%20.13E%20.13E\n", 
  352|      5|          m+1, xce[m], xceref[m], xcedif[m]);
  353|      5|    } else {
  354|      0|      *verified = false;
  355|      0|      printf(" FAILURE: %2d  %20.13E%20.13E%20.13E\n",
  356|      0|          m+1, xce[m], xceref[m], xcedif[m]);
  357|      0|    }
  358|      5|  }
  359|       |
  360|      1|  if (*Class != 'U') {
  361|      1|    printf(" Comparison of surface integral\n");
  362|      1|  } else {
  363|      0|    printf(" Surface integral\n");
  364|      0|  }
  365|       |
  366|      1|  if (*Class == 'U') {
  367|      0|    printf("              %20.13E\n", xci);
  368|      1|  } else if (xcidif <= epsilon) {
  369|      1|    printf("              %20.13E%20.13E%20.13E\n", xci, xciref, xcidif);
  370|      1|  } else {
  371|      0|    *verified = false;
  372|      0|    printf(" FAILURE:     %20.13E%20.13E%20.13E\n", xci, xciref, xcidif);
  373|      0|  }
  374|       |
  375|      1|  if (*Class == 'U') {
  376|      0|    printf(" No reference values provided\n");
  377|      0|    printf("No verification performed\n");
  378|      1|  } else if (*verified) {
  379|      1|    printf(" Verification Successful\n");
  380|      1|  } else {
  381|      0|    printf(" Verification failed\n");
  382|      0|  }
  383|      1|}
  384|       |

/home/dvmuser3/andrey/npb-3.3-c/common/c_timers.c:
    1|       |#include "wtime.h"
    2|       |#include <stdlib.h>
    3|       |
    4|       |/*  Prototype  */
    5|       |void wtime( double * );
    6|       |
    7|       |
    8|       |/*****************************************************************/
    9|       |/******         E  L  A  P  S  E  D  _  T  I  M  E          ******/
   10|       |/*****************************************************************/
   11|       |static double elapsed_time( void )
   12|      4|{
   13|      4|    double t;
   14|       |
   15|      4|    wtime( &t );
   16|      4|    return( t );
   17|      4|}
   18|       |
   19|       |
   20|       |static double start[64], elapsed[64];
   21|       |
   22|       |/*****************************************************************/
   23|       |/******            T  I  M  E  R  _  C  L  E  A  R          ******/
   24|       |/*****************************************************************/
   25|       |void timer_clear( int n )
   26|     44|{
   27|     44|    elapsed[n] = 0.0;
   28|     44|}
   29|       |
   30|       |
   31|       |/*****************************************************************/
   32|       |/******            T  I  M  E  R  _  S  T  A  R  T          ******/
   33|       |/*****************************************************************/
   34|       |void timer_start( int n )
   35|      2|{
   36|      2|    start[n] = elapsed_time();
   37|      2|}
   38|       |
   39|       |
   40|       |/*****************************************************************/
   41|       |/******            T  I  M  E  R  _  S  T  O  P             ******/
   42|       |/*****************************************************************/
   43|       |void timer_stop( int n )
   44|      2|{
   45|      2|    double t, now;
   46|       |
   47|      2|    now = elapsed_time();
   48|      2|    t = now - start[n];
   49|      2|    elapsed[n] += t;
   50|       |
   51|      2|}
   52|       |
   53|       |
   54|       |/*****************************************************************/
   55|       |/******            T  I  M  E  R  _  R  E  A  D             ******/
   56|       |/*****************************************************************/
   57|       |double timer_read( int n )
   58|      2|{
   59|      2|    return( elapsed[n] );
   60|      2|}
   61|       |

/home/dvmuser3/andrey/npb-3.3-c/common/print_results.c:
    1|       |#include <stdio.h>
    2|       |#include <math.h>
    3|       |#include "type.h"
    4|       |
    5|       |
    6|       |void print_results(char *name, char class, int n1, int n2, int n3, int niter,
    7|       |    double t, double mops, char *optype, logical verified, char *npbversion,
    8|       |    char *compiletime, char *cs1, char *cs2, char *cs3, char *cs4, char *cs5,
    9|       |    char *cs6, char *cs7) 
   10|      1|{
   11|      1|  char size[16];
   12|      1|  int j;
   13|       |
   14|      1|  printf( "\n\n %s Benchmark Completed.\n", name );
   15|      1|  printf( " Class           =             %12c\n", class );
   16|       |
   17|       |  // If this is not a grid-based problem (EP, FT, CG), then
   18|       |  // we only print n1, which contains some measure of the
   19|       |  // problem size. In that case, n2 and n3 are both zero.
   20|       |  // Otherwise, we print the grid size n1xn2xn3
   21|       |
   22|      1|  if ( ( n2 == 0 ) && ( n3 == 0 ) ) {
   23|      0|    if ( ( name[0] == 'E' ) && ( name[1] == 'P' ) ) {
   24|      0|      sprintf( size, "%15.0lf", pow(2.0, n1) );
   25|      0|      j = 14;
   26|      0|      if ( size[j] == '.' ) {
   27|      0|        size[j] = ' '; 
   28|      0|        j--;
   29|      0|      }
   30|      0|      size[j+1] = '\0';
   31|      0|      printf( " Size            =          %15s\n", size );
   32|      0|    } else {
   33|      0|      printf( " Size            =             %12d\n", n1 );
   34|      0|    }
   35|      1|  } else {
   36|      1|    printf( " Size            =           %4dx%4dx%4d\n", n1, n2, n3 );
   37|      1|  }
   38|       |
   39|      1|  printf( " Iterations      =             %12d\n", niter );
   40|      1|  printf( " Time in seconds =             %12.2lf\n", t );
   41|      1|  printf( " Mop/s total     =          %15.2lf\n", mops );
   42|      1|  printf( " Operation type  = %24s\n", optype );
   43|      1|  if ( verified ) 
   44|      1|    printf( " Verification    =             %12s\n", "SUCCESSFUL" );
   45|      0|  else
   46|      0|    printf( " Verification    =             %12s\n", "UNSUCCESSFUL" );
   47|      1|  printf( " Version         =             %12s\n", npbversion );
   48|      1|  printf( " Compile date    =             %12s\n", compiletime );
   49|       |  
   50|      1|  printf( "\n Compile options:\n"
   51|      1|          "    CC           = %s\n", cs1 );
   52|      1|  printf( "    CLINK        = %s\n", cs2 );
   53|      1|  printf( "    C_LIB        = %s\n", cs3 );
   54|      1|  printf( "    C_INC        = %s\n", cs4 );
   55|      1|  printf( "    CFLAGS       = %s\n", cs5 );
   56|      1|  printf( "    CLINKFLAGS   = %s\n", cs6 );
   57|      1|  printf( "    RAND         = %s\n", cs7 );
   58|       |
   59|      1|  printf( "\n--------------------------------------\n"
   60|      1|          " Please send all errors/feedbacks to:\n"
   61|      1|          " Center for Manycore Programming\n"
   62|      1|          " cmp@aces.snu.ac.kr\n"
   63|      1|          " http://aces.snu.ac.kr\n"
   64|      1|          "--------------------------------------\n\n");
   65|      1|}

/home/dvmuser3/andrey/npb-3.3-c/common/type.h:
    1|       |#ifndef __TYPE_H__
    2|       |#define __TYPE_H__
    3|       |
    4|       |typedef enum { false, true } logical;
    5|       |typedef struct { 
    6|       |  double real;
    7|       |  double imag;
    8|       |} dcomplex;
    9|       |
   10|       |
   11|       |#define min(x,y)    ((x) < (y) ? (x) : (y))
   12|      2|#define max(x,y)    ((x) > (y) ? (x) : (y))
   13|       |
   14|       |#endif //__TYPE_H__

/home/dvmuser3/andrey/npb-3.3-c/common/wtime.c:
    1|       |#include "wtime.h"
    2|       |#include <time.h>
    3|       |#ifndef DOS
    4|       |#include <sys/time.h>
    5|       |#endif
    6|       |
    7|       |void wtime(double *t)
    8|      4|{
    9|      4|  static int sec = -1;
   10|      4|  struct timeval tv;
   11|      4|  gettimeofday(&tv, (void *)0);
   12|      4|  if (sec < 0) sec = tv.tv_sec;
   13|      4|  *t = (tv.tv_sec - sec) + 1.0e-6*tv.tv_usec;
   14|      4|}
   15|       |
   16|       |    

/home/dvmuser3/andrey/npb-3.3-c/common/wtime.h:
    1|       |/* C/Fortran interface is different on different machines. 
    2|       | * You may need to tweak this.
    3|       | */
    4|       |
    5|       |
    6|       |#if defined(IBM)
    7|       |#define wtime wtime
    8|       |#elif defined(CRAY)
    9|       |#define wtime WTIME
   10|       |#else
   11|      4|#define wtime wtime_
   12|       |#endif

